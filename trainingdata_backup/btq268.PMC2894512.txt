            G:\bioinformatics\Bioinfo-26(14)issue\btq268.dvi [10:29 16/6/2010 Bioinformatics-btq268.tex] Page: 1699 16991703 BIOINFORMATICS ORIGINAL PAPER Vol.
26 no.
14 2010, pages 16991703doi:10.1093/bioinformatics/btq268 Genome analysis Advance Access publication May 30, 2010 Gap5editing the billion fragment sequence assembly James K. Bonfield and Andrew Whitwham Wellcome Trust Sanger Institute, Wellcome Trust Genome Campus, Cambridge, CB10 1SA, UK Associate Editor: Dmitrij Frishman ABSTRACT Motivation: Existing sequence assembly editors struggle with the volumes of data now readily available from the latest generation of DNA sequencing instruments.
Results: We describe the Gap5 software along with the data structures and algorithms used that allow it to be scalable.
We demonstrate this with an assembly of 1.1 billion sequence fragments and compare the performance with several other programs.
We analyse the memory, CPU, I/O usage and file sizes used by Gap5.
Availability and Implementation: Gap5 is part of the Staden Package and is available under an Open Source licence from http://staden.sourceforge.net.
It is implemented in C and Tcl/Tk.
Currently it works on Unix systems only.
Contact: jkb@sanger.ac.uk Supplementary information: Supplementary data are available at Bioinformatics online.
Received on March 26, 2010; revised on May 17, 2010; accepted on May 18, 2010 1 INTRODUCTION With the latest wave of DNAsequencing technologies (Bentley et al., 2008; Margulies et al., 2005; Pandey et al., 2008), the number of individual fragments readily available for both mapping and de novo assemblies has grown many fold.
This has often been coupled with a shortening of each individual fragment.
As a consequence, a full mapping of the entire human genome may conceivably have as many as a billion fragments.
While many applications of new sequencing technologies make use of mapped assemblies, de novo sequence assembly is still common.
These may contain misassemblies or require further finishing work to resolve gaps (Chain et al., 2009).
To progress from the draft standard toward finished sequence, we need tools capable of both viewing and editing our large-scale assemblies.
Traditional algorithms used in earlier sequence assembly viewers and editors such as Gap4 (Bonfield et al., 1995), Consed (Gordon et al., 1998), HawkEye (Schatz et al., 2007) and EagleView (Huang and Marth, 2008) tend to scale poorly with the number of fragments.
For example, Gap4s memory and CPU usage typically scale linearly with the number of fragments in the assembly.
It became clear that the underlying data structures in these older tools are insufficient for the data volumes that we now routinely see.
Recently several viewers including SAMtools (Li et al., 2009), MapView (Bao et al., 2009), IGV (http://www.broadinstitute.org/ igv), Tablet (Milne et al., 2010) and NGSView (Arner et al., 2010) have been released that aim to reduce the algorithmic complexity To whom correspondence should be addressed.
and memory footprint.
However, the solutions typically employed by these programs are only amenable for read-only access, with the exception of NGSView that can perform some minor editing tasks.
In addition to algorithmic efficiency, the large increase in the number of DNA fragments has put a strain on our storage requirements.
By using data compression methods, the storage burden can be greatly reduced, with the BAM file format being one such recent example.
When coupled with an index, compressed BAM files can be randomly accessed.
We present the Gap5 program: a sequence assembly viewer and editor.
This encompasses both base by base editing operations as well as high-level contig rearrangements (complementing, breaking and joining).
Being able to change data has a substantial impact on the choice of data structures and file formats, which are described below.
We also demonstrate the compression techniques used in Gap5 and compare their effectiveness to existing tools.
2 METHODS AND ALGORITHMS A fundamental challenge for any assembly viewer or editor is how to identify which sequences are visible within a specific region or range, such as the portion of an assembly currently shown on screen.
Without an index this range query requires a linear scan, having O(N) complexity, where N is the number of sequences to search through.
Some newer file formats, including MVF (MapView) and CALF (http://www.phrap.org/phredphrap/calf.pdf), make use of an index on the sequence start coordinates.
This works well provided we can place a tight upper bound on the maximum length of any sequence.
We can rapidly identify sequences entirely within our range query, but to identify those completely spanning the range we have to search backwards, up to the maximum sequence length base pairs away from our range boundaries.
If we wish to mix both short and long sequence fragments together this can become inefficient.
To address this programs such as SAMtools (implementing the SAM and BAM file formats) and the UCSC genome browser (Kent et al., 2002) employ spatial indexing (or multidimensional indexing) techniques, e.g.recursive binning and R-Trees (Guttman, 1984).
These mechanisms index on both the start and end positions at the same time meaning that we can rapidly interrogate the index to identify sequences visible within a given range, typically in O(Rlog(N)) complexity, where N is the length of the contig and R is the size of the query range.
For Gap5, we chose a recursive binning algorithm.
A contig has a root bin, which in turn has two child bins, repeating in a recursive manner to form a binary tree of bins until we reach a minimum bin size.
Sequences and annotations are then placed in the smallest bin that they entirely fit within (Fig.1).
For an editor another major problem to resolve is how to move data.
Storing the absolute position of a sequence leads to algorithmic inefficiencies.
Unfortunately this technique was employed in Gap4s database, CAF (Dear et al., 1998) and ACE file formats, and even in newer short-read formats such as CALF, SAM, BAM and MVF.
If we perform an edit that moves sequences within a contig, such as making an insertion or joining the contig to another, then we need to alter the location of potentially every sequence within that contig.
The Author(s) 2010.
Published by Oxford University Press.
This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/2.5), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.
[10:29 16/6/2010 Bioinformatics-btq268.tex] Page: 1700 16991703 J.K.Bonfield and A.Whitwham Sequences Bin Contig Fig.1.
Binning tree containing sequences from two libraries (represented by solid and dashed lines).
Information about the sequence positions and pairings is stored in the bin records, while the sequence names, DNA and qualities are held in the sequence records.
One solution to this comes from making sure that the location of sequences and annotations are stored relative to the bin they have been placed within.
Additionally, the location of a bin itself is stored relative to its parent bin.
With all positional data being relative to the parent object, we can now shift entire portions of a contig with just O(log(N)) operations.
There is one further editing operation that needs special attention: complementing a contig.
If we choose to have a single status flag on the contig indicating whether this entire contig is to be viewed in the original or complemented orientation, we will have a problem when we wish to join it to a contig of the opposite orientation.
For example, if we wish to join contig A to the complement of contig B, then the resulting contig will have a mixture of complemented and uncomplemented data.
We do not wish to actually reverse complement the data in contig B as this may require millions of changes to be made.
To resolve this, each bin has a flag indicating whether it and its children are complemented with respect to its parent bin.
This permits multiple complement and join operations to occur with the minimum of data editing.
The bins can also serve as a way to cache data views at different zoom levels.
When showing a narrow region at high magnification, we will query deep into our tree; when showing a very large region at low magnification, we may only need to query the top few levels of bins to achieve the desired resolution.
So far this has only been implemented experimentally to store sequence depth data.
By storing a fixed number of data points per bin, regardless of the number of bases they span, we can rapidly draw the sequence depth at any zoom level with a minimum amount of disk I/O.
These bin tracks simply act as caches for the actual algorithms that obtain the data to plot.
They are invalidated after some types of edits and are recomputed on demand.
In a similar, albeit simpler manner we use one layer in the bin tree to store cached fragments of the consensus.
This means that after changing the data we can mark small portions of the consensus as invalid, reducing the overhead of recomputing it.
When interactively scrolling through a contig, most of the data required to perform the range query will have been recently loaded for a previous query, as the path down the bin tree will typically be the same except for a few leaf nodes.
By keeping a cache of recently accessed records in memory, we substantially reduce the I/O overhead.
To achieve this all database records are accessed via a data structure, we term as a HacheTable: a caching hash table.
The programmatic interface to this gives the appearance of all database records being held within memory; however, only the most recently used items are stored with older items being discarded to keep memory usage low.
The hache hit rate while scrolling is typically >99%.
The same HacheTable is also used to keep track of edited objects by locking these items to prevent Fig.2.
Contig editor, showing quality values by gray scales and mismatches to the consensus by base color.
them from being discarded.
When the user saves changes to disk the lock status is used as an indicator of which objects to save.
3 IMPLEMENTATION Gap5 is primarily written in C (Kernighan.
and Ritchie, 1988) for efficiency and Tcl/Tk (Ousterhout, 1990) for the graphical user interface.
The use of Tcl also means we have an inbuilt scripting language allowing user-controlled automation of many of Gap5s capabilities.
Many of the Staden Package libraries used by Gap4 have also been reused for Gap5, making Gap5 a direct descendent of Gap4.
However, many of the algorithms and data structures first appeared in tg_view: a prototype text-based editor and viewer.
This was first publicly released in 2007 (unpublished data) as the tgap package and was initially used as a viewer for MAQ (Li et al., 2008) alignments.
For visualization, Gap5 shares a lot of common features with its ancestor Gap4.
The contig editor (Fig.2) displays sequences along with their per-base quality values as gray scales.
Discrepancies between the sequence and the consensus may be automatically highlighted by either color or symbol.
Sequence names and/or mapping qualities, if known, are shown in the left panel.
To save vertical space multiple sequences may be packed onto one display line.
To obtain a broader view of an assembly the sequences may be shown pictorially using the template display.
This draws one line per sequencing template, with the horizontal size and placement governed by the location of the forward and reverse sequence fragments.
Colors are used to distinguish templates where the forward and reverse fragments are in separate contigs, have an inconsistent (unexpected) orientation or are single-ended sequencing templates only.
We draw either a traditional assembly illustration with the Y coordinate being used simply to separate overlapping sequences (Supplementary Material), or a LookSeq (Manske and Kwiatkowski, 2009) style plot, where the Y coordinate is governed by the insert size.
This latter type of plot is particularly effective at identifying regions where indels have occurred (Fig.3).
We observe that to draw the template display, we need to know only sequence start and end coordinates, mapping scores, mate pairs and a few status flags.
The sequence structures constitute the vast bulk of the database size so it is costly to extract this information from the sequence structures themselves.
However, as previously described, a contig bin contains
