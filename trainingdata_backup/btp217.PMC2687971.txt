ABSTRACT Motivation: Developing methods for computing phylogenetic networks from biological data is an important problem posed by molecular evolution and much work is currently being undertaken in this area.
Although promising approaches exist, there are no tools available that biologists could easily and routinely use to compute rooted phylogenetic networks on real datasets containing tens or hundreds of taxa.
Biologists are interested in clades, i.e.groups of monophyletic taxa, and these are usually represented by clusters in a rooted phylogenetic tree.
The problem of computing an optimal rooted phylogenetic network from a set of clusters, is hard, in general.
Indeed, even the problem of just determining whether a given network contains a given cluster is hard.
Hence, some researchers have focused on topologically restricted classes of networks, such as galled trees and level-k networks, that are more tractable, but have the practical draw-back that a given set of clusters will usually not possess such a representation.
Results: In this article, we argue that galled networks (a generalization of galled trees) provide a good trade-off between level of generality and tractability.
Any set of clusters can be represented by some galled network and the question whether a cluster is contained in such a network is easy to solve.
Although the computation of an optimal galled network involves successively solving instances of two different NP-complete problems, in practice our algorithm solves this problem exactly on large datasets containing hundreds of taxa and many reticulations in seconds, as illustrated by a dataset containing 279 prokaryotes.
Availability: We provide a fast, robust and easy-to-use implementation of this work in version 2.0 of our tree-handling software Dendroscope, freely available fromContact: huson@informatik.uni-tuebingen.de 1 INTRODUCTION Developing appropriate methods for computing phylogenetic networks from biological data has been described as one of the five most important challenges posed to mathematics by biology (Cohen, 2004) and there is a lot of recent work focused on this topic (Doolittle and Bapteste, 2007): One area of research is recombination networks, which have been studied in the context of population genetics for many years, e.g.(Hein, 1993; Lyngs et al., 2005; Song and Hein, 2005), and have recently received To whom correspondence should be addressed.
more attention in the guise of galled trees and related concepts, e.g.(Gusfield and Bansal, 2005; Gusfield et al., 2003; Huson and Kloepper, 2005).
Here, the task is to compute a rooted phylogenetic network from a set of binary sequences.
A second area is hybridization networks (Bordewich et al., 2007; Huson et al., 2005; Linder and Rieseberg, 2004), where the goal is to compute a rooted phylogenetic network from a set of incongruent trees.
A third area is HGT networks, where the goal usually is to explain the discrepancies between gene trees (or gene content) and a species tree, e.g (Hallett and Lagergren, 2001; Mirkin et al., 2003).
Another area of research focuses on the computation of rooted networks from triplets (van Iersel et al., 2008).
One type of unrooted phylogenetic network, called a split network (Bandelt and Dress, 1992), is widely used as a tool for displaying incompatible datasets.
Its popularity is probably due to the existence of a user-friendly program (Huson and Bryant, 2006) that contains a number of methods, such as Neighbor-net (Bryant and Moulton, 2002) or the Z-closure super network method (Huson et al., 2004), for computing such networks.
The current state of the art for rooted phylogenetic networks, on the other hand, can be characterized as follows: there are many promising directions to follow and some rudimentary software implementations (Huber et al., 2007; Than et al., 2008; van Iersel and Kelk, 2008).
However, there is no tool currently available that biologists could easily and routinely use on real data.
This is an unfortunate state of affairs, because biologists are more interested in rooted networks than in unrooted networks, just as they are more interested in rooted trees than in unrooted ones.
(Unrooted networks are very different from rooted networks, so constructions for unrooted networks usually do not carry over to rooted networks.)
The aim of this article is to help fill this gap by providing a theoretically well-founded and practically well-implemented and easy-to-use method for computing rooted phylogenetic networks from a set of clusters, for example, extracted from a set of phylogenetic trees, or directly from sequences.
Our approach is based on the concept of a galled network, which is a generalization of the concept of a galled tree.
Continuing work started Huson and Kloepper (2007), here we make new contributions to a number of topics, including: complexity of the cluster containment problem, existence of a galled network, desirability of the decomposition property, role of incompatibility statements, complexity and solution of the (RMSC) problem, formulation, complexity and solution of the MinimumAttachment problem (MAP), user-friendly, robust and fast implementation of all algorithms, aimed at real data.
We believe that galled networks provide a good trade-off between level of generality and ease of practical computability.
2009 The Author(s) This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/2.0/uk/) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.
[10:06 15/5/2009 Bioinformatics-btp217.tex] Page: i86 i85i93 D.H.Huson et al.As we will show in this article, one main advantage of galled networks is that the Cluster Containment problem is easy to solve for them.
This is not true for general rooted phylogenetic networks (Kanj et al., 2008).
In consequence, one can easily verify algorithmically that a galled network actually contains all the clusters that it claims to represent and a user of the network can easily locate a cluster of interest.
Galled networks are particularly applicable if the dataset can basically be represented by a tree, to which some reticulations are attached.
In such cases, the computed network explicitly provides a possible evolutionary scenario.
In more complicated situations (such as in population studies of sexually reproducing organisms), the network should only be seen as an abstract representation of the given cluster set.
We provide an implementation of our method aimed at phylogenetic trees (as input) in the new version 2.0 of our Dendroscope software (Huson et al., 2007).
We plan also to integrate the code into our SplitsTree software (Huson and Bryant, 2006), where it will be applicable to character sequences, too.
We demonstrate the performance of our algorithms using two different datasets.
The first is a collection of six trees on plant species, the size of the trees ranging from 19 to 65 taxa, on which we compare the performance of our algorithms with results reported in Bordewich et al.(2007).
The second dataset is a collection of nine trees, each on 279 prokaryotes (Auch et al., manuscript in preparation).
These examples demonstrate that our methods can be applied to reasonably large datasets in acceptable runtimes (usually only seconds).
2 GALLED NETWORKS COMPARED WITH GALLED TREES, LEVEL K NETWORKS AND MORE GENERAL ROOTED PHYLOGENETIC NETWORKS Let X be a set of taxa.
A rooted phylogenetic network N on X consists of a connected, directed, acyclic graph with a single node of in-degree 0, called the root, together with a bijective labeling of X onto the set of all leaves of N , i.e.all nodes of out-degree 0.
All nodes of in-degree 1 are called tree nodes and all others are called reticulate nodes or simply reticulations.
Any edge leading to a reticulate node is called a reticulate edge, and all others are called tree edges.
A cluster C of X is any proper subset of X , explicitly excluding both the empty set and the full set X.
Let C be a set of clusters on X.
We say that a rooted phylogenetic network N represents C in the hardwired sense, if there exists a one-to-one mapping between the set of clusters C and the set of tree edges in N such that for each cluster C the set of leaves reachable below the corresponding edge e is labeled precisely by C. For example, cluster networks, which we introduced in Huson and Rupp (2008), represent clusters in the hardwired sense, and can be computed efficiently.
We say that a rooted phylogenetic network N represents C in the softwired sense, or N is a softwired network, if for every cluster C C there exists some tree edge e in N and some switching of all reticulate nodes in N such that the set of leaves reachable below e is labeled precisely by C. By a switching of a reticulate node r, we mean a choice of exactly one ingoing edge of r that is considered turned on, whereas all other ingoing edges are considered turned off.
In the following, when we say that a cluster is represented by a tree edge in a network then we will always mean this in the softwired sense.
The basic idea behind the concept of a softwired network is that it describes the evolution of multiple genes or loci: the evolutionary history of any given gene or locus is described by a tree, embedded in the network and containing exactly one of the ingoing edges for each reticulate node of the network.
Let C be a set of clusters on X.
In practice, such a set of clusters is usually given as the set of all clusters present in a collection of rooted phylogenetic trees, or may come from an alignment of binary sequences.
In a number of papers mentioned above, the authors invoke the parsimony principle to argue that the best network to compute to represent a set of clusters (in the softwired sense) is one that minimizes the number of reticulation nodes contained in the network, as the underlying evolutionary events, for example, speciation by hybridization, are considered expensive.
As we will show later, there may be cases where saving a reticulation results in two completely unrelated parts of the phylogeny being linked together, so we will slightly alter the aim of the minimization so as to address this problem.
The problem of computing a miminal rooted phylogenetic network N that represents a given set of clusters C in the softwired sense is known to be hard.
In fact, even just the cluster containment problem of determining whether a given cluster C is represented by some given network N , is already NP-complete, see (Kanj et al., 2008).
Due to the computational difficulties associated with the general problem, researchers have studied rooted phylogenetic networks that fulfill certain topological constraints.
In Gusfield and colleagues (2003) introduced the concept of a galled tree, based on a condition introduced in Ma et al.(1998) and Wang et al.(2001), in which each biconnected component (as defined below) of the network contains at most one reticulate node.
Other authors have generalized this to level k networks (van Iersel et al., 2008), allowing at most k reticulate nodes in any biconnected component.
A practical drawback of these definitions is that for a given set of clusters there might not exist such a network (for a fixed level k).
So, any tool based on these concepts is liable to disappoint its users on some datasets.
In Huson and Kloepper (2007) we started developing an alternative generalization of galled trees called galled networks.
Definition 1.
A rooted phylogenetic network N is called a galled network, if for every reticulation r in N and every pair of reticulation edges p and q with target node r there exists a tree cycle, that is, an undirected cycle in N that passes through p followed by q and otherwise contains only tree edges.
The main idea behind this definition is that a galled network may be obtained by attaching one or more reticulations to a rooted phylogenetic backbone tree, see Figure 1.
A useful and easy consequence of this is that every reticulate node r in a galled network N is a cut node that separates the set of all nodes that are descendants of r from all other nodes in N (Huson and Kloepper, 2007).
This corresponds to a biological scenario in which reticulate events (such hybridization or horizontal gene transfer events) are quite rare.
As already mentioned, one advantage of galled networks over other restricted classes of rooted networks is that for any input set of clusters there always exists a corresponding galled network, unlike i86 [10:06 15/5/2009 Bioinformatics-btp217.tex] Page: i87 i85i93 Computing galled networks kjihgfedcba r rp q p q * Fig.1.
A galled network containing two reticulations r and r. The tree cycles associated with r and r are emphasized using dashed and dotted lines, respectively.
In contrast to a galled tree, in which all cycles are edge-disjoint, these two tree cycles share an edge, namely the one marked.
edcba ihgf v w e f Fig.2.
Any set of clusters on X can be represented by a galled network using a construction that is illustrated here for X ={a,...,i}.
For all leaves except the one labeled by the first taxon (in this example, a), the source of each leaf edge is a reticulate node that is connected to two parent nodes v and w. Any cluster C of X that contains the first taxon is represented by the tree edge e, whereas any cluster that does not contain the first taxon is represented by the tree edge f , in the softwired sense.
in the case of galled trees or level k networks (Fig.2).
Moreover, the cluster containment problem is easy to solve: Lemma 1.
(Cluster containment for galled networks).
The cluster containment for galled networks problem can be efficiently solved.
Proof.
We need to show how to determine whether a given tree edge e= (v,w) in a galled network N can represent a given cluster C. Let Le denote the set of all leaves below the node w that are reachable from w via a path of tree edges, and let Re denote the set of all reticulate nodes below w that are reachable from w via a path of tree edges, followed by a single reticulate edge.
The taxa that label the nodes in Le are contained in every cluster represented by e. As every reticulate node r in a galled network N is a cut node, we have two possibilities.
Either the set Yr of taxa below r is contained in every cluster represented by e, which happens when all parent nodes of r are descendants of w. Or Yr is an optional subset in the sense that a cluster represented by e must either contain all of Yr or none of Yr.
Finally, e represents C if and only if there exists a set RRe such that C =Le  rR Yr. 3 DECOMPOSITION OF PHYLOGENETIC NETWORKS Let C be a set of clusters on X.
Two clusters A,BC are called compatible, if they either are disjoint, or one contains the other, and are called incompatible, otherwise.
We call C pairwise compatible, if all pairs of clusters in C are compatible.
A basic result of phylogenetics states that a set of clusters C on X can be represented by a rooted phylogenetic tree, if and only if C is pairwise compatible.
We define the incompatibility graph IG(C)= (V ,E) for C as the graph with node set V =C and edge set E such that any two clusters A,BC are connected by an edge if and only if they are incompatible with each other.
Recall from basic graph theory that a connected component of an undirected graph G is defined as any maximal set of nodes U in G with the property that any two nodes in U are connected by a path in G. Similarly, a biconnected component is a subgraph of G induced by a maximal set of nodes U such that any two nodes v,wU are connected by two different (undirected) paths that are node-disjoint (except at v and w).
Let N be a rooted phylogenetic network that represents a set of clusters C. Because a cluster C may be represented by more than one edge in N , we define an edge assignment to be a mapping that chooses for each cluster C C a single tree edge (C) in N that represents it.
We say that N is a decomposable representation of C, or simply that N is decomposable, if there exists an edge assignment such that: for all pairs of clusters A,BC we have: the two edges (A) and (B) lie in the same biconnected component of N if and only if A and B lie in the same connected component of the incompatibility graph IG(C).
By definition, cluster networks (Huson and Rupp, 2008) and split networks (Bandelt and Dress, 1992) are always decomposable.
However, an example due to Yun Song shows that this property does not hold for more general rooted phylogenetic networks (Gusfield et al., 2007).
As we illustrate in Figure 3, it is sometimes possible to save one reticulation by replacing two completely unlinked and unrelated configurations, each containing two reticulations, by one configuration containing only three reticulations.
This construction does not reflect biology as it may link together totally unrelated and arbitrarily distant parts of a phylogeny, thus resulting in misleading networks, possibly bringing together nematodes and apes, for example.
To avoid this problem, but also for computational reasons, we propose to focus on decomposable representations.
As a consequence, we may decompose our task as follows (Gusfield and Bansal, 2005; Huson et al., 2005).
Suppose we are given a set of clusters C on X as input.
We first compute the connected components of IG(C) [either naively in time O(|C|2) by building the incompatibility graph, or directly, in subquadratic time (Charbit et al., 2008)].
Then, for each non-trivial connected component C C of IG(C) we compute a rooted phylogenetic network N for C. All these will then be fitted together to produce as output a final network N for C. We say that two taxa x,yX are separated if there exists a cluster AC with |{x,y}A|=1.
When considering such a subproblem C, we identify or collapse all taxa that are not separated by any cluster in C. As a consequence, throughout the next sections of the article, we may assume that for a set of clusters C on X the two following properties hold.
i87 [10:06 15/5/2009 Bioinformatics-btp217.tex] Page: i88 i85i93 D.H.Huson et al.e dc q h r b p a u s o'a'b'h'c'd'dchbao o o'a'b'h'c'd'dchbao s p p'r' u u' e e' r q q' (a) Phylogenetic network (b) Decomposable representation (c) Non-decomposable representation Fig.3.
(a) A minimum rooted network N that represents the clusters C={{a}, {b}, {c}, {d},{o}, {h},{a,b}, {a,b,h},{b,h}, {c,d}, {c,d,h}, {a,b,c,d,h}, {a,b,c,d}} using two reticulate nodes r and s. Note the role of the reticulate edge labeled u is to switch off the taxon h so that the cluster {a,b,c,d} can be represented by the tree edge e. (b) Two copies of N embedded into a decomposable network requiring four reticulations to represent all clusters in C and a second set C of corresponding ones on {o,a,b,c,d,h}.
(c) This network also represents all described clusters, but uses only three reticulations.
However, we clearly see that this improvement is gained at an undesirable price: decomposability is abandoned (all clusters in C are compatible with all clusters in C, yet they are all represented in the same biconnected component of the network) and so two completely unrelated parts of the phylogeny are linked together via reticulation edges.
(P1) The incompatibility graph IG(C) has only one connected component.
(P2) Every pair of taxa in X is separated.
In effect, our algorithm processes all connected components of the incompatibility graph sequentially.
4 DETERMINING A MINIMUM SET OF RETICULATIONS As discussed above, one way to think of galled networks is that they are constructed by attaching a number of reticulations to a phylogenetic tree.
Hence, to compute a galled network that uses a minimum number of reticulations, we will first determine a minimum set of reticulations [the Maximum Compatible Subset (MCS) problem, discussed in this section], which will then be attached optimally to the tree part of the network (the MAP, discussed in the next section).
Problem 1.
(MCS).
Let C be a set of clusters on X.
The Maximum Compatible Subset (MCS) problem is to remove a minimum set of taxa R from X so that the set of clusters C|X \R induced by X \R is compatible.
For a general set of clusters, this is equivalent to the Maximum Compatible Tree (MCT) problem, which is known to be NP-hard (Steel and Hamel, 1996).
We refer to the MCS problem in which the instances are restricted to sets of clusters C on X for which properties (P1) and (P2) hold as the RMCS problem.
We next state that the RMCS problem is hard: Lemma 2.
(RMCS problem is hard).
Let C be a set of clusters on X with properties (P1) and (P2).
Solving the MCS problem is NP-hard for such input.
A proof is given in the Appendix A.
In Berry and Nicolas (2006), an FPT algorithm is presented for solving the MCT problem for a set of rooted phylogenetic trees on X.
This algorithm can be employed to solve the RMCS problem, too, simply by encoding each cluster C as an appropriate rooted phylogenetic tree.
In this article, we formulate a new algorithm for solving RMCS directly, which we call the seed-growing algorithm.
This algorithm goes straight to the heart of the problem and thus performs very well in practice.
For each pair of incompatible clusters A,BC we define an incompatibility statement consisting of the three terms A\B,A B,B \A, and we use L to denote the list of all such statements for C (Fig.4ac).
To solve the RMCS problem, we must find a minimum set of taxa RX that resolves each incompatibility statement in L, that is, for each incompatibility statement in L at least one term is a subset of R. The algorithm maintains a set S of candidate solutions, called seeds.
Each seed sS is labeled by the number rank(s) of incompatibility statements that it has been shown to resolve in succession, starting from the beginning of the list L. Initially, the three parts of the first incompatibility statement are chosen as seeds, and we set rank(s)=1 for each such seed s. The algorithm then proceeds by repeatedly choosing among all seeds of minimum size a seed s that maximizes rank(s).
If rank(s)=|L|, then s is an optimal solution of the RMCS problem and the algorithm halts.
Otherwise, if s resolves the (rank(s)+1)-th incompatibility statement X,Y ,Z , we increment rank(s) by 1.
Otherwise, we define three new seeds s1 =sX, s2 =sY and s3 =sZ , with rank(s1)= rank(s2)= rank(s3)= rank(s)+1, add these to S and remove s from S. Note that this algorithm is more than just a greedy heuristic, as it is guaranteed to find an optimal solution.
Moreover, although the MCS problem has the flavor of a hitting set-, vertex cover-or edge cover problem, it is, in fact, a new problem.
Lemma 3.
(Performance of the seed-growing algorithm).
If a solution to the Maximum Compatible Subset problem has size k for a given set of incompatibility statements H, then the seed growing will find it by considering at most 3k+1 seeds, and the algorithm has a worst-case time complexity of O(k|H|3k).
i88 [10:06 15/5/2009 Bioinformatics-btp217.tex] Page: i89 i85i93 Computing galled networks Fig.4.
(a) A set of clusters C on X ={a,b,c,x,y}, (b) the incompatibility graph IG(C), (c) the corresponding list L of incompatibility statements solved by choosing {x,y} as the solution of the MCS problem; and (d) a galled network N obtained by solving the MAP.
Here, the top and bottom parts of the network are labeled T and B, respectively.
The edges of the top part are labeled by the non-trivial clusters that they represent and the leaves are labeled by their taxa.
Link edges are shown as dashed lines.
A proof is given in the Appendix A.
5 THE MAP Let C be a set of clusters on X and RX a minimum subset of taxa such that the restriction of C to X \R, denoted by C|X \R, is compatible.
Let T be the rooted phylogenetic tree on X \R that represents C|X \R, and let L(e) denote the cluster in C|X \R represented by an edge e of T. For each tree edge e of T , let C(e)={C C |C\R=L(e)} denote the set of all clusters in C that are mapped to L(e) under the restriction of C to X \R, and let R(e)={r RC |C C(e)} denote the set of all reticulate taxa that map to the cluster L(e).
We will refer to T as the top part.
Let C|R denote the restriction of C to the taxon set R and let C|R denote the set of all maximal clusters (by containment) in C|R.
We now define a graph B associated with C|R, as follows: each cluster C C|R is represented by a node v(C) and each taxon r R is represented by a node v(r) and we place an edge from v(C) to v(r) for all taxa r contained in the cluster C. We will refer to B as the bottom part (Fig.4d).
Problem 2.
(Attachment problem).
The Attachment problem is to define a set of link edges from nodes in the top part T to nodes in the bottom part B such that the resulting graph is a galled network that represents the input set of clusters C. More precisely, we aim at representing all clusters in C(e) by the edge e in T and all clusters in C|R by the in-edges of the nodes of the form v(C), with C C|R.
To ensure this, the link set must fulfill the following properties.
(A1) For every edge e of T and every taxon r R(e) there exists a link from some descendent node of e in T to either v(r) or to some node of the form v(C) in B, where C C|R contains r. (A2) For every node of the form v(C) in B, with C C|R, there exists exactly one link from some node in T to v(C).
(A3) For every edge e in T and r R such that C(e) contains some C C that does not contain r, there exists a path from some node in T , that is not a descendant of e, to v(r).
Property (A1) ensures that we can reach v(r) from any edge e in T that has a cluster C C(e) that contains r. Property (A2) ensures that all nodes of the form v(C) in B obtain in-degree 1.
We do not allow an in-degree > 1 to ensure that only nodes of the form v(r) for r R will be reticulate nodes.
For example, in Figure.
4d, the node above x and y is only attached to the node labeled b, and not to the node labeled c or to the parent of the two nodes labeled c and d, etc.
Finally, property (A3) ensures that the node v(r) can be avoided from any edge e in T that must represent a cluster that does not contain r. Our goal is to minimize the number of edges used to solve the following Attachment problem.
Problem 3.
(MAT).
Find a collection of links that has all properties (A1)(A3) and is of minimum size.
In general, this is hard to solve.
Lemma 4.
(The MAT Problem is hard).
The decision problem whether there exists a solution to the Attachment problem that uses at most k edges is NP-complete.
A proof is given in the Appendix A.
The above reduction also proves that the MAT problem is W[2]hard, remaining intractable even when parameterized by k, and so it is unlikely that an O( f (k)poly(n)) algorithm can be obtained.
The instances of this problem that are of interest in practice are usually quite small and so a branch-and-bound approach is adequate.
Alternatively, the problem can be posed as an ILP with binary variables that determine whether a possible link edge is used or not and inequalities that ensure that the properties (A1)(A3) hold.
The optimization goal is then to minimize the sum of the binary variables.
The following complication must also be taken into account.
After solving the MAP for a set of clusters C on X and a given reticulation set R, assume there exists an edge e along the path from the root of the top part T to a node v(r), with r R, that represents a cluster C that does not contain r. Assume further that e has the property that the lowest single ancestor of v(r) (Huson and Rupp, 2008) lies below e. Then we need to create an additional edge to connect v(r) to a node above e to be able to turn off the taxon r in the representation of the cluster C. 6 IMPLEMENTATION IN DENDROSCOPE As our goal is not only to solve the theoretical aspects of galled networks, but also to provide a robust and easy to use tool so that biologists can benefit immediately from these results, we have implemented all presented algorithms in a new version 2.0 of our program Dendroscope (Huson et al., 2007).
Originally designed as a tool for drawing phylogenetic trees, this new version of Dendroscope is geared toward analyzing multiple trees using both consensus trees and rooted networks.
When asked i89 [10:06 15/5/2009 Bioinformatics-btp217.tex] Page: i90 i85i93 D.H.Huson et al.to produce a rooted network, the program provides the user with the choice of either computing a rooted cluster network, as recently introduced in (Huson and Rupp, 2008), or of computing an optimal galled network, as described in this article.
Input is a set of rooted trees on X.
The program proceeds by extracting the set of all clusters C from the input, or, alternatively, all clusters contained in at least a fixed percentage of the input trees.
If the given phylogenetic trees are on overlapping, but non-identical taxon sets, our implementation uses the Z-closure method (Huson et al., 2004) to infer clusters on the full taxon set.
The incompatibility graph is then computed and the list of connected components is generated.
Each such component is compacted, i.e.every maximal subset of taxa which is not separated by any cluster in the component is represented by only one of the taxa in the subset.
For each compacted component C on X X , we determine the smallest set RX such that C|X R is compatible, and then produce an optimal solution of the MAP for the component.
The solution found is encoded as a set of clusters with the property that the Hasse diagram of the set of clusters is precisely the rooted network structure that we are looking for.
This is a useful trick, because it makes uncompacting clusters and putting together the results from different components straightforward to do.
However, the structure of a galled network cannot always be completely described in terms of a set of generating clusters in this way: it may be necessary to add a direct edge from a node v to one of its descendants w, namely to be able to completely turn off a reticulate node in the representation of some cluster.
To address this, we maintain a list of pairs of clusters that describe pairs of such nodes that are to be joined by additional edges after the Hasse diagram of the modified cluster set has been computed.
In Section 2, we showed that the cluster containment problem is easy for galled networks.
Based on this, our implementation contains an algorithm that verifies that a computed galled network does indeed contain all clusters that are present in the input.
Dendroscope was designed to handle very large trees.
In this vein, we have been careful to ensure that our implementation of galled networks works well on large datasets, too.
The running time of the algorithm depends on the maximum number of reticulations required by any compacted component of the incompatibility graph.
If this number is reasonable, then our implementation will happily work well on trees containing hundreds or thousands of taxa.
As discussed above, to obtain an optimal galled network we must solve a number of instances of two problems that are both computationally hard, the Maximum Compatible Subset problem and the MAP.
To avoid frustrating the user, when attempting to solve an instance of either problems, the user is presented with a cancelable progress bar dialog.
If he or she decides to cancel a computation, then the program takes the best partial solution found so far and then greedily extends it to a full solution in very short time.
In this way, the program can always be used to produce a valid galled network, even when the user does not have the time to wait for a guaranteed optimal one.
7 APPLICATION TO REAL DATA 7.1 Application to grasses An algorithm for computing the optimal number of hybridization nodes in a rooted phylogenetic network N that displays both of two given input trees is presented by Bordewich et al.(2007), Table 1.
For all possible pairs of five trees on grasses (Grass Phylogeny Working Group, 2001), we report the number of taxa shared by both trees, the number of hybridization nodes and run-time reported in (Bordewich et al., 2007) and the number of reticulate nodes and run-time obtained using the algorithm described in this article.
First Second Common Hybrid Time Reticulate Time(s) tree tree taxa nodes nodes ndhF phyB 40 14 11 h 9 <2s ndhF rbcL 36 13 11.8 h 8 <2s ndhF rpoC2 34 12 26.3 h 10 <2s ndhF waxy 19 9 320 s 6 <2s ndhF ITS 46 >15 2days 23 <2s phyB rbcL 21 4 1s 6 <2s phyB rpoC2 21 7 180 s 4 <2s phyB waxy 14 3 1 s 3 <2s phyB ITS 30 8 19 s 9 <2s rbcL rpoC2 26 13 29.5 h 9 <2s rbcL waxy 12 7 230 s 4 <2s rbcL ITS 29 >9 2days 15 <2s rpoC2 waxy 10 1 1 s 2 <2s rpoC2 ITS 31 >10 2days 14 <2s waxy ITS 15 8 620 s 5 <2s a computationally hard problem, as they show.
At present, their implementation does not provide an actual network that attains the number, but this is under development (C.Semple, personal communication).
Bordewich and colleagues study five different trees on a grass (Poaceae) dataset provided by the Grass Phylogeny Working Group (Grass Phylogeny Working Group, 2001), ranging in size from 19 to 65 taxa.
They apply their algorithm on all pairs of trees in the input set, in each case restricting the input trees to the set of taxa that both trees have in common.
They report the optimal number of hybridization nodes and the computational time required.
In Table 1, we list their results and compare them with the results obtained by running our new algorithm on the same datasets.
We show the networks obtained in Figure 5.
There are two important observations to be made.
The first is that the number of hybridization nodes and reticulate nodes is not always the same.
The networks considered by Bordewich and colleagues are more general, so a smaller number of hybridization nodes is possible.
On the other hand, they search for a network that contains both trees as subtrees, whereas our algorithm seeks only to represent their clusters.
In all cases where we report a lower number of reticulations, it is true that at least one of the two input trees is not contained in the network as a tree (although all its clusters are).
At first glance, this may seem a weakness of our approach.
However, biologists are usually focused on the clades or monophyletic groups rather than on the trees that contain them, and so in practice this is not a problem.
The second observation is that the runtime required by our algorithm was < 2 seconds in all cases, whereas the algorithm by Bordewich and colleagues took a number of days in some cases, without completion.
7.2 Application to prokaryotes dataset To test the algorithm on a larger dataset, we considered nine different gene trees on a set of 279 prokaryotes (Auch et al., manuscript in preparation).
To evaluate the running time on an extremely hard i90 [10:06 15/5/2009 Bioinformatics-btp217.tex] Page: i91 i85i93 Computing galled networks Fig.5.
Galled networks computed by Dendroscope, using the algorithms presented in this article, for 15 different pairs of trees on grasses (Grass Phylogeny Working Group, 2001), see Table 1. dataset, we ran our algorithm on the set of all 1334 clusters contained in the nine trees.
As it turned out, most clusters are involved in one large incompatibility component with 13 337 incompatibility statements.
Our code for solving the Maximum Compatible Subset problem required < 10 min.
to solve this component, whereas the code for solving the Minimum Attachment problem was unable to find a guaranteed minimum solution within an acceptable time.
The network produced used 179 reticulate nodes.
For a less difficult dataset, we ran the algorithm on all clusters contained in more than one input tree.
This gave rise to a dataset of 655 clusters and the most difficult incompatibility component had 29 incompatibility statements, which required 4 reticulations to resolve.
In this case, the galled network was obtained in less than 2 seconds, and we display it in Figure 6.
ACKNOWLEDGEMENTS This work was initiated by DHH and RR during the Phylogeny Programme at the Newton Institute of Cambridge University in 2007.
We would like to thank Magnus Bordewich, Vincent Moulton and Charles Semple for many helpful discussions, and Johannes i91 [10:06 15/5/2009 Bioinformatics-btp217.tex] Page: i92 i85i93 D.H.Huson et al.Fig.6.
A galled network on 279 prokaryote species, computed from all clusters that are contained in more than one of nine different gene trees.
Fischer for giving us feedback on the article.
Thanks to Alexander Auch for providing the nine gene trees on prokaryotes.
Funding: DFG (to R.R.
)grant Hu 566/5-1.
French ANR project ANR-08-EMER-011-01.
Confllict of Interest: none declared.
