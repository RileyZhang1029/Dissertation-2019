          OP-CBIO130250 326..334 Vol.
29 ISMB/ECCB 2013, pages i326i334 BIOINFORMATICS doi:10.1093/bioinformatics/btt219 IDBA-tran: a more robust de novo de Bruijn graph assembler for transcriptomes with uneven expression levels Yu Peng1, Henry C. M. Leung1, Siu-Ming Yiu1, Ming-Ju Lv2, Xin-Guang Zhu2 and Francis Y. L. Chin1,* 1Department of Computer Science, The University of Hong Kong, Hong Kong and 2CAS-MPG Partner Institute for Computational Biology, Shanghai Institutes for Biological Sciences, Chinese Academy Sciences, Shanghai 200031, China ABSTRACT Motivation: RNA sequencing based on next-generation sequencing technology is effective for analyzing transcriptomes.
Like de novo genome assembly, de novo transcriptome assembly does not rely on any reference genome or additional annotation information, but is more difficult.
In particular, isoforms can have very uneven expression levels (e.g.1:100), which make it very difficult to identify low-expressed isoforms.
One challenge is to remove erroneous vertices/ edges with high multiplicity (produced by high-expressed isoforms) in the de Bruijn graph without removing correct ones with not-sohigh multiplicity from low-expressed isoforms.
Failing to do so will result in the loss of low-expressed isoforms or having complicated subgraphs with transcripts of different genes mixed together due to erroneous vertices/edges.
Contributions: Unlike existing tools, which remove erroneous vertices/edges with multiplicities lower than a global threshold, we use a probabilistic progressive approach to iteratively remove them with local thresholds.
This enables us to decompose the graph into disconnected components, each containing a few genes, if not a single gene, while retaining many correct vertices/edges of low-expressed isoforms.
Combined with existing techniques, IDBA-Tran is able to assemble both high-expressed and low-expressed transcripts and outperform existing assemblers in terms of sensitivity and specificity for both simulated and real data.
Availability: http://www.cs.hku.hk/alse/idba_tran.
Contact: chin@cs.hku.hk Supplementary information: Supplementary data are available at Bioinformatics online.
1 INTRODUCTION Recent development of massively parallel cDNA sequencing (RNA-Seq) provides a more powerful and cost-effective way to analyze transcriptome data.
RNA-Seq has been used successfully to identify novel genes, refine 50 and 30 ends of genes, study gene functions (Graveley, 2008), locate exon/intron boundaries (Nagalakshmi et al., 2008; Trapnell et al., 2009) and estimate expression levels of isoforms (Jiang and Wong, 2009).
However, transcriptome reconstruction (the reconstruction of all expressed transcripts) from RNA-seq data remains a challenging unresolved problem when there is splicing, i.e.when different combinations of regions (exons) of a single gene are decoded to multiple transcripts (isoforms) (Trapnell et al., 2010).
Currently, there are two computational approaches to solve this problem.
Alignment-based methods, such as Cufflinks (Trapnell et al., 2010) and Scripture (Guttman et al., 2010), first align reads to reference genomes using splice junction mappers, such as TopHat (Trapnell et al., 2009), to identify exonintron boundary and then build a graph in which exons are the nodes and two exons are connected if reads connect them.
Cufflinks (Trapnell et al., 2010) attaches weights to edges and models the isoform reconstruction problem as a minimum path cover problem, while Scripture (Guttman et al., 2010) creates a statistical model to identify significant segments as isoforms.
In contrast, de novo assembly methods, such as Trinity (Grabherr et al., 2011), Oases (Schulz et al., 2012), Trans-Abyss (Robertson et al., 2010) and T-IDBA (Peng et al., 2011), assemble transcripts directly from reads.
Alignment-based transcriptome assembly methods, which rely on reference genomes and additional annotation information, may suffer from missing/erroneous information.
Also, the quality of these methods depends heavily on the accuracy of the alignment tools (Trapnell et al., 2009), which is also complicated by splicing and sequencing errors.
As RNA-Seq technology becomes more mature, there will be an increasing need to reconstruct unknown transcriptomes without reference genome information, and de novo transcriptome assembly will become increasingly more important.
Difficulties: At first glance, the de novo transcriptome assembly problem looks similar to the de novo genome assembly problem.
In fact, many existing methods for de novo transcriptome assembly, like genome assembly, apply the de Bruijn graph approach with fragments of transcripts being simple paths in graph, in which a vertex is a k-mer and an edge exists between two vertices u and v if u and v appear consecutively in a read.
However, two main aspects make the two assembly problems different.
(1) Exons shared by multiple isoforms.
In this paper, we focus on transcriptome assembly for eukaryotes with splicing since, without splicing, the problem is much easier.
Consider the example (LOC_Os10g02220 from rice) in Figure 1.
A to I represent different exons forming 5 isoforms (in red).
Shared exons (e.g.D and H) look like repeats, and most genome assemblers try to resolve repeats at the branch level, i.e., each branch needs to be supported by paired-end reads.
In our case, since all five isoforms are real, branches BD and CD as well as DE and DF will be supported.
Some assemblers may stop at the junctions, reporting B, C, D, E and F as separate (short) contigs or falsely regard CDE as a transcript (provided both CD and DE have enough support).
For example, running Velvet on the rice data*To whom correspondence should be addressed.
The Author 2013.
Published by Oxford University Press.
This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited.
For commercial re-use, please contact journals.permissions@oup.com (see Section 3.2 for details) results in contigs of mean length 245 bp only, while the mean length of transcripts is about 1700 bp.
Some metagenomic (Bankevich et al., 2012) and single-cell assemblers (Vyahhi et al., 2012) try to find a path with maximum paired-end reads support; however, as the insert distance of transcriptome data usually cannot cover more than one branch (splicing junction) and there are multiple correct paths (isoforms) with paired-end reads support, these assembliers also fail to reconstruct the isoforms.
(2) Different expression levels of isoforms of the same gene.
Isoforms of the same gene may have very different expression levels.
There are two problems.
First, low-expressed isoforms may have little support from reads and thus are missed by the assembler.
For example, in Figure 1, if there are only a few paired-end reads supporting branch BD and FH, isoform ABDFH is unlikely to be obtained.
Second, support from reads of erroneous k-mers from high-expressed transcripts may be higher than that of correct k-mers from low-expressed transcripts.
These erroneous k-mers introduce branches in the de Bruijn graph and make the graph very complicated.
Figure 2 shows an example from a real rice transcriptome dataset (LOC-Os12g12850).
This subgraph (k 50) is supposed to contain only two isoforms (Fig.2a shows the conceptual view of the isoforms).
There are 92 353 and 90126 erroneous k-mers and branches respectively in the de Bruijn graph (Fig.2b) when we simulated reads with 1% sequencing error (details shown in Section 3).
Existing approaches usually employ a global threshold to remove erroneous k-mers and branches if the multiplicities of these components are smaller than the threshold.
This simple approach will not work for transcriptome data.
Since the error positions of each read are known, we can count the number of correct and erroneous k-mers for simulated data on rice (Section 3.1) for different multiplicities (Fig.2c).
No matter how we set the threshold of multiplicity for removing erroneous k-mers (draw a vertical line and consider all k-mers on the left with lower multiplicities as erroneous k-mers), some erroneous kmers will remain and correct k-mers will be removed.
These complicated components will make isoform finding extremely difficult as there are many paths to be considered.
In the ideal case, the de Bruijn graph should have many isolated components, each representing isoforms from one gene unless there are repeats in different genes.
In most cases, the structure of the component should be simple as most genes do not contain many isoforms.
To tackle this issue, we need a method to separate components that are falsely connected by erroneous k-mers and we need to remove erroneous k-mers from each component.
Existing solutions: Oases (Schulz et al., 2012) and Trinity (Grabherr et al., 2011) are two popular de novo transcriptome assemblers for RNA-Seq data.
In order to solve the splicing problem [Issue (1)], both apply a dynamic programming approach to identify potential paths in the graph, which are supported by many reads or paired-end reads.
In other words, they try to identify isoforms more globally through a path-level analysis instead of a local branch-level analysis.
The results are much better than those of genome assemblers.
However, since the problem is NP-complete (proved in the Supplementary Appendix), the running time of the dynamic programming approach increases exponentially with the number of branches in the de Bruijn graph.
Due to Issue (2), erroneous reads sampled from high-expressed transcripts introduce many branches (with more support than reads sampled from low-expressed transcripts) and thus dynamic programming takes a long time.
In practice, these tools fall back on heuristic search instead of dynamic programming for large components.
To tackle Issue (2), T-IDBA (Peng et al., 2011) uses another approach to isolate components.
Based on the observation that transcripts from different genes share less common vertices when k value is large, T-IDBA builds a de Bruijn graph from small k and iteratively updates the graph with larger k values.
It then finds transcripts in the de Bruijn graph with large k value where transcripts from the same gene usually form a single component.
However, it does not perform very well for low-expressed transcripts because there are more missing k-mers when k is large.
There is no dedicated solution in T-IDBA that solves the issue of erroneous k-mers within a component and methods for isolating components are not sensitive to low-expressed isoforms.
To recover low-expressed transcripts, several post-processing methods (Robertson et al., 2010; Surget-Groba and MontoyaBurgos, 2010) were developed for Velvet (Zerbino and Birney, 2008) and Abyss (Simpson et al., 2009).
They are all based on the observation that lower k values make the assembler more sensitive to low-expressed transcripts, while larger k values make it more specific to high-expressed transcripts.
In order to combine the advantages of different values of k, the resultant contigs, generated by different k-mer lengths independently, are merged together.
However, merging assembly results from different runs is not a straightforward task.
Although output transcripts are clustered and duplicated transcripts are removed, many duplicates are difficult to detect and errors can accumulate in the cluster-remove step.
As a result, multiple contigs with errors are generated for the same transcripts and the number of resulting contigs is much more than the number of expressed transcripts.
Oases-M, an extension of Oases, makes use of multiple k to improve its assembly result and is now the best tool using this approach.
However, since the fundamental problem of removing erroneous vertices from high-expressed isoforms while keeping correct vertices from low-expressed isoforms is not solved, there are still many false positives as well as duplicated transcripts (Section 3).
Some single-cell genome assemblers (Chitsaz et al., 2011; Peng et al., 2012) also have a problem with uneven multiplicities of correct k-mers.
They resolve the problem based on the assumption that, although the multiplicities of these erroneous k-mers are high, their multiplicities should be lower than the nearby correct k-mers.
Thus, they calculate a local threshold, based on.. A  G E  F  I.. H B  C  D Fig.1.
Example of de Bruijn graph for five isoforms from the same gene i327 IDBA-tran the multiplicities of nearby k-mers or contigs, for removing erroneous k-mers.
However, as a k-mer representing the common exon of several expressed isoforms can have relatively higher multiplicity than nearby correct k-mers (Li and Jiang, 2012), calculating the local threshold from only one or two nearby kmers or contigs may be misleading and the algorithms may remove many correct k-mers near these high multiplicity k-mers.
Our contributions: If Issue (2) can be resolved, Issue (1) can be tackled by existing path-level analysis as the components will be simple enough.
Thus, our core contribution is handling Issue (2).
As mentioned before, the traditional filtering method of using one single global threshold for multiplicity cannot separate correct k-mers sampled from low-expressed transcripts from erroneous k-mers sampled from high-expressed transcripts, and single-cell genome assemblers calculating local thresholds from nearby k-mers may remove many correct k-mers.
Thus, we propose a probabilistic progressive approach to solve this problem.
Our proposed assembler IDBA-Tran calculates the probability that a k-mer or short simple path (contigs) contains error using not only the multiplicity of the k-mer or contig (or their neighboring k-mers or contigs) but also uses a multi-normal distribution to model the multiplicities of all k-mers in the whole connected component.
Based on the multi-normal distribution and the contig length (as a short simple path is more likely to have error than a long one), IDBA-Tran calculates a local threshold for determining whether a k-mer or contig has error.
By progressively removing erroneous k-mers, connected components representing isoforms from a single gene are identified.
Since we successfully remove many erroneous k-mers, the size of each component is small.
We can employ a path-level analysis (similar to Oases and Trinity) to identify transcripts from each component [Issue (1)].
Thus IDBA-Tran can perform better than Oases and Trinity, producing more contigs, particularly for lowexpressed transcripts.
Results show that IDBA-Tran outperforms other de novo transcriptome assembly approaches in terms of both sensitivity and specificity for both simulated and real data.
IDBA-Tran also makes use of other techniques used in genome assemblers, such as tips pruning, path merging and error correction.
2 METHODS Similar to Oases-M, IDBA-Tran also adopts the idea of multiple k to handle transcripts with different expression levels.
However, instead of generating a de Bruijn graph and finding transcripts for each k value, an accumulated de Bruijn graph is built to capture all information from both high-expressed and low-expressed transcripts.
During each iteration, an accumulated de Bruijn graph Hk for a fixed k is constructed from the input reads and the contigs constructed in previous iterations, i.e.those contigs constructed in Hk-s are treated as input reads for the construction of Hk.
The depth information is used to separate de Bruijn graph into components.
Ideally, transcripts from different genes are decomposed into different components.
In each component, alternative splicing can be detected and transcripts can be reconstructed.
To accumulate information, all reconstructed transcripts are used as input reads for the next iteration.
Figure 3 shows the workflow of IDBA-Tran for assembling a set of paired-end reads.
In the first iteration when k kmin,Hk is equivalent to a de Bruijn graph for vertices whose corresponding k-mers have multiplicity of at least m (2 by default) times in all reads.
During all subsequent iterations, sequencing errors are first removed according to the topological structure of Hk in a slightly different way to other assemblers (Section 2.1).
The tips (dangling paths in Hk of length shorter than 2k) are likely to be false positives (Li et al., 2010; Simpson et al., 2009; Zerbino and Birney, 2008).
Similar paths (bubbles) representing very similar contigs with the same starting vertex and ending vertex are likely to be caused by errors or SNPs and they should be merged (Li et al., 2010; Simpson et al., 2009; Zerbino and Birney, 2008).
Then, the depth information for contigs and components is used to decompose the graph into components (Section 2.2).
Paths with high support for the paired-end reads are reconstructed as transcripts in each component (Section 2.3).
Errors in the assembled contigs are corrected by aligning reads to the contigs (Section 2.4).
When constructingHks fromHk, each length s 1 path inHk is converted into a vertex ((k s)-mer) and there is an edge between two vertices if the corresponding (k s 1)-mer appears f (1 by default) times in reads or once in contigs in Ck[LCk[Tk, where Ck represents the set of contigs, LCk is the set of contigs constructed by local assembly using paired-end information (Section 2.5), and Tk is the set of transcripts when considering Hk.
In the following subsections, we describe each step of IDBA-Tran in detail.
2.1 Pruning short tips and merge similar path Many de novo assemblers remove tips (short simple paths leading to dead ends) in the de Bruijn graph as erroneous contigs.
It would not be advisable to remove such tips in transcriptome assembly, because transcripts are very short (could be several hundred bases) when compared to genomes.
Removing one hundred bases from the end of a genome may not be a problem, but removing one hundred bases from the end of a transcript may lose much important information.
When constructing the accumulated de Bruijn graph in IDBA-Tran, the tip removal process will take place at each iteration.
Instead of removing all tips and producing shorter transcripts, IDBA-Tran keeps the longest tip (with highest probability of being a correct path) and removes all other short tips.
For (a) (b) (c) A...... B C D.. Fig.2.
Example of de Bruijn graph for two isoforms from the same gene.
(a) de Bruijn graph of two isoforms without error.
(b) de Bruijn graph of two isoforms when there is 1% sequencing error in reads.
(c) Multiplicity of correct and erroneous k-mers for simulated data i328 Y.Peng et al.each branch in the graph, IDBA-Tran checks each outgoing (and incoming) edge, keeps the branch which leads to the longest path, and removes all other branches (tips) which lead to paths shorter than 2k.
Usually, the correct branch leads to longer paths than tips, and this method preserves correct branches.
As transcriptome sequencing data contains more errors and insertions/ deletions than genome sequencing data, IDBA-Tran identifies and merges paths with same starting point and end point and higher than 98% similarity (including insertions and deletions).
2.2 Decomposing the graph by iterating depth Recall that T-IDBA (Peng et al., 2011) also tries to decompose the de Bruijn graph into components.
It is based on the observation that there are not many repeat patterns between two transcripts from different genes while isoforms from the same gene share common exons.
Thus, it decomposes the graph into different components such that there are relatively more branches inside each component and relatively fewer branches between two components.
However, erroneous k-mers (from high-expressed isoforms) still cannot be removed effectively since components representing isoforms from different genes may be connected by these erroneous kmers to form a very large component preventing the assembler from determining isoforms in the component.
Instead of considering the number of branches for decomposing the de Bruijn graph into components, IDBA-Tran detects and removes erroneous paths connecting two components by considering the lengths and sequencing depths (depths in short) of the paths using a probabilistic approach.
The depth of a path (contig) is the average multiplicity of the k-mer on the path.
Long contigs (simple paths in the de Bruijn graph) are usually correct, because long simple paths are unlikely to be formed by erroneous reads, and similarly for high-depth contigs which have supports from many reads.
For a contig, whether its length is long or short and whether its depth is high or low cannot be judged by absolute values as the length of a contig depends on the value of k and the depth of a contig depends on the depths of neighboring contigs (contigs in the same component).
Since erroneous contigs in high-depth regions may have higher depths than correct contigs in low-depth regions, short (5l) and relatively low-depth contigs are likely to be erroneous and can be removed.
The removal takes place in an iterative manner (Chitsaz et al., 2011; Peng et al., 2012), because after some low-depth errors are removed, some short lowdepth contigs may be connected together to form long contigs.
Increasing depth cutoff progressively may help to preserve more lowdepth correct contigs.
IDBA-Tran removes contigs (simple paths) shorter than l with average sequencing depth lower than where is a threshold calculated based on value of l and the depth distribution of the connected component which contains the contig.
When is large, many correct contigs are removed and many true positive transcripts cannot be assembled.
When is small, many erroneous contigs are not removed and transcripts from different genes may form a large component such that correct transcripts are difficult to reconstruct in later steps (Section 2.3).
Thus, we should select the largest threshold such that not too many correct contigs are removed, say51%.
Consider a correct exon with length at least l. It should be represented by a simple path P in the de Bruijn graph.
However, as there are sequencing errors in reads, there may be branches in P and simple path Pmay be broken into several shorter paths with length less than l. Consider a particular edge u!v in P with the corresponding k-mer v sampled x times (some may contain errors).
There is another edge u!v in the de Bruijn graph if at least m (the multiplicity threshold used for removing erroneous k-mers) out of the x k-mers sampled from v having the same error at the last nucleotide, i.e.v and v differ by the last nucleotide, thus introduces branching at u.
This probability can be calculated as follows.
Assume the probability of a sequencing error per base is e and the probabilities that the erroneous base is changed to each other nucleotide are the same, i.e.1/3.
Although this simple assumption is not correct for real biological data, the calculation can be readily refined for different probabilities.
The probability that v is sampled as v with the last nucleotide changed to a particular nucleotide, say A, is perr e 3 1 ek1 As v can be sampled with error as v, i.e.at least m of the x samples have the same error at the last nucleotide.
Since there are three possible v, the existence probability of v (probability of branching at u) is P m,x, perr  3P 1 v0 exist  3P 2 v0 exist  P 3 v0 exist  3 Xxm i0 P 1 v0 existji k-mer v existPi k-mer v exist 3 Xx2m i0 P 2 v0 existji k-mer v existPi k-mer v exist Xx3m i0 P3 v0 existji k-mer v existPi k-mer v exist 3 Xxm i0 Cxmi22 p xi err 1 perr i3 Xx2m i0 Cx2mi22 p xi err 1 perr i Xx3m i0 Cx3mi22 p xi err 1 perr i Prune short tips Merge similar path Paired-end reads Construct de Bruijn Hk for k = kmin Progressive-Component-Depth Error Correction Local Assembling Find-transcripts Build Hk+s until kmax Contigs Fig.3.
Workflow of IDBA-Tran i329 IDBA-tran In order to estimate the value of depth x, we use a multi-normal distribution to model the depth distribution of a component as there can be multiple isoforms, say t, in a component.
Given a set of k-mers with different multiplicities in the same component, we assume the multiplicities of the k-mers are sampled from t normal distributions.
Although the mean and standard deviation of each normal distribution can be estimated by expectation-maximization algorithm (Tanaseichuk et al., 2012), the time is too long because there are many k-mers and components.
Thus IDBA-Tran applies an approximation by clustering the k-mers based on their multiplicities (the distance between two k-mers equals their difference in multiplicities) using K-means clustering method.
The mean and standard deviation can then be calculated for each cluster.
We set t 3 in the experiments based on the assumption that there are at most 3 transcripts in each components (at the final step).
Let N(, ) be a normal distribution of depth with minimum mean depth value.
The probability that we wrongly remove a correct contig with average depth is at most P false positive  1ffiffiffiffiffiffiffiffiffiffi 22 p 1 e x2 22 2lPm,x, perrdx Note that for an exon of length at least l of sequencing depth x, the probability of branching is 2lPm, x, perr.
The value of l should be selected based on the length of exons.
If a very large l is selected, true positive k-mers and paths are removed.
If a very small l is selected, most true negative k-mers and paths cannot be removed.
We should select different values for l depending on the properties of the data (we use l 2k in the experiments).
Once l is selected, we can calculate the largest such that P(false positive) is lower than some value, say 1%, so as to remove most erroneous contigs without too many false positives.
Algorithm 1 shows the pseudocode for the decomposing step.
According to (Peng et al., 2011), when the size of the component is small (with 30 contigs), the component is likely to represent isoforms from a single gene and we can use a very low depth threshold 0.1T(comp), where T(comp) is the average depth of connected component comp, to prevent removing correct contigs.
The filtering depth cutoff threshold t is increased by a factor of progressively (10% by default).
In each iteration, short contig c is removed if its depth T(c) is lower than the minimum of cutoff threshold t and the depth threshold.
2.3 Finding transcripts Algorithm 1.
Progressive-Component-Depth(G, k) t 1 repeat until t4maxc2GT(c) for each component comp in G if size(comp)4, then calculate , else 0.1T(comp) for each contig c in comp if len(c)52k and T(c)5min(t, ) remove c from G t t (1 ) For each connected component in the de Bruijn graph, IDBA-Tran discovers those paths starting from a vertex with zero in-degree to a vertex with zero out-degree with the highest support from paired-end reads.
A path is supported by paired-end reads if the paired-end reads can be aligned to the path with the distance between the aligned positions matching the insert distance of the paired-end reads.
The problem definition can be simplified as follows [Transcripts Discovering (TD) Problem]: given a de Bruijn graph G(V,E) with a set of vertices V and edges E, a set of paired-end reads P {(vi, vj)}, vi, vj 2 V, an insert distance d and error s, find t paths in G with the maximum number of supporting paired-end reads P P. A path p has a supporting paired-end read (vi, vj) iff p contains vertices vi and vj and the distance between vi and vj in p is between d s and d s. Since the TD problem is a NP-hard problem (see Supplementary Appendix), IDBA-Tran performs a heuristic depth-first search to find paths from a zero in-degree vertex to a zero out-degree vertex with maximum supporting paired-end reads.
At each branch, the path with many supporting paired-end reads will be considered before other paths.
In practice, IDBA-Tran reports at most tmax (default 3) potential transcripts for each zero in-degree vertex in each connected component.
IDBA-Tran applies a seed and extend method for aligning reads to contigs (paths in de Bruijn graph).
k-mers in a read appearing in the de Bruijn graph is considering as potential aligned position and IDBA-Tran will try to extend both ends of alignment considering substitution error only.
Note that insertion and deletion error can be implemented in IDBATran easily.
However, as the number of substitution errors appears much more than the insertion/deletion errors, IDBA-Tran considers substitution error only for speeding up the alignment process.
2.4 Error correction The error correction step is performed on reads and assembled contigs during the assembling process.
At first, reads are aligned to each contig.
The consensus of the aligned reads will replace the original contig, i.e.positions of the contig inconsistent with the majority of aligned reads will be corrected.
Then aligned reads are corrected according to the aligned position in contigs, i.e.positions in the reads with nucleotides inconsistent with the consensus will be corrected.
This error correction step can reduce the number of erroneous reads and branches in the de Bruijn graph.
2.5 Local assembly Let C be the set of contigs.
We extract the beginning and end of each contig c in C to form a set of contigs C. Assume the insert distances of paired-end reads satisfy the normal distribution N(d, ).
IDBA-Tran performs local assembly (Peng et al., 2012) on the last d 3 bases of each end of the contig and the paired-end read with one end aligned to it.
Since those reads which are far away from contig c will not mix with reads with one end aligned to c, some missing k-mers can be reconstructed and the contigs can be extended longer.
2.6 Estimating expression levels Since IDBA-Tran is designed for assembling reads to reconstruct expressed transcripts, sophisticated algorithms can be then applied to estimate the expression levels of each transcript.
IDBA-Tran also provides an estimated expression level for each transcript by aligning reads to the transcript.
RPKM (Reads Per Kilobase per Million mapped reads) is estimated by dividing the total length of reads uniquely aligned to a transcript by the total length of regions of transcript uniquely aligned by reads.
3 RESULTS To evaluate the performance of IDBA-Tran, experiments were carried out on both simulated and real data.
We compared IDBA-Tran with the latest transcriptome assemblers Trinity (Grabherr et al., 2011) and Oases (Schulz et al., 2012).
We also compared IDBA-Tran with the single-cell genome assembler IDBA-UD (Peng et al., 2012) and Velvet-SC (Chitsaz et al., 2011), which apply multiple depths when assembling genomes.
IDBA-Tran and IDBA-UD were run with k ranging from 20 to 50 with step size 5.
For Oases and Velvet-SC, k values ranging from 20 to 50 with step size 5 were used, and the best result was selected as output.
As the k value of Trinity was fixed to 25, the default parameters were used to run it.
i330 Y.Peng et al.For transcriptome assembly, the most important indicator of assembly quality is the number of correct transcripts an assembler can reconstruct.
In the experiments, known transcript
