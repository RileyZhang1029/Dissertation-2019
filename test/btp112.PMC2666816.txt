BIOINFORMATICS APPLICATIONS NOTE Vol.25 no.8 2009, pages 1084 1085 doi:10.1093/bioinformatics/btp112 Sequence analysis mkESA: enhanced sufﬁx array construction tool Robert Homann1,2, , David Fleer2, Robert Giegerich2 and Marc Rehmsmeier3, 1International NRW Graduate School in Bioinformatics and Genome Research, Center for Biotechnology (CeBiTec), Bielefeld University, 33594 Bielefeld, 2Technische Fakultät, Bielefeld University, Postfach 100 131, 33501, Bielefeld, Germany and 3GMI - Gregor Mendel Institute of Molecular Plant Biology GmbH, Dr. Bohr-Gasse 3, 1030 Vienna, Austria Received on January 21, 2009 revised on February 19, 2009 accepted on February 20, 2009 Advance Access publication February 26, 2009 Associate Editor: Limsoon Wong ABSTRACT Summary: We introduce the tool mkESA, an open source program for constructing enhanced sufﬁx arrays (ESAs), striving for low memory consumption, yet high practical speed.
mkESA is a user- friendly program written in portable C99, based on a parallelized version of the Deep-Shallow sufﬁx array construction algorithm, which is known for its high speed and small memory usage.
The tool handles large FASTA ﬁles with multiple sequences, and computes sufﬁx arrays and various additional tables, such as the LCP table (longest common preﬁx) or the inverse sufﬁx array, from given sequence data.
Availability: The source code of mkESA is freely available under the terms of the GNU General Public License (GPL) version 2 at http://bibiserv.techfak.uni-bielefeld.de/mkesa/. Contact: rhomann@techfak.uni-bielefeld.de 1 INTRODUCTION The program mkESA is a software tool for constructing enhanced sufﬁx arrays (ESAs) from biological sequence data.
The ESA is an index data structure for textual data, introduced in Abouelhoda et al. (2004) as an extension of the well-known sufﬁx array (Manber and Myers, 1993). The ESA is equivalent to the sufﬁx tree, another very important, but more space consuming full-text index data structure (Gusﬁeld, 1997). The major advantages of ESAs over sufﬁx trees are their lower space overhead, improved locality of reference and simple storing to ﬁles. A sufﬁx array for text T of length n is a table of size n+1 that lists the start positions of the sufﬁxes of T in lexicographic order.
Using a sufﬁx array, exact string queries can be answered in O(mlogn) time, where m is the length of the query, instead of O(m+n) time without a sufﬁx array.
ESAs are composed of a sufﬁx array and additional tables that can be used to improve query performance [e.g. O(m+logn) time using the LCP table, called Hgt array in Manber and Myers (1993)], or enabling efﬁcient implementation of more advanced queries (e.g. ﬁnding maximum unique matches). Thus, ESAs are fundamental technology in sequence analysis.
Many interesting problems on sequences from the ﬁeld of computational biology can be solved efﬁciently by transforming  To whom correspondence should be addressed.
Present address: GMI - Gregor Mendel Institute of Molecular Plant Biology GmbH, Dr. Bohr-Gasse 3, 1030 Vienna, Austria. sequence data into (enhanced) sufﬁx arrays [see, for instance, (Beckstette et al., 2006 De Bona et al., 2008 Höhl et al., 2002 Krumsiek et al., 2007 Rahmann, 2003)]. Linear-time algorithms for sufﬁx array construction have been proposed as well as algorithms that are fast in practice and/or tuned for space efﬁciency, rendering use of sufﬁx arrays feasible for large datasets see Puglisi et al. (2007) for a comprehensive overview.
In addition, by the results of Abouelhoda et al. (2004), any program using sufﬁx trees can be transformed so to employ ESAs instead and beneﬁt from the advantages offered by that data structure.
Despite the great interest in sufﬁx arrays in the literature, only few actual programs for ESA construction are available.
Most existing programs are useful for mere sufﬁx array construction, and do not address speciﬁcities of computational biology such as handling multiple sequences and very large datasets. A notable exception is the widely used mkvtree program (http://www.vmatch.de/). mkvtree can read common ﬁle formats such as FASTA and keeps sequences separated from their descriptions.
An ESA generated by mkvtree may contain multiple sequences, stored so that a match can easily be mapped to its corresponding sequence.
The program is available free of charge as part of the Vmatch package, but, unfortunately, in binary form and for non-commercial purposes only.
This implies that software relying on mkvtree cannot be distributed easily since the terms of the Vmatch license agreement restrict the legal use of mkvtree. Software that requires using mkvtree also requires all users to obtain the Vmatch package, if available for their platform of choice, and have them sign a license agreement, too.
We have implemented the alternative open source software tool mkESA, using the Deep-Shallow algorithm (Manzini and Ferragina, 2004) for in-memory sufﬁx array construction instead of multikey quicksort as used by mkvtree. Thus, mkESA is efﬁcient even for highly repetitive sequence data, and is fast as long as all data can be held in main memory.
As further improvement, our implementation of Deep-Shallow can use multiple CPUs for increased speed.
2 IMPLEMENTATION With mkvtree being the most widely spread program for ESA construction, we tried to pick up all of the important ideas implemented in mkvtree and improve upon its weaknesses.
mkESA has been designed so to produce output as compatible with mkvtree as possible.
The ﬁles generated by mkESA are in fact the same as those made by mkvtree, meaning that data produced by mkESA can be processed by programs that expect mkvtree-generated ESAs. 2009 The Author(s) This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/2.0/uk/) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.
[17:58 30/3/2009 Bioinformatics-btp112.tex] Page: 1084 1084 1085  Table 1.
Datasets used for performance measurements Table 2.
Results of performance measurements mkESA Name Description Size chr1 fmdv spro trem f25 f30 Chromosome 1 human genome Foot/mouth disease virus genomes UniprotKB/Swiss-Prot rel.
56.4 UniprotKB/TrEMBL rel.
39.4 25th Fibonacci string 30th Fibonacci string 219 (219) MB 65 (64) MB 181 (140) MB 2836 (2110) MB 73 (73) kB 813 (813) kB σ 4 4 20 20 2 2 Sizes are given as ﬁle sizes, followed by sizes of ﬁles with FASTA headers removed in parentheses.
Alphabet sizes are given as σ. We included Fibonacci strings since these are hard on many sufﬁx tree and sufﬁx array construction algorithms due to their high repetitiveness.
They impose the worst case for the number of nodes in a sufﬁx tree, 2n, and thus, e.g. trigger the worst case running time of O(n2) of the WOTD sufﬁx tree construction algorithm (Giegerich et al., 2003). Dataset fmdv is a non-artiﬁcial example for highly repetitive sequence data, with similar impact on performance (Table 2). mkESA employs the Deep-Shallow algorithm of Manzini and Ferragina (2004) for sufﬁx array construction.
This algorithm belongs to the family of lightweight sufﬁx sorting algorithms, covering algorithms that use only very small additional space besides the sufﬁx array and the input text, i.e. only O((5+ )n) bytes space for a text of length n, and using 32 bit integers for the sufﬁx array.
Our version of Deep-Shallow is multithreaded, i.e. the computational work for sufﬁx sorting can be distributed over multiple CPUs or CPU cores.
Since Deep-Shallow is not useful for building LCP tables as by-product of sufﬁx sorting (as is the case with simple multikey quicksort), we use the space-efﬁcient, linear- time algorithm of Manzini (2004) to construct LCP tables from sufﬁx arrays.
Moreover, mkESA can generate the inverse sufﬁx array and the skip table (Beckstette et al., 2006). It is worth noting that mkESA can incrementally add additional tables when they are needed.
its included for 3 RUNTIME BENCHMARKS We compared the performance of mkESA with other programs for sufﬁx array construction, namely mkvtree, mksary 1.2.0 (http://sary.sourceforge.net/, ability to run multithreaded), and Manzini s implementation of Deep-Shallow ds. We measured the time and space consumption for building sufﬁx arrays from the datasets in Table 1, using memtime version 1.3. mkESA and mkvtree processed FASTA ﬁles, the other programs processed the bare sequence data with FASTA headers removed so that all programs had comparable workloads.
Only parallel mkESA and parallel mksary (Table 2) made explicit use of multiple CPU cores.
Measurements were taken on a Sun Fire X4450 (4 Intel Xeon CPUs at 2.93 GHz, 16 cores, 96 GB RAM) running Solaris 10.
The programs were compiled with gcc 4.1.1 using ﬂags -m64 -O3 -fomit-frame-pointer. Each experiment was repeated four times in a row the best (shortest elapsed time) of the results are displayed in Table 2.
Our results show comparable memory requirements for all tested programs, while mkESA is usually the fastest among them, even when using only one CPU. 4 CONCLUSION We presented mkESA, a portable, lightweight, multithreaded and fast program for constructing enhanced sufﬁx arrays.
We carefully Name mkESA Parallel mkESA mkvtree sec MB sec MB sec MB chr1 fmdv spro trem f25 f30 91 (2.6) 89 (0.9) 47 (1.9) 2273 (545) 0.1 (0.0) 1.1 (0.0) 1085 353 785 21 461 0.1 5.1 66 (2.6) 66 (0.9) 25 (1.9) 1500 (553) 0.1 (0.0) 1.1 (0.0) 1093 356 785 21 462 0.1 5.3 138 (2.2) 1797 (1.1) 76 (2.2) 2956 (530) 7.3 (0.0) 895 (0.0) 1148 338 813 21 827 1.4 5.4 Name mksary Parallel mksary sec MB sec chr1 fmdv spro f25 f30 224 (11)   161 (7.7) 7.5 (0.0)   1097  705 3.2  252 (28)   115 (23) 6.3 (0.0)   MB 1097  707 3.4  ds sec 102 (3.8) 99 (1.2) 63 (2.5) 0.1 (0.0) 0.9 (0.0) MB 1098 323 705 0.1 5.1 The sec columns show the total time consumed in seconds (wall time clock), followed by the time attributed to operating system activities in parentheses.
The MB columns show main memory consumption in megabytes [resident set size (RSS)]. Parallel versions were allowed to use up to 16 threads.
Some programs crashed for various datasets, in which cases results are not shown.
For the same reason there is no row for trem in the lower part.
All values were rounded for readability.
tested the software on a variety of UNIX-like operating systems and hardware architectures, including recent versions of Linux, Solaris, Mac OS X, FreeBSD, OpenBSD and NetBSD. Its ability to generate output compatible with mkvtree makes mkESA a convenient open source drop-in replacement for earlier programs.
Conﬂict of Interest: none declared.
REFERENCES Abouelhoda,M. et al. (2004) Replacing sufﬁx trees with enhanced sufﬁx arrays.
J. Discrete Algorithms, 2, 53 86.
Beckstette,M. et al. (2006) Fast index based algorithms and software for matching position speciﬁc scoring matrices.
BMC Bioinformatics, 7.
De Bona,F. et al. (2008) Optimal spliced alignments of short sequence reads.
Bioinformatics, 24, i174 i180. Giegerich,R. et al. (2003) Efﬁcient implementation of lazy sufﬁx trees.
Softw. Pract. Exp., 33, 1035 1049.
Gusﬁeld,D. (1997) Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology.
Cambridge University Press, New York, NY, USA. Höhl,M. et al. (2002) Efﬁcient multiple genome alignment.
Bioinformatics, 18, S312 S320. Krumsiek,J. et al. (2007) Gepard: a rapid and sensitive tool for creating dotplots on genome scale.
Bioinformatics, 23, 1026 1028.
Manber,U. and Myers,E. (1993) Sufﬁx Arrays: a new method for on-line string searches.
SIAM J.
Comput., 22, 935 948.
Manzini,G. (2004) Two space saving tricks for linear time LCP array computation.
In Hagerup,T. and Katajainen,J. eds, Proceedings of 9th Scandinavian Workshop on Algorithm Theory (SWAT 04), Vol.3111 of Lecture Notes in Computer Science.
Springer-Verlag, Berlin, Germany, pp.
372 383.
Manzini,G. and Ferragina,P. (2004) Engineering a lightweight sufﬁx array construction algorithm.
Algorithmica, 40, 33 50.
Puglisi,S.J. et al. (2007) A taxonomy of sufﬁx array construction algorithms.
ACM Comput. Surv., 39, 4.
Rahmann,S. (2003) Fast large scale oligonucleotide selection using the longest common factor approach.
J. Bioinform. Comput. Biol., 1, 343 361.
1085 [17:58 30/3/2009 Bioinformatics-btp112.tex] Page: 1085 1084 1085
