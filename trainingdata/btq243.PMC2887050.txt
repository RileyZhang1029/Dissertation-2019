BIOINFORMATICS APPLICATIONS NOTE Vol.
26 no.
13 2010, pages 1669 1670  doi:10.1093/bioinformatics/btq243  Phylogenetics The Newick utilities: high-throughput phylogenetic tree processing in the UNIX shell Thomas Junier1,2,  and Evgeny M. Zdobnov1,2,3 1Department of Genetic Medicine and Development, University of Geneva Medical School, 2Swiss Institute of Bioinformatics, 1 rue Michel-Servet, 1211 Geneva, Switzerland and 3Imperial College London, South Kensington Campus, SW7 2AZ, London, UK Associate Editor: Alex Bateman  Advance Access publication May 13, 2010  ABSTRACT Summary: We present a suite of UNIX shell programs for processing any number of phylogenetic trees of any size.
They perform frequently-used tree operations without requiring user interaction.
They also allow tree drawing as scalable vector graphics (SVG), suitable for high-quality presentations and further editing, and as ASCII graphics for command-line inspection.
As an example we include an implementation of bootscanning, a procedure for ﬁnding recombination breakpoints in viral genomes.
Availability: C source code, Python bindings and executables for from http://cegg .unige.ch/newick_utils.
The distribution includes a manual and example data.
The package is distributed under the BSD License.
Contact: thomas.junier@unige.ch  platforms  available  various  are  Received on March 3, 2010  revised on April 27, 2010  accepted on April 29, 2010  1 INTRODUCTION Phylogenetic trees are a fundamental component of evolutionary biology, and methods for computing them are an active area of research.
Once computed, a tree may be further processed in various ways (Table 1).
Small datasets consisting of a few trees of moderate size can be processed with interactive GUI programs.
As datasets grow, however, interactivity becomes a burden and a source of errors, and it becomes impractical to process large datasets of hundreds of trees and/or very large trees without automation.
Automation is facilitated if the programs that constitute an analysis pipeline can easily communicate data with each other.
One way of doing this in the Unix shell environment is to make them capable of reading from standard input and writing to standard output such programs are called ﬁlters.
Although there are many automatable programs for computing trees [e.g.
PhyML (Guindon and Gascuel, 2003), PHYLIP (Felsenstein, 1989)], programs for processing trees [e.g.
TreeView (Page, 2002), iTOL (Letunic and Bork, 2007)] are typically interactive.
Here, we present the Newick utilities, a set of automatable ﬁlters that implement the most frequent tree-processing operations.
To whom correspondence should be addressed.
Table 1.
Selected Newick utilities programs and their functions  Program  Function  nw_clade nw_distance  Extracts clades (subtrees), speciﬁed by labels Extracts branch lengths in various ways (from root,  nw_display  nw_match nw_order nw_rename nw_reroot nw_trim nw_topology  from parent, as matrix, etc.)
Draws trees as ASCII or SVG (suitable for further editing for presentations or publications), several options  Reports matches of a tree in a larger tree Orders tree nodes, without altering topology Changes node labels Reroots trees on an outgroup, speciﬁed by labels Trims a tree at a speciﬁed depth Retains topological information  SVG, Scalable vector graphics.
2 RESULTS The Newick utilities have the following features:  (cid:127) no user interaction is required  (cid:127) input is read from a ﬁle or from standard input  output is written  to standard output   (cid:127) all options are passed on the command line (no control ﬁles)  (cid:127) the input format is Newick (Archie et al., 1986)  (cid:127) the output is in plain text (Newick, ASCII graphics or SVG)  (cid:127) there are no limits to the number or size of the input trees  (cid:127) each program performs one function, with some variants  and (cid:127) the programs are self-documenting (option -h).
2.1 Example: Bootscanning Bootscanning (Salminen, 1995) locates recombination breakpoints by identifying (locally) closest relatives of a reference sequence.
An example implementation is as follows:  (1) produce a multiple alignment of all sequences, including the  reference   (2) divide the alignment into equidistant windows of constant  size (e.g.
300 bp every 50 bp)   (3) compute a maximum-likelihood tree for each window  (4) root the trees on the appropriate outgroup (not the reference)     The Author(s) 2010.
Published by Oxford University Press.
This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/2.5), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.
[12:27 3/6/2010 Bioinformatics-btq243.tex]  Page: 1669 1669 1670   T.Junier and E.M.Zdobnov  ]  e  t i s / .
t s b u s [    e c n e r e  f  e r    o  t    e c n a t s d  i  Bootscanning of HRV_3UTR.dna WRT CL073908, slice size 300 nt   0.4  0.35  0.3  0.25  0.2  0.15  0.1  0.05  0  100  HRV-58 HRV-88 HRV-7 HRV-89 HRV-36 HRV-9 HRV-32 HRV-67   800   300   200  700 position of slice centre in alignment [nt]   400   500   600  Fig.
1.
Bootscanning using PhyML, EMBOSS, Muscle, Newick utilities, GNUPlot and standard Unix shell programs.
The species with the lowest distance is the reference s nearest neighbor (by distance along tree branches).
A recombination breakpoint is predicted near position 450, as the nearest neighbor changes abruptly.
(5) from each tree, extract the distance (along the tree) from the  reference to each of the other sequences  and  (6) plot the result (Fig.
1).
The distribution includes a Bash script, bootscan.sh, that performs the procedure with Muscle (Edgar, 2004) (Step 1), EMBOSS (Rice et al., 2000) (Step 2), PhyML (Step 3), GNUPlot (Step 6) and Newick utilities for Steps 4 and 5.
This method was used to detect breakpoints in human enterovirus (Tapparel et al., 2007).
3 DISCUSSION The Newick utilities add tree-processing capabilities to a shell user s toolkit.
Since they have no hard-coded limits, they can handle large amounts of data  since they are non-interactive, they are easy to automate into pipelines, and since they are ﬁlters, they can easily work with other shell tools.
Tree processing may also be programmed using a specialized package [e.g.
BioPerl (Stajich et al., 2002), APE (Paradis et al., 2004) or ETE (Huerta-Cepas et al., 2010)], but this implies knowledge of the package, and such programs tend to be slower and use more resources than their C equivalents.
The difference is particularly apparent for large trees (Fig.
2).
3.1 Python bindings To combine the advantages of a high-level, object-oriented language for the application logic with a C library for fast data manipulation, one can use the Newick utilities through Python s ctypes module.
This allows one to code a rerooting program in 25 lines of Python while retaining good performance (Fig.
2).
A detailed example is included in the documentation.
Some users will feel more at ease working in the shell or with shell scripts, using existing bioinformatics tools  others will prefer to code their own tools in a scripting language.
The Newick utilities are designed to meet the requirements of both.
ACKNOWLEDGEMENTS We wish to thank the members of the E.Z.
group for feedback and beta testing.
1670  5 min  1 min  0 0 1  0 1  1  1 0  .
1 0 0  .  ]
s [    e m  i t  Newick Utils Newick Utils/Python ctypes ETE APE BioPerl  0  5000  10000  15000  20000  Tree size [# leaves]  Fig.
2.
Average run times (10 samples) of rerooting tasks on various tree sizes in different implementations.
The task involved reading, rerooting and printing out the tree as Newick.
Runs of the BioPerl and APE implementation on the 20 000-leaf tree did not complete.
Error bars show 1 SD.
Computer: 3 GHz 64 bit Intel Core 2 Duo, 1 GB RAM, Linux 2.6.
Made with R (R Development Core Team, 2008).
Funding: The Infectigen Foundation  Swiss National Science Foundation (grant 3100A0-112588 to E.Z.).
Conﬂict of Interest: none declared.
REFERENCES Archie,J.
et al.
(1986) http://evolution.genetics.washington.edu/phylip/newicktree.html.
Edgar,R.C.
(2004) MUSCLE: multiple sequence alignment with high accuracy and high  throughput.
Nucleic Acids Res., 32, 1792 1797.
Felsenstein,J.
(1989) PHYLIP - Phylogeny Inference Package (version 3.2).
Cladistics,  5, 164 166.
Guindon,S.
and Gascuel,O.
(2003) A simple, fast, and accurate algorithm to estimate  large phylogenies by maximum likelihood.
Syst.
Biol., 52, 696 704.
Huerta-Cepas,J.
et al.
(2010) ETE: a python environment for tree exploration.
BMC  Bioinformatics, 11, 24.
Letunic,I.
and Bork,P.
(2007) Interactive Tree Of Life (iTOL): an online tool for  phylogenetic tree display and annotation.
Bioinformatics, 23, 127 128.
Page,R.
(2002) Visualizing phylogenetic trees using TreeView.
Curr.
Protoc.
Bioinformatics, Chapter 6, Unit 6.2.
Paradis,E.
et al.
(2004) APE: analyses of phylogenetics and evolution in R language.
Bioinformatics, 20, 289 290.
Rice,P.
et al.
(2000) EMBOSS: the European molecular biology open software suite.
Trends Genet., 16, 276 277.
R Development Core Team (2008) R: A Language and Environment for Statistical Computing.
R Foundation for Statistical Computing, Vienna, Austria.
ISBN 3-900051-07-0.
Salminen, M. (1995) Identiﬁcation of breakpoints in intergenotypic recombinants of  HIV type I by bootscanning.
AIDS Res.
Hum.
Retroviruses, 11, 1423 1425.
Stajich,J.E.
et al.
(2002) The Bioperl toolkit: Perl modules for the life sciences.
Genome  Res., 12, 1611 1618.
Tapparel,C.
et al.
(2007) New complete genome sequences of human rhinoviruses shed  light on their phylogeny and genomic features.
BMC Genomics, 8, 224.
[12:27 3/6/2010 Bioinformatics-btq243.tex]  Page: 1670 1669 1670
