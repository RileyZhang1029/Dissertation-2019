BIOINFORMATICS  Vol.
24 ISMB 2008, pages i132 i138 doi:10.1093/bioinformatics/btn150  The multiple gene duplication problem revisited Mukul S. Bansal and Oliver Eulenstein   Department of Computer Science, Iowa State University, Ames, IA 50011, USA  ABSTRACT Motivation: Deciphering the location of gene duplications and multiple gene duplication episodes on the Tree of Life is fundamental to understanding the way gene families and genomes evolve.
The multiple gene duplication problem provides a framework for placing gene duplication events onto nodes of a given species tree, and detecting episodes of multiple gene duplication.
One version of the multiple gene duplication problem was deﬁned by Guigó et al.
in 1996.
Several heuristic solutions have since been proposed for this problem, but no exact algorithms were known.
Results: In this article we solve this longstanding open problem by providing the ﬁrst exact and efﬁcient solution.
We also demonstrate the improvement offered by our algorithm over the best heuristic approaches, by applying it to several simulated as well as empirical datasets.
Contact: oeulenst@cs.iastate.edu  1 INTRODUCTION Gene duplication is known to have played a major role in the evolution of almost all life on Earth.
For example, analyses of genomic data from numerous plants such as grasses (Guyot and Keller, 2004  Paterson et al., 2004  Schlueter et al., 2004  Vandepoele et al., 2003  Wang et al., 2005  Yu et al., 2005), Arabidopsis or other Brassicaceae (Blanc et al., 2003  Bowers et al., 2003  Cannon et al., 2006  Schlueter et al., 2004  Schranz and Mitchell-Olds, 2006  Simillion et al., 2002  Vision et al., 2000), poplar (Sterck et al., 2005), cotton (Blanc and Wolfe, 2004  Rong et al., 2004) and Physcomitrella (Rensing et al., 2007), among others, have revealed evidence of ancient gene duplications.
Complex evolutionary processes such as gene duplication and loss, recombination and horizontal gene transfer generate gene trees that differ from species trees.
One approach to infer gene duplications is to reconcile the conﬂicting gene trees with respect to a trusted species tree (Bonizzoni et al., 2005  Chen et al., 2000  Goodman et al., 1979  Górecki and Tiuryn, 2004  Guigó et al., 1996  Mirkin et al., 1995  Page, 1994  Zhang, 1997).
Existing techniques that reconcile gene trees to species trees can identify gene duplications but cannot, in general, accurately locate them on the species tree.
Other approaches make use of sequence similarity to reconstruct the underlying evolutionary history of genes (see, for example, Wapinski et al., 2007a,b).
Probabilistic models for gene/species tree reconciliation as well as gene sequence evolution have also been developed (Arvestad et al., 2003, 2004).
There is evidence that many gene duplications are part of larger multiple gene duplication episodes, during which a large portion     To whom correspondence should be addressed.
of an organism s genome is duplicated.
In fact, it is known that the entire genomes of numerous species (many eukaryotes for example) have been entirely duplicated one or more times.
However, the rapid gene loss and gene rearrangements that follow a multiple gene duplication episode can make them difﬁcult or even impossible to detect  and there is often no clear consensus on the number of ancient multiple gene duplication episodes or their precise location in evolutionary history.
Deciphering the location of gene duplications and multiple gene duplication episodes on the Tree of Life is a fundamental problem in understanding the way gene families and genomes evolve.
The multiple gene duplication problem provides a framework for (i) mapping gene duplication events onto a given species tree and (ii) inferring and locating multiple gene duplication episodes.
Informally, the multiple gene duplication problem is to assign duplication events to nodes in a species trees in such a way that the total number of multiple gene duplication episodes (or simply episodes in short) is minimized.
This allows for a  parsimonious  reconciliation of the gene trees with respect to a trusted species tree, which helps to locate gene duplications, as well as to detect multiple gene duplication episodes, more accurately.
Guigó et al.
(1996) were the ﬁrst to address a comprehensive phylogenetic problem that maps duplication events from a collection of rooted, binary gene trees onto a larger rooted binary species tree.
They presented a heuristic that could be used to trace back the identiﬁed gene duplications to a few multiple gene duplication episodes.
Later on, this heuristic approach was reﬁned and restated in more formal terms, and used to study multiple gene duplication episodes in vertebrates by Page and Cotton (2002).
Essentially, this heuristic approach sought to solve the multiple gene duplication problem of Guigó et al.
by solving instead a similar problem which we refer to as the  episode clustering  problem.
An alternative version of the multiple gene duplication problem was introduced by Fellows et al.
(1998b) which they proved to be intrinsically difﬁcult.
Hence, we direct our focus to the work of Guigó et al.
and Page and Cotton.
The episode clustering problem determines duplication events using the Gene Duplication (GD) model from Goodman et al.
(1979).
Each duplication can be placed on any species on a path between the two (not necessarily distinct) most recent species that could have contained the duplication and its parent, respectively.
In case the parent does not exist, the path runs between the most recent species for the duplication and the root of the species tree.
An example is depicted in Figure 1.
The duplications in gene tree G are represented by the three bold vertices.
Associated with each bold vertex is its path represented by an interval.
For example, the interval [5,3] represents the path (cid:2)5,4,3(cid:3) in the species trees S. Let g denote the node corresponding to the interval [5,3].
Species 5 is the most recent species that could have contained g and the parent of species 3, i.e.
2, is the most recent    2008 The Author(s) This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/2.0/uk/) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.
[19:25 18/6/03 Bioinformatics-btn150.tex]  Page: i132  i132 i138   Multiple gene duplication problem revisited  2.1 Basic deﬁnitions and notation A tree T is a connected graph with no cycles, consisting of a node set V(T) and an edge set E(T).
T is rooted if it has exactly one distinguished node called the root which we denote by Ro(T).
Let T be a rooted tree.
We deﬁne  T to be the partial order on V(T) where x T y if y is a node on the path between Ro(T) and x.
The set of minima under  T is denoted by Le(T) and its elements are called leaves.
If  x,y   E(T) and x T y then we call y the parent of x denoted by PaT (x) and we call x a child of y.
The set of all children of y is denoted by ChT (y).
If two nodes in T have the same parent, they are called siblings.
The least common ancestor of a non-empty subset L  V (T), denoted as lca(L), is the unique smallest upper bound of L under  T .
A subtree of T rooted at node y  V(T), denoted by Ty, is the tree induced by  x  V(T): x  y .
T is (fully) binary if every node has either zero or two children.
Throughout this article, the term tree refers to a rooted fully binary tree.
Given a T b we deﬁne the interval [a,b]= x  V(T)  a T x  T b .
The height of T, denoted by h(T) is the number of nodes on a maximal length path from Ro(T) to a leaf node of T. Thus, a rooted binary tree with three leaves has height three.
2.2 The ME problem In this section we formally deﬁne the ME problem.
The ME problem seeks to assign duplication events to nodes in a species tree, where each duplication event is associated with an interval in the species tree describing the locations where that duplication can be placed.
The deﬁnition of duplication is based on the (GD) model introduced by Goodman et al.
(1979).
Guigó et al.
(1996) extended this model and deﬁned the associated intervals for each gene duplication.
Here we only provide deﬁnitions necessary to state the ME problem.
The GD model  is based on a gene and species tree from which gene duplications can be derived.
A species tree is a tree that depicts the evolutionary relationships of a set of species.
Given a gene family for a set of species, a gene tree is a tree that depicts the evolutionary relationships among the sequences encoding only that gene family in the given species.
Thus the vertices in a gene tree represent genes.
In order to compare a gene tree G with a species tree S a mapping from each gene g  V(G) to the most recent species in S that could have contained g is required.
Deﬁnition 2.1 (LCA Mapping).
A leaf-mappingLG,S : Le(G)  Le(S) speciﬁes, for each gene g, the species from which it was sampled.
The extension MG,S : V(G)  V(S) of LG,S is the LCA mapping deﬁned by MG,S(g)=lca(LG,S(Le(Gg)).
Deﬁnition 2.2 (Comparability).
The trees G and S are comparable if there exists a leaf-mapping LG,S.1 A set of gene trees G and S are comparable if each gene tree in G is comparable with S. Throughout the remainder of this article, G denotes a collection of input gene trees, S a comparable species tree, and G denotes an arbitrary gene tree in G.  1Note that mathematically speaking such a leaf-mapping always exists.
However, in the current context, we are only concerned with biologically relevant leaf-mappings.
i133  Fig.
1.
A gene tree G and a comparable species tree S is depicted.
The bold vertices in G are duplications and their intervals represent their allowed locations in the species tree S.  species that could have contained the parent of g. The Episode Clustering (EC) problem is, given a collection of gene trees and a species tree, ﬁnd a minimum number of locations in the species tree where all duplications in the gene trees can be placed.
For example, all three duplications in Figure 1 can be placed on species nodes 2 and 3  The EC problem itself has a long and interesting history.
Guigó et al.
(1996) presented a heuristic approach to solve this problem.
This heuristic was somewhat imprecise, and there were hints, but no formal algorithm, on how to deal with certain optimization steps.
Page and Cotton (2002) observed that the EC problem can be efﬁciently and cleanly reduced to the Set Cover problem.
They approach the EC problem using a heuristic for the intrinsically difﬁcult set-cover problem.
Recently, Burleigh et al.
(2008) gave an efﬁcient and exact solution for the EC problem.
However, the EC problem itself suffers from a major limitation: it minimizes the number of locations in the species tree at which gene duplications occur, but it need not minimize the total number of episodes of multiple gene duplication.
In fact, it is easy to ﬁnd examples where minimizing the number of locations, does not minimize the number of episodes.
Indeed, the desired goal in the papers of both Guigó et al.
(1996) and Page and Cotton (2002) is to minimize the number of episodes, and the EC problem was used only as a heuristic approach for this problem.
We refer to this problem of minimizing the number of episodes as the Minimum Episodes (ME) problem.
In essence, the ME problem is the multiple gene duplication problem as deﬁned by Guigó et al.
(1996).
Thus, all previous attempts at solving the ME problem have made use of heuristics approaches based on the EC problem.
In this article we ﬁnally solve a longstanding open problem by providing the ﬁrst exact and efﬁcient solution to the ME problem (see Section 3).
Our algorithm is surprisingly simple and extremely efﬁcient.
We have also implemented our algorithm and demonstrated the improvement it offers over the best heuristic approaches experimentally by applying it to several simulated as well as empirical datasets (see Section 4).
2 BASIC DEFINITIONS, NOTATION AND  PRELIMINARIES  In this section we ﬁrst introduce basic deﬁnitions and notation that we shall use and then deﬁne the preliminaries required for this work.
[19:25 18/6/03 Bioinformatics-btn150.tex]  Page: i133 i132 i138   M.S.Bansal and O.Eulenstein  Deﬁnition 2.3 (Duplication).
A node v  V(G) is a (gene) duplication if MG,S(v)= MG,S(u) for some u  Ch(v) and we deﬁne Dup(G,S)= g  V(G)  g is a duplication  .
Deﬁnition 2.4 (Interval I(g)).
For every g  Dup(G,S), the interval I(g) is deﬁned to be: (cid:127) [MG,S(g),Ro(S)], if g= Ro(G), (cid:127) [MG,S(g),MG,S(g)], if MG,S(g)= MG,S(Pa(g)) and (cid:127) [MG,S(g),MG,S(Pa(g))]  MG,S(Pa(g)) ,otherwise.
Deﬁnition 2.5 (Valid Mapping).
A mapping FG,S : V(G)  V(S) is called valid if for each g  G,  (cid:1)  FG,S(g)=  s, where s  I(g), MG,S(g),  if g  Dup(G,S), otherwise.
Note: (i) F is used to denote the mapping  G GFG,S, and we say F is valid if FG,S is valid for each G G, (ii) given a mapping F, and a node s  V(S), we write F 1(s) to denote the set  g: F(g)= s  and (iii) in the remainder of this article, we denote by FM the valid mapping  G G MG,S.
Deﬁnition 2.6 (H(F ,s)).
Given G and S, a valid mapping F, and a node s  V(S), we deﬁne H(F ,s) to be the sub-graph of G2 induced by the node set F 1(s).
Note that H(F ,s) must be a forest.
Throughout this article we abbreviate the term  multiple gene duplication episode  simply to  episode .
Given any valid mapping F, the following deﬁnition deﬁnes (i) the number of episodes,  (F ,s), at each node s  V(S) and (ii) the total number of episodes  (F).
For the actual deﬁnition of an episode itself, we refer the reader to Guigó et al.
(1996).
Deﬁnition 2.7 ( (F ,s) and  (F)).
Given a valid mapping F and a node s  V(S), we denote by  (F ,s) the number of episodes at s caused by the mapping F. Then,  (F ,s)=max h(T): T    H(F ,s) , and,  (F)=(cid:2)  s V(S)  (F ,s).
Deﬁnition 2.8 ( opt).
opt =min  (F):F is any valid mapping .
G and S form the input for the ME problem.
The output is a valid mapping Fopt : G GV(G)  V(S), such that  (Fopt) is minimized.
More formally,  Problem 1.
Minimum Episodes (ME)  Instance:  Find:  A collection of gene trees G and a comparable species tree S. A valid mapping Fopt such that  (Fopt)=  opt.
3 THE ME PROBLEM It is not hard to see that the number of distinct valid mappings can be extremely large (exponential in the size of the input).
It is therefore infeasible to solve the ME problem by considering all possible valid mappings and then picking the one that causes the fewest episodes.
2When G is viewed as a forest.
i134  In this section we give a simple and extremely efﬁcient algorithm to solve the ME problem.
The main idea of the algorithm is to traverse the species tree S in post-order, and perform greedy optimization steps at each node.
As we shall prove, this leads us to a globally optimal mapping.
In order to state the algorithm, we must ﬁrst deﬁne a few terms.
Deﬁnition 3.1 (Leading node).
Let F be a valid mapping and let s  V(S).
Then, we say a node g F 1(s) is a leading node if and only if g= Ro(T) where T   H(F ,s) and h(T)=  (F ,s).
Deﬁnition 3.2 (Free node).
Given a valid mapping F, and a node s  V(S) such that s(cid:9)= Ro(S), a node g F 1(s) is called free if and only if Pa(s)  I(g).
For convenience, we refer to each node s  V(S) for which F 1(s)(cid:9)= , as a relevant node.
Also recall that FM denotes the mapping  G G MG,S.
We begin by stating the intuitive idea behind our algorithm.
Consider any valid mappingF : G GV(G)  V(S).
Given any node s  V(S), let F(cid:11) be a new mapping constructed from F by moving the mapping of all the free nodes in F 1(s) to Pa(s).
Clearly, F(cid:11) must be a valid mapping.
Now, if all the leading nodes in F 1(s) are free, then we can show that  (F(cid:11) )   (F).
On the other hand, if not all the leading nodes in F 1(s) are free, then we must have  (F(cid:11) )   (F).
This simple observation forms the basis of our greedy algorithm.
If these greedy optimizations are carried out in a particular order, then it can be shown that the resulting mapping will be an optimal one.
We are now ready to state our algorithm.
The algorithm starts with the LCA mapping from the gene trees to the species tree, and progressively modiﬁes it so that when the algorithm terminates, we have an optimal valid mapping.
First, a valid mapping F :  G GV(G)  V(S) is initialized such that F =FM.
Next, we traverse S in post-order, and at each node, say s, we check if it is relevant and if all the leading nodes in F 1(s) are free.
If they are, then we modify the mapping F by changing the mapping of all the leading nodes in F 1(s) to Pa(s).
It can be shown that when the post-order traversal is ﬁnished, the mapping F must be a solution to the ME problem (see Theorem 3.1).
This algorithm is described more formally in Algorithm 1.  nodes map according to the LCA mapping.
Algorithm 1 This algorithm solves the ME problem Input: A set of gene trees G and the species tree S. Initially all gene 1: Compute the LCA mapping MG,S for each G G. 2: Compute the interval I(g) for each gene tree node g. 3: F : G GV(G)  V(S) denotes a valid mapping.
Initially, set F = G G MG,S.
4: for each node s in a post-order traversal of S do Deﬁne a mapping (cid:3)F : G GV(G)  V(S) as follows: if s is a relevant node then 5: if all leading nodes in F 1(s) are free then (cid:1) 6: (cid:3)F(g)= 7: Rename (cid:3)F to F  if g is a leading node in F 1(s), otherwise.
Pa(s), F(g),  (1)  8: 9: return F  [19:25 18/6/03 Bioinformatics-btn150.tex]  Page: i134  i132 i138   We denote the ﬁnal mapping output by Algorithm 1 by Fopt.
In the remainder of this section we ﬁrst show that Fopt is a valid mapping and  (Fopt)=  opt, and then study the complexity of Algorithm 1.
Lemma 3.1.
Fopt is a valid mapping.
Proof.
Algorithm 1 starts with the mapping F =FM which is valid by deﬁnition.
During each iteration of the loop, the mapping F may be modiﬁed according to Equation (1).
However, Equation (1) only modiﬁes the mapping of those nodes that are free, and hence produces a valid mapping.
Therefore, each mapping produced by the algorithm, including the mapping Fopt, is valid.
(cid:1) Lemma 3.2.
Let F :  G G V(G)  V(S) be any valid mapping.
Then we have the following: 1.
If s  V(S) is a relevant node under mapping FM, then 2.
If s  V(S) is not a relevant node under mapping FM, then   (FM,s) 1   (F ,s)   (FM,s).
0   (F ,s) 1.
Proof.
Part 1: Here s is a relevant node i.e.
F 1 M (s)(cid:9)= .
Let A denote the set of nodes that are present in F 1 M (s) but not in F 1(s) and B denote the set of nodes that are present in F 1(s) but not in F 1 M (s).
Observe that all the nodes in A must be leading nodes in F 1 M (s).
Relocating all the leading nodes in F 1 M (s) reduces  (FM,s) by exactly 1.
Therefore, relocating the nodes in A reduces  (FM,s) by at most 1.
This proves that  (FM,s) 1   (F ,s).
Consider now the set B.
Let a and b be two gene duplication nodes from some gene tree in G such that one is an ancestor of the other, and FM(a)(cid:9)=FM(b).
Then, Deﬁnition 2.4 implies that F(a)(cid:9)=F(b).
Therefore, none of the nodes in set B is an ancestor of another, and hence none of them is a leading node in F 1(s).
This proves that  (F ,s)   (FM,s).
Part 2: In this case F 1 M (s)= , and therefore B=F 1(s).
Following the argument from the previous paragraph, we can conclude that none of the nodes in set B is an ancestor of another.
This implies that  (F ,s) 1.
(cid:1)  The following three lemmas are required for the proof of  Theorem 3.1.
Lemma 3.3.
Let F :  G G V(G)  V(S) be a valid mapping and s  V(S) be a node such that  (Fopt ,s)    (F ,s).
Then,  (Fopt ,s)=1.
Proof.
There are two possible cases: (i) s is not a relevant node under FM or (ii) s is a relevant node under FM.
We analyze these cases separately.
Case (i): In this case, by Part 2 of Lemma 3.2, we must have  (F ,s)=0 and  (Fopt ,s)=1.
Case (ii): If  (FM,s)  2, then by Part 1 of Lemma 3.2 the result follows immediately  therefore, let us assume that  (FM, s)   2.
Part 1 of Lemma 3.2 implies that we must have  (F ,s)=  (FM,s) 1 and  (Fopt ,s)=  (FM,s).
Let A denote the set of nodes that are present in F 1 in F 1(s), and B denote the set of nodes that are present in F 1  M (s) but not opt (s)  Multiple gene duplication problem revisited  but not in F 1 M (s).
All the nodes in A must be leading nodes in F 1 M (s), and since these nodes are not present in F 1(s), all the nodes in A must be free as well.
Also, none of the nodes in B can be a leading node in F 1 opt (s) (see the proof of Part 1 of Lemma 3.2).
Therefore, all of the leading nodes in F 1 opt (s) must be present in A, which implies that all the leading nodes in F 1 opt (s) are free.
Thus, during the execution of Algorithm 1, the mapping for these nodes would have been changed.
This is a contradiction, and hence we cannot have  (FM,s) 2.
(cid:1) Lemma 3.4.
Let node a be such that FM(a)  S Fopt(a).
If F :  G G V(G)  V(S) is a valid mapping such that F(a) = FM(a), then  (Fopt ,FM(a))    (F ,FM(a)).
Proof.
Since F(a)  S Fopt(a), a must be a leading node in F 1 M (a).
This implies that  (F ,FM(a))(cid:9)   (FM,FM(a)).
Moreover, since Fopt(a)(cid:9)=FM(a), we have  (Fopt ,FM(a))=  (FM,FM(a)) 1 (see Algorithm 1).
The lemma follows.
(cid:1) Lemma 3.5.
Let node a be such that FM(a)  S Fopt(a).
If   =  x: FM(a)  S x  S Fopt(a) , then Fopt(x)=0 for all x   .
Proof.
Consider any node x   .
There must exist some valid mapping F, realized during the execution of Algorithm 1, for which F(a)= x.
However, as the execution of Algorithm 1 progresses, the mapping of a changes.
This implies that a must be a leading node in F 1(a).
Observe that a could be a leading node in F 1(a) only if  (F ,x)=1.
Furthermore, for the mapping of a to be changed, all the nodes in F 1(a) must be free, and would therefore not map to node x when the algorithm terminates.
Thus, Fopt(x)=0.
(cid:1) Theorem 3.1.
Algorithm 1 solves the ME problem.
Proof.
In Lemma 3.1 we have already established that Fopt is a valid mapping.
Therefore, to establish the correctness of our algorithm, it is sufﬁcient to show that  (Fopt)=  opt.
Let us assume, for the sake of contradiction, that there exists some valid mapping F for which  (Fopt)    (F).
This implies that there must be at least one node s  V(S) for which  (Fopt ,s)    (F ,s).
We may assume, without any loss of generality, that s has the following property: there does not exist any other node t  V(Ss) for which  (Fopt ,t)    (F ,t).
By Lemma 3.3 we know that node s must be such that  (Fopt , s) = 1.
This implies that  (F , s) = 0, i.e.
F 1(s) =  .
(cid:2) least one node t  We will now show that V(Ss)\ s  for which  (Fopt ,t)    (F ,t).
This would imply that Let A=F 1 opt (s)  clearly A(cid:9)= .
We now have two possible scenarios, exactly one of which must be true: (i) F(g)  S s for each g  A or (ii) there exists some g  A for which F(g)  S s. If case (i) were possible, it would imply that all nodes in A are leading and free, and therefore Algorithm 1 would have already moved their mappings to nodes that are proper ancestors of s. Hence, case (ii) is the only possible scenario.
So far we have shown that if there exists some valid mapping F for which  (Fopt)    (F), then there must exist some node, say a, where a  A and F(a)  S s. Clearly, FM(a) S F(a)  S s. This leads us to two possible cases, exactly one of which  v V(Ss)  (Fopt ,v) (cid:2)  v V(Ss)  (F ,v).
there exists at  [19:25 18/6/03 Bioinformatics-btn150.tex]  Page: i135  i132 i138  i135   M.S.Bansal and O.Eulenstein  (cid:2)  v V(Ss)  and Q=(cid:2)  v V(Ss)  (F ,v).
F 1 opt (v)  v V(Ss)  (Fopt ,v) (cid:2) let P=(cid:2)  must be true: (i) FM(a)=F(a) or (ii) FM(a)  S F(a).
If case (i) were true, then by Lemma 3.4 we must have  (F ,F(a))    (Fopt ,F(a)).
If case (ii) were true, then Lemma 3.5 implies that  (Fopt ,F(a))=0, but  (F ,F(a))(cid:9)=0.
Thus, in either case, there exists some t  V(Ss)\ s , for which  (Fopt ,t)    (F ,t).
And hence, F 1(v).
Now, Suppose there exists a node x such that Fopt(x)  V(S)\V(Ss), and F(x)  V(Ss).
Then, there are two possibilities: (i) F(x)  V(Ss)\ s  or (ii) F(x)= s. In case (i), Lemma 3.5 implies that F 1 opt (s) must be empty, which is clearly a contradiction.
Similarly, case (ii) leads to a clear contradiction as well since F 1(s)= .
Therefore, such a node x cannot exist.
And hence Q  P. All together, this implies that in the subtree Ss, the mapping F induces at least as many episodes as the mapping Fopt, even F 1 though opt (s).
Let us now construct a new valid mapping F(cid:11):  G G V(G)  V(S) as follows:  v V(Ss)  v V(Ss)  v V(Ss)  (cid:2)  F 1(s) (cid:2) (cid:1) Fopt(g), F(g),  (g)=  F(cid:11)  if Fopt(g)  V(Ss), otherwise.  )
(F).
Moreover, F(cid:11)  In light of the observation made in the previous paragraph, we must have  (F(cid:11) has fewer nodes s for which  (Fopt ,s)    (F(cid:11),s).
Therefore, we can now set F to be F(cid:11) and a straightforward induction argument completes our (cid:1) proof.
We now study the complexity of Algorithm 1.
In order to simplify our analysis we assume that all G G have approximately the same size.
The input for the ME problem is the set of gene trees G, and species tree S. Let n= Le(S) , k= G  and m= Le(G)  for some G G. Theorem 3.2.
The time complexity of Algorithm 1 is O(kmn).
Proof.
Computing the LCA mapping for all the gene trees takes O(kmn) time (Zhang 1997).
With-in this time, the inverse LCA mapping is also easily computed.
All the intervals I(g) can be computed in O(km) time.
Now, at each node, s, in the species tree, we must (i) ﬁnd all the leading nodes in F 1(s), (ii) check if these leading nodes are free and (iii) update the mapping F. Let x= F 1(s) , then, each of the Steps (i), (ii) and (iii) above can be completed in O(x) time.
Hence, since x= O(km) and there are O(n) nodes in the species tree, we obtain a total time complexity of (cid:1) O(kmn) for Algorithm 1.
4 EXPERIMENTAL RESULTS We evaluated the efﬁcacy and efﬁciency of our novel algorithm for the ME problem through comparative studies on simulated and empirical datasets.
For this evaluation we implemented our algorithm in the program ExactMGD.
We compared our program against the program ApproxMGD of Burleigh et al.
(2008) that implements the currently best known approach to solve the ME problem.
Recall that the objective of the ME problem is to produce a mapping which deﬁnes the fewest number of episodes.
The smaller  i136  Table 1.
Performance of ExactMGD on simulated datasets  Dataset  Unoptimized  ApproxMGD  ExactMGD  50 taxa 100 taxa 200 taxa 400 taxa  30 47 64 65  28 38 54 45  25 35 49 40  Table 2.
Performance of ExactMGD on empirical datasets  Dataset  Unoptimized  ApproxMGD  ExactMGD  Guigó et al.
(1996) Burleigh et al.
(2008)  9 1180  7 1152  5 1042  the number of episodes, the more accurate the mapping.
Therefore, for each dataset we compared the programs by measuring three values: (i) The number of episodes deﬁned by the initial LCA mapping (i.e.
the unoptimized value), (ii) the number of episodes deﬁned by the mapping produced by ApproxMGD and (iii) the number of episodes deﬁned by the mapping produced by ExactMGD.
All analyses were performed on a 3 Ghz Intel Pentium 4 CPU based PC with Windows XP operating system.
A run of ExactMGD on each of these datasets terminated in less than 1s!
4.1 Simulated datasets Our simulated datasets consist of 50 randomly generated gene trees, all with the same set of taxa, along with a randomly generated species tree.3 We generated four such datasets, each with a different number of taxa (50, 100, 200 and 400) in the input trees.
ExactMGD shows a signiﬁcant reduction in the number of episodes as compared to ApproxMGD for each of the four datasets (Table 1).
4.2 Empirical datasets For the empirical study we evaluated two datasets from the literature.
The ﬁrst dataset consists of 53 gene trees, each representing the evolutionary history of different gene families from a set of 16 eukaryotes.
This set was assembled and evaluated for episodes by Guigó et al.
(1996).
Subsequently, this dataset was reused and its evaluation reﬁned by Page and Cotton (2002).
The second dataset, assembled and evaluated for episodes by Burleigh (2008), consists of 85 gene trees from the Phytome et al.
comparative plant genome database and contains genes from 136 plant taxa.
For brevity we refrain from performing biological analyses of our results  and only demonstrate the exceptional level of improvement offered by our algorithm over the best current methods.
The results depicted in Table 2 show that the mappings produced by our  3Our randomly generated trees have a random (binary) topology and a random assignment of leaf labels.
[19:25 18/6/03 Bioinformatics-btn150.tex]  Page: i136  i132 i138   Multiple gene duplication problem revisited  algorithm are signiﬁcantly more optimal compared to the mappings produced by the best current approaches.
This leads to more accurate inference of the location of gene and genome duplications on the Tree of Life.
Blanc,G.
et al.
(2003) A recent polyploidy superimposed on older large-scale  duplications in the Arabidopsis genome.
Genome Res., 13, 137 144.
Bonizzoni,P.
et al.
(2005) Reconciling a gene tree to a species tree under the duplication  cost model.
Theor.
Comput.
Sci., 347, 36 53.
Bowers,J.
et al.
(2003) Unravelling angiosperm genome evolution by phylogenetic  analysis of chromosomal duplication events.
Nature, 422, 433 438.
5 OUTLOOK AND CONCLUSION In this article we have provided the ﬁrst exact and efﬁcient algorithm for a longstanding open problem.
Traditionally, the multiple episodes problem has been used to infer the location of episodes of multiple gene duplication on a given species tree.
Our new algorithm allows this to be done far more accurately.
But another interesting and important fallout of our algorithm is that it may also allow us to infer the  correct  species trees.
Consider the problem of constructing a species tree from conﬂicting gene trees based on the gene duplication optimality criteria.
The gene duplication problem is to ﬁnd for a given set of gene trees a corresponding species tree with the minimum reconciliation cost (Fellows et al., 1998a  Hallett and Lagergren, 2000  Ma et al., 2000  Stege, 1999).
However, since these gene duplication events are usually a part of larger multiple gene duplication episodes, it might be more helpful if we can infer species trees directly based on the multiple gene duplication optimality criteria (see also Fellows et al.
1998b).
Our algorithm offers the ﬁrst practical and effective means to do so.
The idea is to use a local search based hill climbing heuristic to traverse through the search space of possible species tree.
Our algorithm can be used to compute the number of episodes induced by each candidate species tree during the local search steps.
The lower the number of episodes, the better the species tree.
In addition,  it would be interesting to extend the multiple GD model of Guigó et al.
(1996) by relaxing the constraints on the possible locations of gene duplications on the species tree.
ACKNOWLEDGEMENTS The authors wish to thank the anonymous referees for their invaluable comments.
Funding: This work was supported in part by National Science Foundation AToL grant EF-0334832.
Conﬂict of Interest: none declared.
REFERENCES Arvestad,L.
et al.
(2003) Bayesian gene/species tree reconciliation and orthology analysis using mcmc.
In Proceedings of the Eleventh International Conference on Intelligent Systems for Molecular Biology (ISMB).
Brisbane, Australia, pp.
7 15.
Arvestad,L.
et al.
(2004) Gene tree reconstruction and orthology analysis based on an integrated model for duplications and sequence evolution.
In Bourne,P.E.
and Gusﬁeld,D.
(eds) Proceedings of the Eighth Annual International Conference on Computational Molecular Biology (RECOMB).
ACM, San Diego, California, USA, pp.
326 335.
Blanc,G.
and Wolfe,K.H.
(2004) Widespread paleopolyploidy in model plant inferred from age distributions of duplicate genes.
Plant Cell,  species 16, 1093 1101.
In Vingron,M.
and Wong,L.
Burleigh,J.G.
et al.
(2008) Locating multiple gene duplications through reconciled trees.
the 12th Annual International Conference in Research in Computational Molecular Biology (RECOMB).
Vol.
4955 in Lecture Notes in Computer Science, Springer, Singapore, pp.
273 284.
(eds) Proceedings of  Cannon,S.
et al.
(2006) Legume genome evolution viewed through the Medicago japonicus genomes.
Proc.
Natl Acad.
Sci., 103,  and Lotus  truncatula 14959 14964.
Chen,K.
et al.
(2000) Notung: a program for dating gene duplications and optimizing  gene family trees.
J. Comput.
Biol., 7, 429 447.
Fellows,M.
et al.
(1998a) Analogs & duals of the MAST problem for sequences & trees.
In Chwa,K.-Y.
and Ibarra,O.H.
(eds) Proceedings of the 9th International Symposium on Algorithms and Computation (ISAAC 98).
Vol.
1533 in Lecture Notes in Computer Science, Springer, Taejon, Korea, pp.
103 114.
Fellows,M.
et al.
(1998b) On the multiple gene duplication problem.
In 9th International Symposium on Algorithms and Computation (ISAAC 98), LNCS 1533.
Springer, Taejon, Korea, pp.
347 356.
Goodman,M.
et al.
(1979) Fitting the gene lineage into its species lineage.
a parsimony strategy illustrated by cladograms constructed from globin sequences.
Syst.
Zool., 28, 132 163.
Górecki,P.
and Tiuryn,J.
(2004) On the structure of reconciliations.
In Lagergren,J.
(ed.)
Recomb Comparative Genomics Workshop 2004.
Vol.
3388, Springer, Bertinoro, Italy.
Guigó,R.
et al.
(1996) Reconstruction of ancient molecular phylogeny.
Mol.
Phylogenet.
Evol., 6, 189 213.
Guyot,R.
and Keller,B.
(2004) Ancestral genome duplication in rice.
Genome, 47,  610 614.
Hallett,M.T.
and Lagergren,J.
(2000) New algorithms for the duplication-loss model.
In Shamir,R.
et al.
(eds) Proceedings of the Fourth Annual International Conference on Computational Molecular Biology (RECOMB 2000).
ACM, Tokyo, Japan, pp.
138 146.
Ma,B.
et al.
(2000) From gene trees to species trees.
SIAM J.
Comput., 30, 729 752.
Mirkin,B.
et al.
(1995) A biologically consistent model for comparing molecular  phylogenies.
J. Comput.
Biol., 2, 493 507.
Page,R.D.M.
(1994) Maps between trees and cladistic analysis of historical associations  among genes, organisms and areas.
Syst.
Biol., 43, 58 77.
Page,R.D.M.
and Cotton,J.A.
(2002) Vertebrate phylogenomics: reconciled trees and gene duplications.
the 7th Paciﬁc Symposium on Biocomputing (PSB 02).
Lihue, Hawaii, USA, pp.
536 547.
In Altman,R.B.
et al.
(eds) Proceedings of  Paterson,A.H.
et al.
(2004) Ancient polyploidization predating divergence of the cereals, and its consequences for comparative genomics.
Proc.
Natl.
Acad.
Sci., 101, 9903 9908.
Rensing,S.
et al.
(2007) An ancient genome duplication contributed to the abundance of metabolic genes in the moss physcomitrella patens.
BMC Evol.
Biol., 7, 130.
Rong,J.
et al.
(2004) A 3347-locus genetic recombination map of sequence-tagged sites reveals features of genome organization, transmission and evolution of cotton (Gossypium).
Genetics, 166, 389 417.
Schlueter,J.
et al.
(2004) Mining EST databases to resolve evolutionary events in major  crop species.
Genome, 47, 868 876.
Schranz,M.
and Mitchell-Olds,T.
(2006) Independent ancient polyploidy events in sister  families Brassicaceae and Cleomaceae.
Plant Cell, 18, 1152 1165.
Simillion,C.
et al.
(2002) The hidden duplication past of Arabidopsis thaliana.
Proc.
Natl.
Acad.
Sci., 99, 13627 1632.
Stege,U.
(1999) Gene trees and species trees: the gene-duplication problem is ﬁxed- parameter tractable.
In Proceedings of the 6th International Workshop on Algorithms and Data Structures, LNCS 1663, Springer, Vancouver, Canada.
Sterck,L.
et al.
(2005) EST data suggest that poplar is an ancient polyploidy.
New  Phytol., 167, 165 170.
Vandepoele,K.
et al.
(2003) Evidence that rice and other cereals are ancient aneuploids.
Plant Cell, 15, 2192 2202.
Vision,T.
et al.
(2000) The origins of genome duplications in Arabidopsis.
Science, 290,  2114 2117.  i137  [19:25 18/6/03 Bioinformatics-btn150.tex]  Page: i137  i132 i138   M.S.Bansal and O.Eulenstein  Wang,X.
et al.
(2005) Duplication and DNA segmental loss in the rice genome:  Wapinski,I.
et al.
(2007b) Natural history and evolutionary principles of gene  implications for diploidization.
New Phytol., 165, 937 946.  duplication in fungi.
Nature, 449, 54 61.
Wapinski,I.
et al.
(2007a) Automatic genome-wide reconstruction of phylogenetic gene trees.
In Proceedings of 15th International Conference on Intelligent Systems for Molecular Biology (ISMB) & 6th European Conference on Computational Biology (ECCB), ISMB/ECCB (Supplement of Bioinformatics).
Vienna, Austria, pp.
549 558.
Yu,J.
et al.
(2005) The genomes of Oryza sativa: a history of duplication.
PLoS Biol.,  3, 266 281.
Zhang,L.
(1997) On a Mirkin-Muchnik-Smith conjecture for comparing molecular  phylogenies.
J. Comput.
Biol., 4, 177 187.  i138  [19:25 18/6/03 Bioinformatics-btn150.tex]  Page: i138  i132 i138
