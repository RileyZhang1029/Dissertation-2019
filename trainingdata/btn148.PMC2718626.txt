BIOINFORMATICS  Vol.
24 ISMB 2008, pages i114 i122 doi:10.1093/bioinformatics/btn148  Estimating true evolutionary distances under the DCJ model Yu Lin and Bernard M.E.
Moret   Laboratory for Computational Biology and Bioinformatics, Swiss Federal Institute of Technology (EPFL), EPFL-IIS-LCBB, INJ 230, Station 14, CH-1015 Lausanne, Switzerland  interest  ABSTRACT Motivation: Modern techniques can yield the ordering and strandedness of genes on each chromosome of a genome  such data already exists for hundreds of organisms.
The evolutionary mechanisms through which the set of the genes of an organism is altered and reordered are of great to systematists, evolutionary biologists, comparative genomicists and biomedical researchers.
Perhaps the most basic concept in this area is that of evolutionary distance between two genomes: under a given model of genomic evolution, how many events most likely took place to account for the difference between the two genomes  Results: We present a method to estimate the true evolutionary distance between two genomes under the  double-cut-and-join  (DCJ) model of genome rearrangement, a model under which a single multichromosomal operation accounts for all genomic rearrangement events: inversion, transposition, translocation, block interchange and chromosomal fusion and ﬁssion.
Our method relies on a simple structural characterization of a genome pair and is both analytically and computationally tractable.
We provide analytical results to describe the asymptotic behavior of genomes under the DCJ model, as well as experimental results on a wide variety of genome structures to exemplify the very high accuracy (and low variance) of our estimator.
Our results provide a tool for accurate phylogenetic reconstruction from multichromosomal gene rearrangement data as well as a theoretical basis for reﬁnements of the DCJ model to account for biological constraints.
Availability: All of our software is available in source form under GPL at http://lcbb.epﬂ.ch Contact: bernard.moret@epﬂ.ch  1 INTRODUCTION The ordering and strandedness of genes on each chromosome of many organisms have become available, with many more added every year.
Using this information, one can represent a genome as a collection of chromosomes, each of which is a linear or circular sequence of gene identiﬁers.
Variations in the placement of the same genes, as well as variations in gene content and multiplicity, among organisms can then be analyzed.
This data is of great interest to evolutionary biologists, but also to comparative genomicists and to any researcher interested in understanding evolutionary changes in pathogens.
In the past 10 years, there has been a large increase in work done on analyzing such data (see, e.g.
Moret et al., 2005).
Perhaps the most basic requirement in the analysis of such data is the ability to estimate the amount of evolutionary change between two genomes that is, to compute a pairwise evolutionary distance.
Since the true distance, that is, the actual number of    To whom correspondence should be addressed.
changes in the gene order and content that took place during the course of evolution, is not something we can compute, researchers have used a two-stage process, in which a well-deﬁned measure is ﬁrst computed (such as an edit distance, that is, the smallest number of evolutionary changes from a deﬁned set needed to transform one genome into the other), then a statistical model of evolution is used to infer an estimate of the true distance by deriving the effect of a given number of changes in the model on the computed measure and (algebraically or numerically) inverting the derivation to produce a maximum-likelihood estimate of the true distance under the model.
This second step is often called a distance  correction  and has long been used for sequence (DNA) data (see, e.g.
Swofford et al., 1996) as well as, more recently, for gene-order data, (for which see Moret et al., 2001, 2002  Sankoff and Blanchette, 1999  Wang, 2001  Wang and Warnow, 2001).
The measures commonly used in the ﬁrst step (edit distances, synteny measures, etc.)
are bounded and typically reﬂect only the endstate of an evolutionary process, whereas the true evolutionary distance can be arbitrarily large.
Thus these ﬁrst-step measures typically underestimate the true distance, by an amount that grows quickly as the true distance grows large.
This is an aspect of the problem of saturation, in which the evolutionary process may take a convoluted path to its endstate, possibly even undoing earlier changes along the way.
For very small distances, the problem does not arise, while, for extremely large ones, the problem is essentially insurmountable, as the variance of any estimate will be huge.
For most distance values, however, one can view the goal of distance correction as postponing the onset of saturation, is, making it possible to deliver an accurate estimate of the true distance up to as large a value as possible.
that  indirectly,  Evolutionary events that affect  the gene order of genomes include a number of rearrangements, which affect only the order, as well as gene duplication and loss, which affect both the gene content and, the order.
Handling both together has proved challenging ﬁrst steps were taken recently by Marron et al.
(2004), Swenson et al.
(2005, 2008).
Rearrangements themselves include inversion, transposition and block exchange, which act on a single chromosome, and translocation, fusion and ﬁssion, which act on two chromosomes.
Inversion, translocation, fusion and ﬁssion were characterized in the seminal work of Hannenhalli and Pevzner (1995a,b), while Bader et al.
(2001) showed how to compute edit distances for these operations in linear time.
In contrast, transpositions remain poorly understood.
Efforts at unifying some of these operations in a statistical framework have had some success (Durrett et al., 2004).
However, Yancopoulos et al.
(2005) recently deﬁned and studied a unifying these rearrangements in operation that can produce each of    2008 The Author(s) This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/2.0/uk/) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.
[16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i114  i114 i122   one or two steps: the so-called  double-cut-and-join , or DCJ, operation.
Bergeron et al.
(2006) subsequently generalized the DCJ operation and showed how to compute an edit distance for it (assuming that every operation has unit cost) in linear time with a simple formula.
In this article, we address the problem of estimating a true evolutionary distance under the DCJ model of evolution, assuming no change in gene content and a uniform distribution of all possible DCJ events the same simplifying assumptions used to date in all rearrangement analyses.
Our estimate is in the style of the IEBP estimate for the true inversion distance for (see also Wang a single chromosome due to Wang (2001) and Warnow, 2001), require computing an edit distance, but only a simple count of shared gene adjacencies [or, equivalently, breakpoints, as in the seminal work of Sankoff and Blanchette (1998, 1999)] and chromosome endpoints.
We characterize the asymptotic behavior of genome structure under the uniform DCJ model and present experimental results showing that our estimates are very precise, and exhibit very little variance, under both realistic and extreme parameter settings.
it does not  in that  (cid:3)  (cid:3) to 5  2 BACKGROUND 2.1 Genomes as gene-order data A gene is a stranded sequence of DNA that starts with a tail and ends with a head.
The tail of a gene a is denoted by at and its head by ah.
We write +a (at   ah) if gene a is transcribed from 3 and write  a (ah  at) otherwise.
We are interested, not in the strand of one single gene, but in the connection of two consecutive genes in one chromosome.
Due to different strandedness, two consecutive genes b and c can be connected by one adjacency of the following four types,  bt , ct ,  bh, ct ,  bt , ch  and  bh, ch .
If gene d lies at one end of a linear chromosome, then we have a singleton set,  dt  or  dh , called telomere.
In the simplest case, we assume equal gene content and no duplicate gene.
A genome is then represented as a set of adjacencies and telomeres such that the tail or the head of any gene appears in exactly one adjacency or telomere.
For example, the genome G illustrated in Figure 1, composed of two linear and one circular chromosomes, (a, c, f ), (e) and (b,d,b), can be represented by the following set of adjacencies and telomeres:   at , ah,ch , ct ,f h , f t , bh,dt , dh,bt ,  et , eh  .
The number of adjacencies and telomeres in one genome only captures the number of linear chromosomes: k adjacencies from circular chromosomes could come from a single circular chromosome of size k or from k circular chromosomes of one gene each, or any other combination.
In particular, every genome on n  a   c   f  e  Fig.
1.
A very small genome G.  b  d  Evolutionary distances under DCJ model  genes made entirely of circular chromosomes has the same number of adjacencies and telomeres.
2.2 Preliminaries on the DCJ model The double-cut-and-join operation, in the formulation of Bergeron et al.
(2006), can model all classical rearrangements: inversion, translocation, fusion, ﬁssion, transposition and block interchange.
In that formulation, a DCJ operation makes a pair of cuts in the chromosomes and reglues the cut ends on two adjacencies or telomeres (which can be in the same chromosome or in different chromosomes), giving rise to four cases: 1 A pair of adjacencies  iu, jv  and   px, qy  can be replaced by the pair  iu, px  and   jv, qy  or by the pair  iu, qy  and   jv, px .
2 An adjacency  iu, jv  and a telomere   px  can be replaced by the adjacency  iu, px  and telomere   jv  or by the adjacency   jv, px  and telomere  iu .
3 A pair of telomeres  iu  and  jv  can be replaced by the adjacency  iu,jv .
4 An adjacency  iu,jv  can be replaced by the pair of telomeres  iu  and   jv .
Theorem 1.
Let G be a genome with n genes, n1 adjacencies, and n2 telomeres.
If m is the number of the different possible DCJ operations on G, we can write  2  n = n1+ n2 m = n2 n2   m 2n2 n  +2n1n2+ 1  2  1  n2 2    1 2  n2  Proof.
G has n genes and thus 2n tails and heads of genes  as the tail or the head of any gene appears in exactly one adjacency or telomere, we have  2n= 2n1+n2  (cid:1)  (1)  (cid:2) 2  (cid:1)  (cid:2)  n1 2  (cid:1)  (cid:2)  n2 2  Now consider the four cases of DCJ operations:  1.
There are  ways to select two adjacencies and two possible  DCJ operations for each such choice, for a total of operations.
2.
There are n1 n2 ways  to select one adjacency and one telomere and two possible DCJ operations for each  combination, for a total of n1 n2 2 operations.
n1 2  3.
There are  ways to select two telomeres and one possible n2 2  DCJ operation for each such choice, for a total of operations.
(cid:1)  (cid:2)  4.
There are n1 different ways to select one adjacency and one possible DCJ operation for each such choice, for a total of n1 operations.
Thus the total number of possible DCJ operations is  m= n2  1  +2n1n2+ 1  n2 2    1 2  n2  2 Combining this result with (1), we get +(n  1 2  m=  1 4  n2 2  )n2+n2  (2)  i115  [16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i115  i114 i122   Y.Lin and B.M.E.Moret  Now we also have 0  n2 2n, and so we can write n2  m 2n2 n  (cid:1)  3 METHODS 3.1 An overview of our technique for estimating the  true evolutionary distance  The problem of estimating the true evolutionary distance under DCJ model is deﬁned as follows:  Input: The original genome G and the ﬁnal genome GF, two genomes on the same n genes represented as adjacencies and telomeres.
Output: An estimate of the actual number of DCJ operations that took place in the evolutionary history to transform G into GF.
,d    A    A, s  into four sets S    A and D    T , where S  that do not appear in G and D  Based on the original genome G, for any genome G    A is the set of adjacencies of G that also appear in G, D  (of same gene content       T , A, S as G), we can divide the adjacencies and telomeres of G     that also appear in G, S D   T A is the set of adjacencies is the set of telomeres of G       that do of G T is the set of telomeres of G )=(s       not appear in G. Then we can calculate a vector VG(G T ) ,s ,d       T A to represent the genome G based on G, where s T are the A and d T , d         A and D T , respectively.
(VG may be viewed A, S T , D cardinalities of the sets S   .)
Obviously, we have as producing a ﬁngerprint of G 2n= 2s +s +2d   A  (3) Let Gk be the genome obtained from G= G0 by applying k randomly selected DCJ operations under our model, the (i+1)th DCJ operation is selected from a uniform distribution of all possible DCJ operations on the current genome Gi.
We can compute the vector VG(Gk)= (sk that, given G, we can also produce the estimate(cid:3)E(VG(Gk))= ( T ) to represent the genome Gk with respect to G. In the next section, we will show dk T ) for the expected vector E(VG(Gk))= (sk T ), for any integer k  0. sk A to approximate the expected number of adjacencies present in We use both G and Gk.
Our approach for estimating the true evolutionary distance is then to return the integer k that minimizes the difference  sk  ,(cid:3) (cid:3)  (cid:3)  ,(cid:4)  ,(cid:3)  +d  (cid:3)  ,dk A  ,dk A  ,sk T  ,sk T  ,dk  ,dk  dk A  sk A  sk T   .
A    T    T  A  A  sk A  A     3.2 Estimation of the expected vector after some  number of random DCJ operations  We show how to estimate the expected vector E(VG(Gk))= (sk ,dk T ) under our DCJ model for any integer k  0.
Let G and Gk be as deﬁned above  the vector for G0 = G is clearly just VG(G0)= (n1,n2,0,0).
We ﬁrst show how to compute E(VG(G1)).
,dk A  ,sk T  A  1  A  s1 A  ,d1  T ), where  Theorem 2.
Let m be the number of possible DCJ operations applicable to G. We have E(VG(G1))= (s1 ,s1 ,d1 T A +2n1n2 n1 = n1  2n2 = n2  2n1n2+n2  n2  2n1+2n1n2+ 1 = 2n2 2 n2 2 = 2n1n2+2n1    1  2 n2  d1 A  s1 T  m  m  m  2  1  Proof.
Write VG(G0)= (s0 operations.
A  m ,s0 T  ,0,0) and consider the four cases for DCJ  (cid:2) 2.
Neither of the resulting adjacencies will be in G,  A, the number of possible DCJ  1.
When we select two adjacencies out of S0  operations is so that every such operation reduces s0  A by 2 and increase d0  A by 2.  d1 T  (cid:1)  s0 A 2  2.
When we select one adjacency out of S0  A and one telomere out of  2.
Neither of S0 T , the number of possible DCJ operations is s0 A the resulting adjacency nor telomere will be in G, so that every such operation reduces both s0 A and d0 T by 1.
T by 1 and increases both d0  A and s0   s0  T  3.
When we select two telomeres out of S0  T , the number of possible DCJ .
The resulting adjacency will not be in G, so that  operations is every such operation will reduce s0  T by 2 and increase d0  A by 1.
4.
When we select one adjacency out of S0  A, the number of possible DCJ A.
Neither of the resulting telomeres will be in G, so that  operations is s0 every such operation reduces s0  A by 1 and increases d0  T by 2.
(cid:2)  (cid:1)  s0 T 2  Adding up the four cases and normalizing by the total m, we get   ( 1)   ( 1)+ s0 A m (cid:2)   ( 2) (cid:2) (cid:1)   1   2   s0 T m + 1 2 s0 T  s0  1+ T 2 m 2  1 2 s0 T  (cid:1)  (cid:2)  = s0  A  s1 A  = s0  A  = s0  T  s1 T  A  A  + 2  s0 A 2 m   2s0  s0 T m   2s0 As0 T   ( 2)+ 2s0 As0 T m  s0 2+2s0 (cid:1) As0 T m  2  ( 1)+ 2 s0  + s0  A  T  T  s0 T 2 m  T  A  (cid:1)  = s0  = 0+  (cid:2) 2  +s0 m s0  2+ s0 A 2 m 2 2s0 +2s0 As0 T m  s0  2 = 0+ s0  1+ s0 A T m m +2s0 = 2s0 As0 T m  = 2s0  A  A  A  A  d1 A  d1 T   2  (cid:1)  by applying one more randomly selected DCJ operation.
We show how to  Let Gk be a genome obtained from G by applying k randomly selected DCJ operations and let  Gk+1 be the genome obtained from the genome Gk calculate the expected value of VG(  Gk+1) given Gk and G. Theorem 3.
Let VG(Gk)= (sk ,dk ,dk T ) and let mk be the number of possible DCJ operations on Gk.
For conciseness, write Ak = sk A A (the number of adjacencies in Gk) and T k = sk + dk T (the number of telomeres in Gk).
Then we can write  + dk  ,sk T  A  A  T  mk = (Ak)2+2(Ak)(T k)+ 1 2 , dk+1  , dk+1  , sk+1  E(VG(  Gk+1)) = ( sk+1  A  T  A  T  )  (T k)2  1 2  (T k)  A  where we have  sk+1  sk+1  dk+1  dk+1  A  T  T  A  = sk = sk  T  A  = dk (cid:5) = dk  T   2  (cid:6)  A(Ak+T k)] [n1 2sk (cid:5) [n2(T k+1) 2sk T (Ak+T k)] [2sk A(Ak+T k)+ T k 2 T (Ak+T k) n2(T k+1) [2sk  + 1 mk + 1 mk + 1 mk + 1 mk +2(Ak)]  (cid:6)  T k 2   (Ak) n1]  Proof.
From Theorem 1, we have  mk = (Ak)2+2(Ak)(T k)+ 1 2  (T k)2  1 2  (T k)  (4)  (5)  (6)  i116  [16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i116  i114 i122   There are n1 sk fall into one the following three cases:  A adjacencies in G that do not appear in Gk and they must  1. nAA pairs with members in two different adjacencies in Dk A.
2. nTT pairs with members in two telomeres of Dk T .
3. nAT pairs with one member in Dk There also are n2 sk be members of Dk A.
A and the other in Dk T .
T telomeres in G that do not appear in Gk and so must  Now we complete the proof by running through the possible cases.
From the proof for Theorem 2, we have already covered four cases where adjacencies and telomeres were selected only from Sk T .
The remaining eight cases cover selections from Dk T as well.
In the last ﬁve of these eight cases, the outcome of a particular operation in terms of adjacency and telomere counts is not ﬁxed, but the total count over all possible operations can still be computed  we use the expression  recover  (an adjacency or a telomere) to indicate a case in which the count increases.
A and Dk  A and Sk  A and another out of Dk 1.
When we select one adjacency out of Sk  dk number of possible DCJ operations is sk A adjacency will be in G, so that every such operation reduces sk and increases dk  A, the  2.
Neither resulting A by 1  A  A by 1.
T   dk  A and one telomere out of Dk 2.
When we select one adjacency out of Sk T , the  2.
Neither the resulting  dk number of possible DCJ operations is sk A adjacency nor telomere will be in G, so that every such operation reduces sk  A by 1.
3.
When we select one telomere out of Sk  A by 1 and increases dk  T and dk  T and one telomere out of Dk T , the number of possible DCJ operations is sk T .
Neither the resulting T adjacency nor telomere will be in G, so that every such operation reduces sk  T by 1 and increases dk 4.
When we select one telomere out of Sk  A by 1.
T and one adjacency out of Dk A,  2.
The resulting the number of possible DCJ operations is sk T adjacency will not be in G, while the resulting telomere can be in G or not.
There are sk T ) ways to recover one telomere out of n2 sk T  (cid:2) 2.
The two resulting adjacencies can be in G or not.
5.
When we select two adjacencies out of DA, the number of possible DCJ  T telomeres in G that do not appear in Gk.
operations is There are nAA ways to recover one adjacency out of n1 sk in G that do not appear in Gk.
(n2 sk  A adjacencies   dk  (cid:1)  dA 2  A  6.
When we select one adjacency out of Dk  A and one telomere out of Dk T ,  2.
The resulting the number of possible DCJ operations is dk  (n2 sk A adjacency and telomere can be in G or not.
There are dk T ) ways to recover one telomere out of n2 sk T T telomeres in G that do not appear in Gk and nAT ways to recover one adjacency out of n1 sk A adjacencies in G that do not appear in Gk.
dk  T  7.
When we select one adjacency out of Dk  operations is dk there are n2 sk (cid:1) in G that do not appear in Gk.
A, the number of possible DCJ A.
The two resulting telomeres can be in G or not and T ways to recover one telomere out of n2 sk T telomeres (cid:2)  T , the number of possible DCJ .
The resulting adjacency can be in G or not and there A adjacencies in G  operations is are nTT ways to recover one adjacency out of n1 sk that do not appear in Gk.
8.
When we select two telomeres out of Dk  dT 2  A  A  = sk = sk  Adding up the 12 cases and normalizing by the total mk, we get  sk+1  sk+1  dk+1  A(Ak+T k)] [n1 2sk (cid:5) [n2(T k+1) 2sk T (Ak+T k)] A(Ak+T k)+ [2sk T k 2  + 1 mk + 1 mk + 1 mk   (Ak) n1]  = dk  (cid:6)  A  A  T  T  Evolutionary distances under DCJ model   dk+1  T  = dk  T  (cid:5)  + 1 mk T k 2   2  (cid:6) [2sk  T (Ak+T k) n2(T k+1) +2(Ak)]  (cid:1)  Given G0, we estimate E(VG(Gk)) for k  0 by iterating k times the matching formula in Theorem 3, and every time we identify E(VG(Gk 1)) with the actual vector VG(Gk 1).
,(cid:3) Corollary 1.
Let G be one genome on n genes, the estimated vector T ) for all integers i (0  i  k) can be computed in di  (cid:3)E(VG(Gi))= (  ,(cid:3)  ,(cid:3)  (cid:3)  di A  si A  si T  O(k) time.
lim k +   lim k +   sk A  (cid:3) (cid:3) (cid:3) (cid:3)  sk T  sk T  sk A  dk A  (cid:3)  ,(cid:3)  ,(cid:3)  3.3 Asymptotic behavior of our estimation We can use our results to derive the  stable  structure of a genome under the ,(cid:3) random DCJ model the structure reached after sufﬁciently many events.
(cid:3)E(VG(Gk))= ( Corollary 2.
Let G have n (n 2) genes  then the estimated vector operation(cid:3)mk for genome Gk satisfy +(cid:4) (cid:3) dk T ) and the estimated number of possible DCJ T )=  k + (cid:3)mk = n2+n 2n  ε0 2n    The fairly technical proof is attached in Appendix  the approach is to deﬁne s0 2n, and to consider separately T the cases where ε0 is positive and negative, showing in each case that εk keeps the sign of ε0 and that the limit of εk as k grows is zero.
+(cid:3) Corollary 3.
If the estimated vector is(cid:3)E(VG(Gk))= (  2n+ε0, with       2n 2  2n  n 2  ,(cid:3)  ,(cid:3)  ,(cid:3)  lim k + (  =   (cid:3)  (cid:3)     lim     d0 T  (7)  (8)  sk T  2n  dk  dk T ) and  dk A  sk A  sk T  if we have n 2, then we can write =  2n+  n1   2n 2n+1) = n2( 2n+    2n   2n+  2n 2   2n 2n+1) 2n+  2n (cid:3)  2n  n2(  n1  A  n1  si T  si A  sk A  (9)  dk T  dk A  =  lim k +   lim k +   lim k +   + 1 mi  = n  =  Proof.
We ﬁrst calculate limk + (cid:3) sk and formula (3), we have(cid:7) A.
From formula (4) in Theorem 3 [n1 (cid:3) +(cid:3) =(cid:3) T ))] A(2n+( si+1 di si (cid:3) A(= n1) 2n, we get Combining formulae (7), (8) and (9), together with 0  s0 2n+  (cid:3) (cid:3) (cid:3)  Similarly, we can calculate the limits for Corollary 4.
If we have n1 1, then our estimated value monotonically with k until (cid:3) Proof.
From the assumption n1 1, we have = s0 (cid:7) (cid:3)  (cid:3) A sk is enough to show that, for any integer k, if we have (cid:7)  (cid:3) +(cid:3) +(cid:3) +(cid:3) (cid:3) (cid:3) A sk+1 sk sk A.
If we have A [n1 2 T )] sk+1 (cid:3) +(cid:3) +(cid:3) +(cid:3) dk T )] [n1 ( +(cid:3) (n2+(cid:3) dk dk A T ) 0 dk  = n1 1.
Now it 2 , then we get 2 , then, from formula (4) in Theorem 3, we have, sk sk A( A  = 1 mk 1 mk    1 2mk  2n dk A and  sk A decreases    1 2 .
(cid:3)  (cid:3)  (cid:3)  dk T .
sk T ,    1    1  dk A  (cid:1)  s0 A  sk A  sk A  sk A  sk T  sk T  sk T     A  A  (cid:1)  i117  [16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i117  i114 i122   Y.Lin and B.M.E.Moret  (cid:3)  These three corollaries paint a picture of the long-term consequences on genomic structure of random DCJ events  in particular, they predict that the   number of linear chromosomes (half of the number of telomeres) converges to 2n/2 and also, intuitively enough, that the number of shared adjacencies, sk A, goes down to (effectively) zero.
The prediction of the asymptotic number of linear chromosomes illustrates the limitations of the method: for humans, for instance, using a ﬁgure of 25000 genes, we get an asymptotic number of 112 chromosomes and it is to be doubted whether, even with a billion more years of evolution, the human genome would ever feature these many chromosomes.
Another example is that of bacteria, which usually have a single circular chromosome, not the 22 50 linear chromosomes that would go with 1000 5000 genes.
Clearly, the uniform model is too simple and constraints exist in organismal genomes that strongly dampen chromosomal ﬁssion.
At present, however, there are too many ways in which to impose such constraints within the DCJ model and not enough data to decide which way is best.
4 EXPERIMENTS We now present experimental results on the accuracy of our estimation of the expected vector after a given number of random DCJ operations and on the quality of our estimator for the true evolutionary distance (in terms of the actual number of DCJ operations).
Our experiments all start with an original genome, G, with some chosen number of linear and circular chromosomes of various sizes  this genome is subjected to a prescribed number k of DCJ operations chosen uniformly at random to obtain a ﬁnal genome Gk.
We vary k from one to six times the number of genes very large values in evolutionary terms.
For each choice of parameters, we generate 10 000 runs to obtain a tight estimate of variance.
We compute the vector representations for all intermediate genomes and then use our method to estimate the evolutionary distance.
We ran tests on a large variety of initial genomes, some designed to resemble actual organismal genomes, some entirely unrealistic to test extreme cases.
Due to space limitations, we present results on just three initial genomes, all meant to resemble real organismal genomes: (a) 25 000 genes and 25 linear chromosomes  (b) 10 000 genes and 5 linear chromosomes and (c) 1000 genes and 1 circular chromosome the ﬁrst two examples match metazoan genomes, the last matches a small bacterial genome.
Gene Number = 25000, Linear Chromosome Number = 25  25000  20000  15000  10000  5000  0  0  sA sT dA dT  50000  100000  150000  DCJ operations  4.1 Accuracy of the expected vector after k-random  We study the behavior of our estimation(cid:3)E(VG(Gk)) by comparing of our experiments, we ﬁnd that(cid:3)E(VG(Gk)) is extremely close to  its prediction to the sample mean for E(VG(Gk)), as computed from our 10 000 trials.
We include an additional, extreme, genome with 5000 genes and 2500 linear chromosomes to show that our technique works across a very broad range of parameters.
In all  the sample mean for E(VG(Gk)): the maximum absolute error of corresponding values between our estimation and the sample mean is always  0.8.
Figure 2 shows the four values in the vector as a function of the actual number of DCJ operations for genome (a) (the curves for genomes (a), (b) and (c) are similar) and for the  extreme  genome (where the curves are better differentiated).
The  ﬁgure does not distinguish our estimation(cid:3)E(VG(Gk)) and the sample for sA, sT , dA, and dT between our estimation(cid:3)E(VG(Gk)) and each  mean for E(VG(Gk)), because the difference is too small with respect to the actual value.
We also compute the mean absolute difference  experimental vector VG(Gk) in every single run for genomes (a), (b) and (c) and show the results in Figure 3.
The sum of absolute difference of entries in the vector on the larger genomes never exceeds 0.5% (as a percentage of the sum of entries in the vector) and is typically well below 0.25%  even on the smaller genome, the difference does not exceed 2% and is typically below 1%.
4.2 Accuracy of the estimation of the actual number  of DCJ operations  We want to study the threshold of saturation of our estimator in addition to its accuracy  in order to do that, we create simulations with controlled numbers of DCJ operations and set up a threshold for correction in the estimation procedure.
Speciﬁcally, we choose a number between 1 and some upper bound B as the actual number of DCJ operations  B is chosen to be the smallest integer k that sk makes the expected value A  2, a point at which there are almost no shared adjacencies left (from Corollary 4).
For genomes (a), (b) and (c), the corresponding upper bounds are 121 621, 44 047 and 3253,  respectively.
From Corollaries 3 and 4, and the fact n1  n, we have 2 .
Thus we use the smallest integer r that causes  0 limk + (cid:3)  (cid:3)    1  sk A  5000  4000  3000  2000  1000  0  0  Gene Number = 5000, Linear Chromosome Number = 2500  sA sT dA dT  10000  20000  30000  Fig.
2.
The four vector values as a function of the actual number of DCJ operations.
i118  [16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i118  i114 i122   Gene Number = 25000, Linear Chromosome Number = 25  50000  100000  150000  Gene Number = 1000, Linear Chromosome Number = 0  50  45  40  35  30  25  20  15  10  5  0  0  50  45  40  35  30  25  20  15  10  5  0  0  10  8  6  4  2  Evolutionary distances under DCJ model  Gene Number = 10000, Linear Chromosome Number = 5  10000  20000  30000  40000  50000  60000  sA sT dA dT     0  0  6000  5000  4000  3000  2000  1000  actual number of DCJ operations.
Fig.
3.
The mean absolute difference for sA, sT , dA and dT between our estimation(cid:3)E(VG(Gk)) and each experimental vector VG(Gk) as a function of the the expected value(cid:3)sr  (cid:3)  A to become smaller than 1/2 as an upper limit on the maximum number of DCJ operations in the evolutionary history.
= 0, we set k (the value normally chosen to Finally, if we have sF A  ) to this upper limit r. For genomes (a), (b) and minimize  sF (c), r has values 211 442, 81 329 and 6398, respectively.
our approach postpones the threshold of saturation (viewed as a number of DCJ operations) from well under the number of genes to at least three times the number of genes for all three example genomes.
This large gain in accuracy should translate into much better phylogenetic reconstructions as well as more accurate genomic alignments.
sk A  A  Figure 4 shows the mean and SD for the actual number of DCJ operations estimated by the edit DCJ distance and by our approach.
These ﬁgures indicate that, as expected, the edit DCJ distance underestimates, often severely, the actual number of events.
In contrast, our approach provides highly accurate estimates, with very small variance.
We also study the mean absolute difference between the actual number of DCJ operations and our estimator for genomes (a), (b) and (c).
The results are shown in Table 1.
The estimates are highly accurate (even for small genomes) up to surprisingly large numbers of events.
Rearrangements events fall under the category of  rare genomic events  [in the terminology of Rokas and Holland (2000)], yet our estimator works well even for what would be considered common events.
5 DISCUSSION AND CONCLUSIONS From Sections 4.1 and 4.2, our estimation achieves very high accuracy, especially for larger (metazoan) genomes.
From Figure 4,     Moreover, Corollaries 2 and 3 make speciﬁc predictions about the structure of evolved genomes on n genes after many steps:   namely, that all should have approximately 2n telomeres, that is 2n/2 linear chromosomes, and that shared adjacencies with other highly evolved genomes should be nearly absent.
While the second prediction is intuitively reasonable, it is in fact rarely satisﬁed in actual organisms, especially for small genomes (such as prokaryotic genomes), where conservation pressures are very high and speciﬁc structures such as operons survive across broad ranges of evolutionary divergence.
The ﬁrst prediction is, as noted earlier, nearly always overstated: clearly, biological constraints prevent chromosomal ﬁssion to be as commonplace as the uniform DCJ mechanism would appear to suggest.
These predictions rely on the two main assumptions made in this work: no gene duplication or loss  and uniform distribution of DCJ operations.
Both are clearly unrealistic, so our ability to gauge their effect on model predictions is crucial to future model reﬁnements.
For instance, in their original paper, Yancopoulos et al.
(2005) required that a chromosomal ﬁssion that creates a new small  i119  [16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i119  i114 i122   Y.Lin and B.M.E.Moret  125000  100000  75000  50000  25000  0  0  3500  3000  2500  2000  1500  1000  500  0  0  Gene Number = 25000, Linear Chromosome Number = 25  25000  50000  75000  100000  125000  Gene Number = 1000, Linear Chromosome Number = 0  500  1000  1500  2000  2500  3000  3500  45000  40000  35000  30000  25000  20000  15000  10000  5000  0  0  Gene Number = 10000, Linear Chromosome Number = 5  5000 10000 15000 20000 25000 30000 35000 40000 45000  for edit DCJ distance  for our estimation  standard deviation  Fig.
4.
Mean and SD plots for the actual number of DCJ operations (y-axis) versus the edit DCJ distance and our estimator (x-axis).
The datasets are divided into 60 bins according to their x-coordinate values.
Table 1.
The mean absolute difference between actual number of DCJ operations and our estimation  No.
of genes  Actual number of DCJ operations No.
of genes  1  No.
of genes  2  No.
of genes  3  25 000 10 000 1000  131.0 (0.5%) 83.9 (0.8%) 27.2 (2.7%)  447.5 (0.9%) 282.0 (1.4%) 93.6 (4.7%)  1280.2 (1.7%) 819.4 (2.7%) 441.8 (14.7%)  circular chromosome be immediately followed by a chromosomal fusion that re-absorbs this small circular chromosome, thereby causing a block exchange within the original chromosome and treating the extra circular chromosome as a transient artifact.
Since circular chromosomes do not arise in organisms with a number of linear chromosomes, a similar constraint would strongly reduce the incidence of ﬁssion.
A similar type of constraint could be used for prokaryotic genomes, which normally consist of a single circular chromosome.
Using just such a constraint, Kothari and Moret (2007) found that the DCJ edit distance closely reﬂected both inversion and transposition operations.
Evidence that paracentric rearrangements are more common than pericentric ones, at least in two Drosophila species (York et al., 2007), and that short inversions  are more common than long ones, in some prokaryotes and in the aforementioned Drosophila (Lefebvre et al., 2003  York et al., 2007), can also be reﬂected into additional constraints on the DCJ model.
Any additional constraint naturally creates complications, but we expect that at least a few natural constraints can be handled within the framework described here.
Some signiﬁcant advances have been made by our group for handling duplications and losses in an inversion context (see, e.g.
Marron et al., 2004  Swenson et al., 2005  Tang et al., 2004)  since duplications and losses are handled in that work mostly through the greedy approach of using rearrangements to place together genes that can then be gained or lost in a single operation, moving this work to a DCJ context appears uncomplicated.
This combination could then yield the ﬁrst reliable estimate of genomic pairwise distances for complex metazoan genomes based on rearrangements and duplication/loss mechanisms.
Finally, since the DCJ operation regroups all rearrangements studied to date, and since our results point to one way in which the behavior of this model can be studied for various constraints (such as where the cuts can be made), our results may shed light on the vexing issue of what constitutes a signiﬁcant syntenic block in comparative genomics an issue that has seen a lot of discussion over the last few years.
[Sinha and Meller (2008) give a review of these discussions and some proposals, while  i120  [16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i120  i114 i122   Chaisson et al.
(2006) give evidence that rearrangements occur at multiple scales.]
Conﬂict of Interest: none declared.
Yancopoulos,S.
et al.
(2005) Efﬁcient sorting of genomic permutations by translocation,  inversion and block interchange.
Bioinformatics, 21, 3340 3346.
York,T.
et al.
(2007) Dependence of paracentric inversion rate on tract length.
BMC  Bioinformatics, 8, (online publication).
Evolutionary distances under DCJ model  REFERENCES Bader,D.
et al.
(2001) A fast linear-time algorithm for inversion distance with an  experimental comparison.
J. Comput.
Biol., 8, 483 491.
Bergeron,A.
et al.
(2006) A unifying view of genome rearrangements.
In Proceedings of the 6th International Workshop on Algorithms in Bioinformatics (WABI 06).
Vol.
4175 in Lecture Notes in Computer Science, Springer Verlag, pp.
163 173.
Chaisson,M.
et al.
(2006) Microinversions in mammalian evolution.
Proc.
Natl Acad.
Sci, USA, 103, 19824 19829.
Durrett,R.
et al.
(2004) Bayesian estimation of the genomic distance.
Genetics, 166,  621 629.
Hannenhalli,S.
and Pevzner,P.
(1995a) Transforming cabbage into turnip (polynomial algorithm for sorting signed permutations by reversals).
In Proceedings of the 27th Annual ACM Symposium on the Theory of Computing (STOC 95).
ACM Press, pp.
178 189.
Hannenhalli,S.
and Pevzner,P.
(1995b) Transforming mice into men (polynomial algorithm for genomic distance problems).
In Proceedings of the 36th Annual IEEE Symposium on Foundations of Computer Science (FOCS 95).
IEEE Press, pp.
581 592.
Kothari,M.
and Moret,B.
(2007) An experimental evaluation of inversion- and transposition-based genomic distances.
In Proceedings of the 3rd IEEE Symposium on Computational Intelligence in Bioinformatics and Computational Biology (CIBCB 07), IEEE Press, pp.
151 158.
Lefebvre,J.-F. et al.
(2003) Detection and validation of single gene inversions.
In the 11th International Conference on Intelligent Systems for  Proceedings of Molecular Biology (ISMB 03).
Bioinformatics, 19, i190 i196.
Marron,M.
et al.
(2004) Genomic distances under deletions and insertions.
Theor.
Comput.
Sci., 325, 347 360.
Moret,B.
et al.
(2001) New approaches for reconstructing phylogenies from gene-order data.
In Proceedings of the 9th International Conference on Intelligent Systems for Molecular Biology (ISMB 01).
Bioinformatics, 17, S165 S173.
Moret,B.
et al.
(2002) Steps toward accurate reconstructions of phylogenies from gene-  order data.
J. Comput.
Syst.
Sci., 65, 508 525.
Moret,B.
et al.
(2005) Reconstructing phylogenies from gene-content and gene- order data.
In Gascuel,O.
(ed.
), Mathematics of Evolution and Phylogeny.
Oxford University Press, Oxford, pp.
321 352.
Rokas,A.
and Holland,P.
(2000) Rare genomic changes as a tool for phylogenetics.
Trends Ecol.
Evol., 15, 454 459.
Sankoff,D.
and Blanchette,M.
(1998) Multiple genome rearrangement and breakpoint  phylogeny.
J. Comput.
Biol., 5, 555 570.
Sankoff,D.
and Blanchette,M.
(1999) Probability models for genome rearrangement and linear invariants for phylogenetic inference.
In Proceedings of the 3rd Annual International Conference on Computational Molecular Biology (RECOMB 99).
ACM Press, pp.
302 309.
Sinha,A.
and Meller,J.
(2008) Sensitivity analysis for reversal distance and breakpoint reuse in genome rearrangements.
In Proceedings of the 13th Paciﬁc Symposium on Biocomputing (PSB 08).
World Scientiﬁc, pp.
37 48.
Swenson,K.
et al.
(2005) Approximating the true evolutionary distance between two genomes.
In Proceedings of the 7th SIAM Workshop on Algorithm Engineering & Experiments (ALENEX 05).
SIAM Press, pp.
121 129.
Swenson,K.
et al.
(2008) Phylogenetic reconstruction from complete gene orders of whole genomes.
In Proceedings of the 6th Asia Paciﬁc Bioinformatics Conference (APBC 08).
Vol.
6 in Advances in Bioinformatics and Computational Biology.
Imperial Press, pp.
241 250.
Swofford,D.
et al.
(1996) Phylogenetic inference.
In Hillis,D.
et al.
(eds), Molecular  Systematics, Sinauer Assoc., Sunderland, MA, pp.
407 514.
Tang,J.
et al.
(2004) Phylogenetic reconstruction from arbitrary gene-order data.
In Proceedings of the 4th IEEE Symposium on Bioinformatics and Bioengineering (BIBE 04).
IEEE Press, pp.
592 599.
Wang,L.-S. (2001).
Exact-IEBP: a new technique for estimating evolutionary distances between whole genomes.
In Proceedings of the 33rd Annual ACM Symposium on Theory of Computing (STOC 01).
ACM Press, pp.
637 646.
Wang,L.-S. and Warnow,T.
(2001) Estimating true evolutionary distances between genomes.
In Proceedings of the 1st International Workshops on Algorithms in Bioinformatics (WABI 01).
Vol.
2149 in Lecture Notes in Computer Science, Springer Verlag, pp.
176 190.
APPENDIX  (cid:3)  (cid:4)  T  2n  s0 T  s0 T  lim  d k  d0 T  d0 T  s k T  2n):  with  = s0  +d0  T , and  = d0 T ,  2n  ε0 0 and (ii) 0  ε0   2n.
In each case, we prove by induction on k the following  Proof of Corollary 2: Proof.
We have 0  s0 T (= n2) 2n, (cid:3) +(cid:4) =  and so can write 2n+ε0    2n  ε0 2n   We now consider two cases: (i)    +(cid:4) (cid:4) 2n   T )   result for εk(= ( k + εk = 0 2n  εi(=(cid:3) +(cid:4) We have    2n  ε0 0 and, by inductive hypothesis,       +(cid:7) range for εi+1 (=(cid:7) 2n) 0.
We now bound the si    T di+1 si+1 (cid:7) +(cid:7) +(cid:4) +(cid:7) (cid:3) di+1 si+1 T )2] T )+ 1 )= ( [2n ( (cid:7) +(cid:7) +(cid:4) (cid:3) di di mi T ) by (εi+1+  si+1 di+1 di si T 2n), we get   (εi+2 εi+1 = εi(1  1 2n)) mi      From formulae (5) and (6) in Theorem 3 as well as formula (3),  From formula (2), we have  (εi +    Replacing (  ) and (  2n) and  we have  (cid:3)  Case  (A1)  (A2)  2n).
di T  si T  si T  (i)  T  T  T  T  T  T  (  (  (A3) From Formula (A3) and our inductive hypothesis, and using n 2, we get  )(  2n+εi)2+(n  1 2  2n+εi)+n2  mi =  1 4    2n 2n2 n Then from formulae (A2) and (A4), we can write    2n) 1  (cid:9)  0 1  1 (cid:8) mi  (A4)  (εi+2   2n 2n2 n  1   εi    εi+1 0  and from the inductive assumption and by using n 2, we can verify that εi+1 satisﬁes Since we have     2n  ε0 0, then, by induction, we have, for any (cid:8)  2n  εi+1 0      integer k,  (cid:9)k   εk  0    2n 2n2 n  1   ε0 and thus, with n 2,  k + εk = 0  lim  i121  [16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i121  i114 i122   Y.Lin and B.M.E.Moret  We have 0  ε0 2n       hypothesis, 0  εi 2n   +(cid:7) (=(cid:7) Case (ii) 2n and, by inductive 2n.
We now bound the range for εi+1 si+1 di+1 From formula (A3) and the inductive hypothesis, and using n 2, we can write  2n).
T  T  0 1  1 mi  (εi+2      2n) 1  2 2n 2n2 n (cid:9)  (cid:8)  Now using formulae (A2) and (A5), we get   2n 2n2 n  0  εi+1  εi  1  2  and from the inductive hypothesis and using n 2, we can verify that εi+1 satisﬁes  0  εi+1 2n    2n  Since we have 0  ε0 2n    any integer k,  2n, then, by induction, we have, for  and thus, with n 2,  (A5)  Putting it all together, we have  (cid:9)k  (cid:8)    2n 2n2 n  1  2  0  εk   ε0  lim  k + εk = 0 (cid:3) +(cid:4) T )=   si T  di  2n  k + ( lim  Moreover, from formulae (A1) and (A3), we can write  k + (cid:3)mk = n2+n  lim    2n  n 2       2n 2  (cid:1)  i122  [16:06 25/6/03 Bioinformatics-btn148.tex]  Page: i122  i114 i122
