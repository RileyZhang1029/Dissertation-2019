Copyedited by: zaza  MANUSCRIPT CATEGORY:  BIOINFORMATICS  Vol.
28 ISMB 2012, pages i265 i273 doi:10.1093/bioinformatics/bts207  Fast alignment of fragmentation trees Franziska Hufsky1,2, Kai Dührkop1, Florian Rasche1, Markus Chimani3 and Sebastian Böcker1,  1Chair for Bioinformatics, Friedrich-Schiller-University, 2Max Planck Institute for Chemical Ecology, Beutenberg Campus and 3Algorithm Engineering, Friedrich-Schiller-University, Jena, Germany   unknown  small molecules not  ABSTRACT Motivation: Mass spectrometry allows sensitive, automated and high-throughput analysis of small molecules such as metabolites.
One major bottleneck in metabolomics is the identiﬁcation in any database.
Recently, of fragmentation tree alignments have been introduced for the automated comparison of the fragmentation patterns of small molecules.
Fragmentation pattern similarities are strongly correlated with the chemical similarity of the molecules, and allow us to cluster compounds based solely on their fragmentation patterns.
Results: Aligning fragmentation trees is computationally hard.
Nevertheless, we present three exact algorithms for the problem: a dynamic programming (DP) algorithm, a sparse variant of the DP, and an Integer Linear Program (ILP).
Evaluation of our methods on three different datasets showed that thousands of alignments can be computed in a matter of minutes using DP, even for  challenging  instances.
Running times of the sparse DP were an order of magnitude better than for the classical DP.
The ILP was clearly outperformed by both DP approaches.
We also found that for both DP algorithms, computing the 1% slowest alignments required as much time as computing the 99% fastest.
Contact: sebastian.boecker@uni-jena.de  1 INTRODUCTION Metabolomics deals with the identiﬁcation and quantiﬁcation of small compounds below 1000 Da, and has received increasing interest during the last years (Last et al., 2007).
All organisms, especially plants, fungi and bacteria, synthesize many different metabolites and a large portion of them is still unknown (Fernie et al., 2004).
The genome sequence usually does not reveal information about metabolite structure, as it does for protein structure.
Newly identiﬁed metabolites often serve as leads in drug design (Li and Vederas, 2009  Schmidt et al., 2007), in particular for antibiotics.
For a high-throughput analysis of metabolites and other small molecules, mass spectrometry (MS) is the predominant technology (Cui et al., 2008  Fernie et al., 2004  Last et al., 2007).
Nuclear magnetic resonance reveals more information about the analyte, but is inapplicable for high-throughput analysis due to its low sensitivity.
MS can be coupled with a separation method (gas chromatography, liquid chromatography or capillary electrophoresis) to analyze complex mixtures like cell extracts (Fiehn, 2008  Halket et al., 2005).
To obtain information beyond the compound mass, the analyte is usually fragmented, and fragment masses are recorded.
Typically, collision-induced dissociation is combined with liquid chromatography MS, whereas gas chromatography MS uses electron impact fragmentation.
The ﬁrst attempt to develop computational methods for analyzing fragmentation spectra of     To whom correspondence should be addressed.
metabolites has been the DENDRAL project in 1965 (Lederberg, 1965).
But the project was stopped after it became clear that automated structure elucidation using MS data could not be achieved at that time.
Today, data analysis is still the major bottleneck in metabolomics (Neumann and Böcker, 2010).
Manual data analysis requires time and deep knowledge of the underlying chemistry (Werner et al., 2008).
Due to the limited reproducibility of the data, even library searches are difﬁcult (Oberacher et al., 2009).
Additionally, spectral libraries are vastly incomplete.
Methods for de novo sequencing of non-ribosomal peptides have recently been developed.
But these methods rely on the fact that the analytes are structurally restricted polymers with predictable fragmentation.
When manually analyzing tandem MS spectra, chemists try to annotate fragmentation peaks and identify relations between fragments, resulting in fragmentation pathways.
This approach has been automated by Böcker and Rasche (2008).
They calculate hypothetical fragmentation trees solely based on the MS data.
Fragmentation tree nodes are annotated with the molecular formula of the fragments, whereas edges represent losses.
To ﬁnd a fragmentation tree that shows maximum agreement with the measured data, we search for a tree of maximum edge weight, comparable to prize-collecting Steiner trees (Ljubi c et al., 2005).
Only lists of common and implausible losses are required as expert knowledge about fragmentation mechanisms.
In Rasche et al.
(2011), experts evaluated the calculated fragmentation trees and conﬁrmed their excellent quality.
Recently, methods to calculate fragmentation trees from multiple MS and gas chromatography  MS data have been developed (Hufsky et al., 2012, manuscript  Scheubert et al.
2011).
MS analysis of similar compounds results in similar fragmentation trees.
Rasche et al.
(2012) proposed local tree alignments for the automated comparison of fragmentation trees and showed that this method is superior to spectral comparison.
Fragmentation tree alignments even allow for inter-dataset comparisons for datasets measured on different instruments (Rasche et al., 2012).
A tree alignment may contain matches, mismatches, insertions and deletions, but respects the structure of the two trees.
Fragmentation tree similarity is deﬁned via edges (representing losses) and nodes (representing fragments).
A local tree alignment contains those parts of the two trees where similar fragmentation cascades occurred.
Tree alignments were introduced by Jiang et al.
(1995) and can be applied for RNA secondary structure comparison (Le et al., 1989).
RNA structure trees are ordered, that is, the children of any node have a ﬁxed order.
In contrast, fragmentation trees are unordered, as there cannot exist any sensible ordering for the sub fragments of some fragment.
In this respect, fragmentation trees are more similar to phylogenetic trees than to RNA structure trees.
Whereas efﬁcient, polynomial-time algorithms exist for the alignment of ordered trees, the alignment of unordered trees is computationally hard, namely MAX SNP-hard (Jiang et al., 1995).
This implies that there exists no    The Author(s) 2012.
Published by Oxford University Press.
This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/3.0), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.
[16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i265 i265 i273   Copyedited by: zaza  MANUSCRIPT CATEGORY:  F.Hufsky et al.
Fig.
1.
Optimal fragmentation tree alignment for cystine (11 losses) and methionine (6 losses) from the Orbitrap dataset (a).
(b) Fragmentation mass spectra of cystine and methionine.
The mass spectra do not share peaks.
Molecular structures of cystine (c) and methionine (d).
The molecular structures are not known to the alignment method.
The alignment detects the common fragmentation path of formic acid ammonia ethylene losses and the separate ammonia branch.
Additionally, it ﬁnds the methylthiol loss, which occurs at a later stage in cystine  Polynomial Time Approximation Scheme (PTAS) for the problem unless P=NP (Arora et al., 1998).
In case both trees have ﬁxed maximum out degree, an optimum alignment can be computed via dynamic programming (DP) in polynomial time (Jiang et al., 1995).
In comparison, computing the edit distance between two unordered trees remains MAX SNP hard even for bounded degrees (Zhang and Jiang, 1994).
An informal algorithm for aligning fragmentation trees was presented by Rasche et al.
(2012), and join nodes were introduced to account for missing nodes in one of the trees compared.
Missing nodes result from missing peaks in one of the spectra.
Rasche et al.
(2012) do not give a correctness proof or running time analysis for the algorithm.
As related work, we mention the Tree- Constrained Bipartite Matching problem where either a node or any of its descendants may be part of the matching  this problem is also APX-hard (Canzar et al., 2011).
Our contribution: we modify the tree alignment algorithm from Jiang et al.
(1995) for edge similarities and local alignments, and analyze its running time.
We then show how to integrate join nodes without increasing the worst-case running time.
Next, we modify the algorithm to allow for sparse DP, a technique common in RNA folding (Backofen et al., 2011).
This does not only decrease the practical memory requirements of the method but, more importantly, also severely decreases running times in practice.
Furthermore, we present an Integer Linear Program (ILP) for the fragmentation tree alignment problem, as ILPs often solve NP-hard problems swiftly in practice.
We then evaluate all methods on real-world data, and ﬁnd that the sparse DP approach dominates the classical DP, resulting in an 11-fold speed-up for one dataset.
Somewhat unexpectedly, the ILP is clearly outperformed by both DP approaches.
2 ALIGNING FRAGMENTATION TREES Let T =(V ,E) be a tree  the elements of V are called nodes.
In the following, we assume all trees to be arboreal, that is, all edges  i266  in E are directed away from some root node.
By uv, we denote a directed edge from node u to node v. Let p(v) be the parent node of some node v. A fragmentation tree is a tree T =(V ,E) together with an edge labeling (cid:2): E L. In more detail, nodes V correspond to fragments of a compound, whereas the labels L are (neutral or radical) losses: that is, both are molecular formulas over some ﬁxed alphabet of elements (Böcker and Rasche, 2008).
Formally, molecular formulas are compomers or multi sets.
The children of any node of a fragmentation tree are intrinsically unordered, as there is no sensible way to order the sub fragments of some fragment.
In our presentation, we will not consider the molecular formulas of fragments, and concentrate on comparing losses only.
As we will see below, comparing fragments instead or comparing both simultaneously requires only minor modiﬁcations.
See Figure 1 for two examples of fragmentation trees.
We introduce some notation used throughout this article: Let T1= (V1,E1) and T2=(V2,E2) be the two trees we want to align.
We sometimes call T1 the left tree and T2 the right tree.
Let C(v) denote the children (nodes) of any node v in T1 or T2.
In the following, we usually assume that u is a node of T1, and v a node of T2.
For i=1,2, let ni := Vi  be the number of nodes in Ti, and let di be the maximum out degree in Ti.
These maximum out degrees will be of particular interest to us, as the running time of our DP grows exponentially in d1,d2.
Let δ=min d1,d2  and  =max d1,d2 .
Rasche et al.
(2012) introduce a similarity function σ :L L  R for pairs of losses (molecular formulas).
We do not repeat the details here, but note that this implies a similarity function σ : E1 E2  R between edges of the two trees T1,T2 via σ (e1,e2)= σ ((cid:2)(e1),(cid:2)(e2)).
They also introduce a similarity function for fragment molecular formulas, which induces a similarity function between nodes of the two trees.
Furthermore, they also extend the deﬁnition of tree alignments by introducing a join operator [see Figure 2(b)]: Given a path p1 in T1 (cid:4) 1 be the edges of p1.
We can assign a loss to of length two, let e1,e  [16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i266 i265 i273   Copyedited by: zaza  MANUSCRIPT CATEGORY:  Fast alignment of fragmentation trees  tree T1  if we do the same for the second coordinate, we end up with the tree T2.
(In fact, we have to replace the nodes of the restricted trees by their labels, we omit the simple technical details.)
We say that A is a local alignment if the trees originating from contracting gap edges are induced subtrees of T1 and T2, respectively.
Different from Jiang et al.
(1995), we want to score an alignment based on the edges of the two trees.
To this end, for any node a of A but the root, let e1(a) be the unique edge in T1 that ends in the ﬁrst coordinate of the label of a, and let e2(a) be the unique edge in T2 that ends in the second coordinate of the label of a.
In case no such edge exists, we assume e1(a)=    or e2(a)=   , respectively.
Now, we deﬁne the score of A as(cid:2) non-root node a of A  σ (e1(a),e2(a)).
We deﬁne σ (T1,T2) as the maximum score of a local alignment of T1 and T2.
Scoring node pairs and scoring edge pairs are closely related: We can push an edge score into its end node, or we can pull a node score into its unique incoming edge.
The only difference is that the root node is not considered when scoring edge pairs.
The two scorings  can be combined by introducing a particular root scoring σ : V1  V2  R for the root nodes of the alignment.
In the following, we  omit the simple but somewhat tedious details, and simply note that all algorithms presented here work both with node scoring, edge scoring, as well as a combination thereof.
A local fragmentation tree alignment for two compounds from the Orbitrap dataset (see Section 6) can be found in Figure 1.
3 DYNAMIC PROGRAMMING We now present an algorithm to compute optimum fragmentation tree alignments that has reasonable running time in practice.
Our algorithm is a modiﬁcation of an algorithm by Jiang et al.
(1995) for computing global alignments of unordered trees.
The reason for these algorithms to be swift in practice is that fragmentation trees usually have comparatively small out degree: fragments rarely have more than, say, ﬁve child fragments.
We can limit the inevitable exponential part of the running time to this out degree.
We use DP to compute the maximal score σ (T1,T2) of a local alignment between two trees T1,T2.
Let S(u,v) be the maximal score of a local alignment of two subtrees of T1,T2, where the subtree of T1 is rooted in u, and the subtree of T2 is rooted in v. For A  C(u) and B  C(v), we deﬁne Su,v[A,B] to be the score of an optimal local alignment of subtrees rooted in u and v, respectively, such that maximally the children A of u and B of v are used in the alignment.
Clearly, S(u,v)= Su,v[C(u),C(v)].
Furthermore, we have Su,v[A, ]= Su,v[ ,B]=0 for all A,B.
When all S(u,v) are known, we can compute the maximal score of a local alignment of T1,T2 as  σ (T1,T2)= max u T1,v T2  S(u,v).
(1) We present a recurrence for the computation of Su,v[A,B].
We initialize Su,v[A,B]=0 for A=  or B= .
Recall that T1 is the left tree and T2 is the right tree.
In the recurrence, we distinguish three cases, namely match (including mismatches), deletion left or deletion right, where the latter two are symmetric (Figure 3).
For  Fig.
2.
Two alignments of fragmentation trees based on edge similarities.
Nodes represent molecular formulas of the fragments, edges represent molecular formulas of the losses.
(a) A gap ( ) is introduced for the missing CO loss in the left tree (dashed edge and node).
Losses CO and CH3 are aligned by a mismatch (dotted edges).
(b) In the left tree, the fragment after loosing H3N is missing (dashed edges and node), whereas the fragment after further loss of C2H2 is observed.
To account for missing fragments, we introduce the join operation.
It allows to align the two successive losses H3N and C2H2 in the right tree to a single loss C2H5N in the left tree (dotted edges).
Fragments may be missing because the corresponding peak was not detected, for example  p1 by adding the corresponding losses (cid:2)(e1)+(cid:2)(e  (cid:4) 1) L. This means  taking the sum of the respective compomers or the additive union of the corresponding multisets.
We then assign a similarity between (cid:4) p1 and any edge e2 of T2 as σ (p1,e2)= σ ((cid:2)(e1)+(cid:2)(e 1),(cid:2)(e2)).
Analogously, we can deﬁne a similarity for paths of length two in T2.
Obviously, this can be generalized to paths of arbitrary lengths but here, we will limit ourselves to paths of length two.
For joining nodes in the alignment, we assume homogeneous join costs: The  penalty for joining a node is σjoin 0, independent of the node or  edge that we want to join.
Formally, this allows us to focus on the important aspects of our algorithms, and omit some technical details.
Practically, we currently see no biologically reasonable way to assign different scores to different join nodes, as these usually correspond to the non-detection of a peak in one of the mass spectra.
Let T1,T2 be two trees.
We deﬁne a global alignment A of T1,T2 as follows (Jiang et al., 1995): A is a tree where nodes are labeled with pairs from (V1    ) (V2    ).
Here,     is the gap symbol [see Figure 2(a)].
If we restrict labels of A to the ﬁrst coordinate and contract all edges that end in a node labeled    , we end up with the  [16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i267 i265 i273  i267   Copyedited by: zaza  MANUSCRIPT CATEGORY:  F.Hufsky et al.
prejoin case for nodes that will be joined in the alignment.
We set  Su,v[A,B]=max  (cid:3) 0,matchu,v[A,B], (cid:4) deleteLu,v[A,B],deleteRu,v[A,B], joinLu,v[A,B],joinRu,v[A,B]  (3)  where we deﬁne, in addition to (2), prejoinLu,v[A,B]:= max a A,b B prejoinLu,v σ (p(u)a,vb)+σjoin  S(a,b)+ A  a ,B  b (cid:6)+ (cid:5)  (cid:4)  (cid:3)  (cid:3)  joinLu,v[A,B]:= max a A,B(cid:4) B Su,v[A  a ,B B  (cid:4)]  (cid:4)  prejoinLa,v[C(a),B  (4)  (cid:4)]+  (cid:4),B  (cid:4)], such that u (cid:4) (cid:4),v  Here, σ (p(u)a,vb) is the score for the combined losses on the path from p(u) to a with the loss of edge vb.
Recall that σjoin 0 is the penalty for joining a node.
Again, we initialize joinLu,v[A, ]= joinLu,v[ ,B]=0 for all A,B.
Analogously to (4), we can deﬁne recurrences for prejoinRu,v[A,B] and joinRu,v[A,B].
For bottom-up DP (Sniedovich, 2006), we have to ﬁnd an order in which the entries of the DP tables can be ﬁlled.
Computation of matchu,v[A,B], deleteLu,v[A,B] and deleteRu,v[A,B] only accesses (cid:4)  u  C(u) and v (cid:4)  v  C(v).
By entries Su(cid:4),v(cid:4)[A (cid:4)] are processing nodes in postorder, we ensure that all Su(cid:4),v(cid:4)[A )(cid:10)=(u,v).
For the remaining case, we previously computed for (u iterate A + B =0,1,..., C(u) + C(v) .
Similar arguments hold for the computation of join and prejoin nodes.
Theorem 1.
Let T1=(V1,E1) and T2=(V2,E2) be two trees, σ : E1     E2      R a scoring function between edge pairs, and σjoin  R the penalty for joining a node.
For i=1,2 set ni :=  Vi , and let di be the maximum out degree in Ti.
The maximum score σ (T1,T2) of a local alignment of T1,T2 can be computed in O using recurrence (3) and equation (1), where  :=max d1,d2  and δ:=min d1,d2 .
3  2δ δn1n2  (cid:4),B  (cid:7)  (cid:8)  The proof of the theorem is based on the following lemma: Lemma 1.
Computing Su,v[A,B] for all A  C(u) and B  C(v) is possible using recurrence (3) in O(3du  2dv  dv+2du  3dv  du) time, where du= C(u)  and dv = C(v) .
See the Supplementary Material for proofs of Lemma 1 and Theorem 1.
Similarly to Theorem 1, we can show that any pairwise tree alignment that does not take joining nodes into account, can also be computed in this time.
We leave out the straightforward details.
(cid:7)  Theorem 2.
A pairwise unordered tree alignment (global or local, scoring nodes or edges or both, with similarities or costs) of rooted trees T1,T2 can be computed in O time.
Here, ni is the number of nodes in tree Ti, and di is the maximum out degree in Ti, for i=1,2  furthermore,  :=max d1,d2  and δ:= min d1,d2 .
3  2δ δn1n2  (cid:8)  Fig.
3.
Representation of the match and the deleteL recurrences of the DP algorithm.
(a) matchu,v[A,B] is the best score of matching edge ua on edge vb, such that maximally the children A of u and B of v are used.
(b) deleteLu,v[A,B] is the best score for deleting edge ua, such that maximally (cid:4)  B of the children of v the children A of u and B of v are used.
A subset B can now be matched to the children of a  non-empty sets A  C(u) and B  C(v) we set  (cid:3) 0,matchu,v[A,B], deleteLu,v[A,B],deleteRu,v[A,B]  (cid:4)  Su,v[A,B]=max  where we deﬁne  Su,v  (cid:3) S(a,b)+ A  a ,B  b (cid:6)+σ (ua,vb) (cid:3) (cid:4)  matchu,v[A,B]:= max (cid:5) a A,b B deleteLu,v[A,B]:= max a A,B(cid:4) B Su,v[A  a ,B B (cid:3) Su,b[A (cid:4),B  b ]+σ ( ,vb)  deleteRu,v[A,B]:= max A(cid:4) A,b B Su,v[A A  (cid:4)]+σ (ua, ) (cid:4),C(b)]+ (cid:4)  Sa,v[C(a),B  (cid:4)]+  (cid:4)  (2)  Here, σ (ua,vb) denotes the score of the losses attached to arcs ua and vb, and σ (ua, ),σ ( ,vb) accordingly.
Recurrence (2) is the obvious modiﬁcation of the recurrence presented in Jiang et al.
(1995) for global alignments and node similarities.
Merging two losses in T1 or T2 requires two additional symmetric cases, namely join left and join right for merging in tree T1 or T2, respectively.
To speed up computations, we add an additional  i268  [16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i268 i265 i273   Copyedited by: zaza  MANUSCRIPT CATEGORY:  Fast alignment of fragmentation trees  4 SPARSE DYNAMIC PROGRAMMING Applying the above algorithm to real-world instances of aligning fragmentation trees, one can see that S(u,v)=0 holds for many node pairs u,v.
This can be attributed to two factors: First, we are computing local alignments, so we can always choose to end the alignment subtrees in the nodes u,v.
Second, there are many different labels found at the edges (or nodes) of a fragmentation tree.
A reasonable scoring scheme will assign negative scores to most non-matching edge (or node) labels, so it is rather the exception than the rule that we can ﬁnd two nodes u,v with S(u,v)  0.
(cid:4)  (cid:4),B  with A  A  The idea is to  sparsify  our DP tables by storing only those table entries with positive values.
Thereby, we face the following (cid:4)]  0 (cid:4),B fact: If Su,v[A,B]  0 for A  C(u) and B  C(v) then Su,v[A (cid:4)  C(u) and B  B (cid:4)  C(v).
holds for all supersets A So, as soon as we have one non-zero entry in the table, then an exponentially large part of the table will be ﬁlled with non-zero entries, too.
To negate this rather unfortunate effect, we modify our DP as follows: for A  C(u) and B  C(v), we deﬁne S score of an optimum local alignment with subtrees rooted in u and v, respectively, such that exactly the children A of u and B of v are used in the local alignment.
If no such alignment exists, we set (cid:4) u,v[A,B]=  .
Then S S (cid:4) (cid:4) u,v[ ,B]  0.
Clearly, u,v[A, ]  0, S S S(u,v)= A C(u),B C(v)  (cid:4) u,v[ , ]=0, but for all A,B(cid:10)=  we have  (cid:4) u,v[A,B] to be the  (cid:4) u,v[A,B].
max  (5)  S  We need one more trick in our recurrence: in (2) we have accessed (cid:4),C(b)], but this is not possible for entries Sa,v[C(a),B the table S as the optimal alignments might not use all the children of a or b.
To this end, we introduce  (cid:4)] and Su,b[A  (cid:4)  (cid:3) (cid:3)  (cid:4) u,v[A, ]:= max B(cid:4) C(v) (cid:4) u,v[ ,B]:= max A(cid:4) C(u)  S  S  (cid:4)] (cid:4) u,v[A,B (cid:4),B] (cid:4) u,v[A  S  S  (cid:4) (cid:4)  ,  ,  for the maximum over all subsets of C(v) or C(u), respectively.
For non-empty sets A  C(u) and B  C(v) we set  (cid:3)  which, compared to (3), misses the lower bound 0 and uses the deﬁnitions:  (cid:4) u,v[A,B]=max  S  (cid:4) u,v[A,B], match (cid:4) (cid:4) (cid:4) u,v[A,B], u,v[A,B],deleteR deleteL (cid:4) (cid:4) u,v[A,B],joinR u,v[A,B] joinL (cid:3) S(a,b)+ A  a ,B  b (cid:6)+σ (ua,vb) (cid:3) (cid:4)  S  match  (cid:4) u,v[A,B]:= max (cid:5) a A,b B (cid:4) u,v (cid:4) (cid:4) u,v[A,B]:= max a,v[ ,B deleteL a A,B(cid:4) B (cid:4) u,v[A  a ,B B (cid:3) [A  deleteR  S  (cid:4) u,v[A,B]:= max A(cid:4) A,b B (cid:4) u,v[A A  S  S  (cid:4)]+ (cid:4)]+σ (ua, ) (cid:4), ]+ (cid:4)  (cid:4) S u,b (cid:4),B  b ]+σ ( ,vb)  (cid:4)  (6)  (7)  For the further join recurrences, we only concentrate on the left (cid:4) u,v[A, ] and the join recurrences at tree.
The deﬁnition of prejoinL the right tree are analogous.
(cid:4) u,v[A,B]:= max prejoinL a A,b B (cid:4) prejoinL u,v  (cid:3)  S(a,b)+ (cid:5) A  a ,B  b (cid:6)+ (cid:4)  (cid:4)  (cid:3)  σ (p(u)a,vb)+σjoin (cid:4) (cid:4),B] u,v[A prejoinL (cid:4) a,v[ ,B (cid:4) prejoinL (cid:4)]  (cid:4) u,v[ ,B]:= max prejoinL A(cid:4) A (cid:4) u,v[A,B]:= max joinL a A,B(cid:4) B (cid:4) u,v[A  a ,B B  (cid:3)  S  (cid:4)]+  (8)  (cid:4)  (cid:4),B  (cid:4)  B with (A  To summarize, the central point is that we do not have to store  (cid:4) u,v[A,B] 0: such entries will never lead to an  any entries with S optimal alignment, as we are better off removing all nodes A,B, plus everything below these nodes from the alignment.
The only (cid:4) u,v[ , ]=0.
exception to this rule is that we store the entry S (cid:4) u,v[A,B] if there exist Furthermore, we do not have to store entries S (cid:4) (cid:4)  A, B )(cid:10)=(A,B) such that S u,v[A,B]  subsets A (cid:4)].
In this case, we can replace an alignment that uses (cid:4),B (cid:4) u,v[A S (cid:4),B (cid:4) children A,B of u,v, by an alignment that uses only children A (cid:4) u,v[A,B] is and has better or equal score.
We say that an entry S (cid:4)].
For a scoring scheme that assigns dominated by entry S negative scores for non-matching edge (or node) labels, large parts of the tables have negative scores or are dominated by another entry.
We do not actually have to forbid that dominated entries are stored, as they do not interfere with our computations  rather, we are free to leave out dominated entries when we encounter them.
(cid:4) u,v[A  (cid:4),B  (cid:4) u,v are sparsely populated, and for many (cid:4) u,v[A,B]  0.
We can reduce  vertices u,v, there are no entries with S the memory consumption of the method using hash maps instead of arrays.
Hash map implementations like Cuckoo hashing (Pagh and Rodler, 2004) or Hopscotch hashing (Herlihy et al., 2008) can carry out all operations in constant (amortized) time.
In practice, we ﬁnd that memory consumption is usually not prohibitive.
In this case, we can use lazy arrays that are not allocated until a ﬁrst entry is stored.
The resulting tables S  Resolving the recurrences: Now, it is time for our ﬁnal trick: instead of computing the scores using recurrence (6 8), we apply a successive approximation procedure similar to Dijkstra s Algorithm for shortest paths (Sniedovich, 2006).
That is, instead of  pulling  scores from previously calculated entries, we  push  scores from entries that have been ﬁnalized.
For example, assume that we have ﬁnalized the computation of some entry (cid:4) u,v[A,B] for ﬁxed A  C(u) and B  C(v).
Also assume that S (cid:4) (cid:4) u,v[ , ]= u,v[A,B]  0 as otherwise, S S 0.
Then, recurrence (7) tells us that we can update other entries (cid:4) u,v[ ,B] (which we of the table accordingly: (cid:4) u,v[ ,B]  assume to be incompletely calculated so far) then S (cid:4) (cid:4) (cid:4) (cid:4) u,v[A, ]  u,v[A,B].
Similarly, if S u,v[A,B]   S u,v[A, ] then S S (cid:4) (cid:4) (cid:4) u,v[A,B]   S(u,v) then S(u,v)  S u,v[A,B].
u,v[A,B], and if S S , we iterate over all a  C(u)\A Regarding the recurrence for match (cid:4) (cid:4) and b  C(v)\B: If match u,v[A,B]+ u,v[A  a ,B  b ]   S(a,b)+S (cid:4) u,v[A  a ,B  b ]  σ (ua,vb) then update it accordingly.
If match  (cid:4) u,v[A,B] is dominated by S  (cid:4) u,v[A,B]   S  if S  (cid:4)  [16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i269 i265 i273  i269   Copyedited by: zaza  MANUSCRIPT CATEGORY:  F.Hufsky et al.
(cid:4) u,v[A,B] then the entry match match and we can remove it from the hash map.
(cid:4) u,v[A  a ,B  b ] is dominated  Table 1.
The three datasets used in this study  (cid:4)  C(v)\B   For all other cases, similar updates can be performed, which (cid:4) we iterate over all a  C(u)\ we only sketch here: For deleteL (cid:4) (cid:4)]+ u,v[A  a ,B B A and B if deleteL (cid:4) u,v[A,B]+σ (ua, ) then update it accordingly.
Updates have to S be performed as soon as an entry is ﬁnalized, that is, it cannot be changed by any future modiﬁcations.
Finding ﬁnalized entries is similar to the order of computations in the previous section  we omit the technical details.
(cid:4) a,v[ ,B  (cid:4)]   S  The above algorithm has exactly the same worst-case running time complexity as the initial recurrence from Section 3.
But in practice, we can get even faster, at least in cases where the arrays are very (cid:4) u,v[A,B] triggers sparse: to this end, ﬁnalizing some entry deleteL (cid:4)  C(v)\B.
But only those B updates for all subsets B can lead to (cid:4)]  0 holds.
Otherwise, the updated (cid:4) a,v[ ,B relevant updates where S (cid:4) a,v[ , ]=0.
If we iterate over the hash (cid:8) entry will be dominated by S (cid:4)]  0 then the worst-case running (cid:4) a,v[ ,B map for those B 4  2δ δn1n2 time increases to O , assuming constant time access to the hash map.
However, in practice, running time decreases if the DP tables are sparsely populated.
We stress that the sparse DP still guarantees to ﬁnd the optimal solution.
with S  (cid:7)  (cid:4)  (cid:4)  Characteristics of the datasets  Orbitrap  MassBank  Hill  Number of compounds Number of non-empty trees Maximum out degree Average/median out degreemax Number of alignments  97 93 7 3 4278  370 343 6 2 58 653  102 102 10 5 5151  Fragmentation trees were computed for all compounds.
Only non-empty trees were considered for tree alignment.
The maximum out degree of a single tree is denoted by out degreemax.
Number of alignments is given without self-alignments.
a join (e.g., φp(e)=1 if the former x(i) e,f   variable is 1).
We use the shorthands σ (1)(e,f ):= σ (e+p(e),f )+σjoin σ (e,f ) and σ (2)(e,f ):= σ (e,f +p(f ))+σjoin σ (e,f ) in the objective function.
Constraints (15) (17) are analogous to the former ILP.
While (18) guarantees that joins are always separated from each other within an input tree, (19) ensures that at most one joined alignment may occur for any edge.
Inequalities (20) (22) make sure that a parent edge e is only marked as a joined parent iff all its aligned children are joined with e .
Finally, (23) guarantees that we do not align two joined edges with each other.
(cid:4)  (cid:4)  5 INTEGER LINEAR PROGRAMMING ILPs are a classical approach for ﬁnding exact solutions of computationally hard problems.
We now present an ILP for  computing a pairwise unordered tree alignment.
Again, let T1= (V1,E1),T2=(V2,E2) be the input trees with V1 V2= .
As the ILP is edge based, we have to introduce some additional notation: Let e  Ei, i  1,2 , be any edge in one of the two given trees.
We denote by D(e) the set of edges in the subtree rooted at the head of e, and by N (e):= Ei\( e  D(e)) the non-descendant edges of e. For an edge (e):= p(e),p(p(e)),...  e, we deﬁne p(e) to be the parent edge, and p all of its ancestor edges.
Finally, F(e):=D(p(e)) N (e) is the  extended family  of e, that is, all descendants of e s parent edge, except for e and its descendants.
(ILP 1) and use the following binary variables: Iff an edge e  We start with the ILP without considering the join operation (cid:4)  (E1 E2) appears in the aligned subtree, we have ze(cid:4) =1  iff this edge is aligned to a gap, we have ye(cid:4) =1.
Finally, iff an edge e  E1 is aligned to an edge f   E2, we have x e,f  =1.
The constraints (10)  ensure for each edge that we decide whether this edge is used in the alignment and if, how it is aligned.
The inequalities (11) ensure that the subgraphs of T1 (and T2) are proper trees.
Finally, (12) ensure that the obtained alignments are consistent: assume an alignment (cid:14)e,f (cid:15) then we cannot also align a descendant of e with a non- descendant of f and vice versa.
The conditional term following the universal quantiﬁer simply avoids redundancy.
Based thereon, we can construct an ILP allowing join operations (ILP 2).
Therefore, we require additional binary variables x(i) e,f   (with i  1,2 ,e  Ei,f   E3 i), which are 1 iff the joined edges (p(e),e) are aligned with f .
Technically, we also require x e,f  =  1 in such a case.
Note that this amount of additional variables is necessary to compose a linear objective function, when the join costs cannot be computed only based on align- and gap costs.
Furthermore, we introduce binary variables φe(cid:4), e which are 1 iff the edge e  is used as a parent edge within  (cid:4) (E1 E2),  (cid:4)  6 EXPERIMENTAL RESULTS To evaluate our work, we used three different test datasets (Table 1).
The Orbitrap dataset (Rasche et al., 2012) contains 97 compounds, measured on a Thermo Scientiﬁc Orbitrap XL instrument.
The MassBank dataset (Horai et al., 2010) consists of 370 compounds measured on a Waters Q-Tof Premier spectrometer.
The Hill dataset consists of 102 compounds measured on a Micromass Q-Tof, published by Hill et al.
(2008).
We omit the experimental details.
Fragmentation trees were computed using ILP as described in Rauf et al.
(2012).
Self-alignments were excluded from the analysis.
For our evaluations, we use a scoring function very similar to the one from (Rasche et al., 2012), evaluating pairs of losses and pairs of fragments.
For losses nl1, nl2, we distinguish between size-dependent positive match scores σ (nl,nl):=5 + number of non-hydrogen atoms and size-dependent negative mismatch scores σ (nl1,nl2):= 5 number of different non-hydrogen atoms.
For f2, we use size-dependent positive match scores σ (f ,f ):=5 + number of non-hydrogen atoms and size- independent negative mismatch scores σ (f1,f2):= 3.
We allow  fragments f1,  insertion/deletions, as well as joining two subsequent losses, both without penalty.
The idea behind this ad hoc scoring is to reward or penalize large losses stronger than small losses, whereas non- matching fragments are penalized independent of size.
See Rasche et al.
(2012) for details.
We implemented the DP algorithms in Java 1.6.
For the sparse DP, we used lazy arrays to store the DP tables.
We solved the ILP via branch and cut using CPLEX 12.1 in its default settings.
Computation was done on two different but comparable computers, namely on a quad-core 2.2 GHz AMD Opteron processor with 5 GB of main memory for the DP algorithms, and on a quad-core Intel Xeon E5520 with 2.27 GHz in 32-bit mode for the ILP, using 2 GB RAM per job.
For the DP algorithms, we repeated computations ﬁve times, reporting the minimum running time for each instance.
i270  [16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i270 i265 i273   Copyedited by: zaza  MANUSCRIPT CATEGORY:  Fast alignment of fragmentation trees  (cid:4)  ) ye(cid:4)  σ ( ,e  (cid:9)  e E1 , f  E2  max  s.t.
σ (e,f ) x e,f  + (cid:9) e(cid:4) E1 (cid:2) ye+ f  E3 i  e(cid:4) E2  σ (e  (cid:4), ) ye(cid:4) + (cid:9) x e,f  = ze ze(cid:4) +ze(cid:4)(cid:4)  1+ze  x e,f  +x e(cid:4),f (cid:4)  1  x e,f  ,ye(cid:4) ,ze(cid:4)   0,1   ILP 1: The ILP for pairwise unordered tree alignment without join operations  (cid:10)  (cid:9)  e E1 , f  E2  max  s.t.
σ (e,f )x e,f  + (cid:9) ye+φe+   i  1,2 ,e  Ei (cid:4) D(e),e  i  1,2 ,e  Ei,e  i  1,2 ,e  Ei,f   E3 i,  (cid:4)(cid:4) F(e)  (cid:4) N (f ),[if i=2: f (cid:4) (E1 E2)     (cid:4)(cid:10)  p  (f )]  e  (cid:4) D(e),f  e  E1,f   E2,e (cid:4), )ye(cid:4) + (cid:9)  σ ( ,e  (cid:4)  (cid:11)  + (cid:9)  e(cid:4) E1  σ (e  (cid:2) f  V3 i  i  1,2 σ (i)(e,f )x(i) e,f   x e,f  = ze ze(cid:4) +ze(cid:4)(cid:4)  1+ze  x e,f  +x e(cid:4),f (cid:4)  1  φe(cid:4) +φe(cid:4)(cid:4)  1  x(1) e,f  +x(2) e,f    x e,f   x e,f   x(i) e,f   1 φe(cid:4) ye 1 φe(cid:4)  x(i) e,f    φe(cid:4) x(i) e,f  +φf (cid:4)  1  x e,f  ,ye(cid:4) ,ze(cid:4) ,x(i) e,f  ,φe(cid:4)   0,1   (cid:4)(cid:4) F(e)     (cid:4)(cid:10)  p  (f )]  )ye(cid:4)  e(cid:4) E2  i  1,2 ,e  Ei (cid:4) D(e),e  i  1,2 ,e  Ei,e  i  1,2 ,e  Ei,f   E3 i,  (cid:4)  )  e  (cid:4) N (f ),[if i=2: f (cid:4)(cid:4)= p(e  (cid:4) D(e),f (cid:4) (E1 E2),e  e  e  E1,f   E2  i  1,2 ,e  Ei,e  i  1,2 ,e  Ei,e  i  1,2 ,e  Ei,e  i  1,2 ,e  Ei,f   E3 i,f  i  1,2 ,e  E1,f   E2,e  (cid:4)= p(e),f   E3 i (cid:4)= p(e) (cid:4)= p(e),f   V3 i (cid:4)= p(f ) (cid:4) (E1 E2)  (9)  (10)  (11)  (12)  (13)  (14)  (15)  (16)  (17)  (18)  (19)  (20)  (21)  (22)  (23)  (24)  ILP 2: The ILP for pairwise unordered tree alignment including join operations  For the Orbitrap and the MassBank dataset, we found that for over 98% of the instances, the running time was in the range of microseconds for both DP algorithms.
For these datasets, we only evaluate total running times for all alignments.
For MassBank, the classical DP (Section 3) ﬁnished in 4.2 s for an all-against- all alignment of 343 trees, whereas sparse DP (Section 4) only required 1.8 s. For Orbitrap, the classical DP ﬁnished in 5.4 s for the all-against-all alignment of 93 trees, whereas sparse DP required 0.6 s, a 9-fold speed-up.
In contrast, the ILP needed 9.6 min for all alignments in the MassBank datasets and 14.5 min for all alignments in the Orbitrap dataset.
The Hill dataset contains trees with much higher maximum out degree, so we performed a more detailed running time analysis.
Classical DP required 13.9 min and sparse DP ﬁnished in 1.3 min, an 11-fold speed-up.
Running times of the ILP could only be measured without allowing join operations.
For 1241 instances, computations run into the memory limitation of 2 GB.
For the  the ILP ﬁnished in 11.24 h. Hence, we remaining alignments, excluded the ILP from our detailed analysis.
To get an overview of the differences in the running times between hard and easy alignments, we sorted the instances by their running times in increasing order.
This was done separately for each algorithm.
See Figure 4 (top) and Table 2.
For both algorithms, we found that the 99% fastest alignments need nearly as much computing time as the remaining 1% slowest alignments.
We further sorted all instances by the running time of the classical DP (see again Figure 4).
We found that for every instance, sparse DP requires less time than the classical DP.
7 CONCLUSION Fragmentation trees are a tool to overcome the limitations of spectral library search, as they, for the ﬁrst time, enable us to retrieve not only exact hits, but also similar compounds from a spectral database.
But performing the workﬂows proposed by Rasche et al.
(2012) on  i271  [16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i271 i265 i273   Copyedited by: zaza  MANUSCRIPT CATEGORY:  F.Hufsky et al.
(a)  (b)  Fig.
4.
Running times for the Hill dataset with 5151 individual alignments.
(a) Total running times when instances are sorted by individual running times.
For any fraction x%, we calculate the total running time of the x%, instances for which the alignment was computed faster than for any of the remaining instances.
For example at 50% one can ﬁnd the running time that was needed to compute the 50% fastest instances.
For each algorithm, instances were sorted separately.
Note the logarithmic y-axis.
(b) Individual running times for the 200 slowest instances of the classical DP algorithm.
Instances are sorted by their running time for the classical DP algorithm.
One can see that running times of the classical DP are outperformed by that of the sparse DP  a large database requires tree alignments to be executed extremely fast.
In this article, we have presented three exact algorithms for the alignment of fragmentation trees.
We ﬁnd that the sparse DP approach dominates the classical DP, resulting in an 11-fold speed- up for one dataset.
ILPs have an excellent record of providing fast algorithms for NP-hard problems.
Thus, it is rather unexpected that, for the problem discussed here, the ILP is usually clearly outperformed by both DP approaches  still, it has the potential to solve those instances that are  hard  for DP-based algorithms.
Also, in such cases we may use the ILP as a heuristic, solving only its LP relaxation and applying some integer rounding algorithm, many of which are standard in state-of-the-art ILP solvers.
i272  Table 2.
Running times for the Hill dataset  Algorithm All  90% fastest  99% fastest  1% slowest  DP 833.3 s Sparse DP 75.3 s  133.5 s (16.0%) 437.9 s (52.6%) 395.4 s (47.4%) 13.9 s (18.5%) 41.4 s (55.0%)  33.9 s (45.0%)  Speed up  11-fold 10-fold  13-fold  10-fold  We report running times in seconds and as fractions of the total running time for all instances (5151 alignments).
We also report running time for the 90 and 99% fastest and for the 1% slowest alignments.
For both algorithms, instances were sorted separately.
When larger datasets become available, we expect the total running time of an all-against-all alignment to increase more than quadratic with dataset size: We have shown above that a large fraction of the total running time stems from a few  hard  alignments which, in turn, correspond to a few trees in the dataset that are large and, in particular, have high out degrees.
We conjecture that for larger datasets, the running time spent on computing the 99% fastest alignments will be signiﬁcantly smaller than the running time spent on the 1% slowest alignments.
Here, even faster methods for computing fragmentation tree alignments are sought.
We will evaluate whether our ILP is capable of solving these  hard  instances faster than a DP-based approach, as its running time is not directly dependent on the out degree of the trees.
We have put particular focus on fragmentation trees that are hard to align, namely large trees with high out degrees.
Small trees with low out degree seem to be less interesting since they often belong to small compounds ( 300 Da).
Often, these compounds are  knowns  (that is, reference measurements of the compound can be found in a spectral library) and can be identiﬁed by spectral comparison.
Also, small fragmentation trees contain less information for, say, classifying an unknown compound.
Nevertheless, we believe that we can also speed up alignments when one of the fragmentation trees is relatively small: this may be achieved using some preprocessing for small trees with, say, less than four losses.
We conjecture that running time of the DP (Theorems 1 and 2)  can be improved to O(2d1+d2  poly(d1,d2)n1n2) using the Möbius  transform (Björklund et al., 2007), but theoretical interest only.
this appears to be of  In our evaluations, we have used a scoring function similar to the one by Rasche et al.
(2012).
Both scorings lack any statistical explanation and should be reﬁned in the future using, say, log odds scores.
Also, the effect of merging two or possibly even more nodes has to be investigated.
Both questions were beyond the scope of this work.
Another interesting question is whether polynomial-time methods for tree alignment of unordered trees, such as the constrained tree edit distance (Zhang, 1996), can be used for aligning fragmentation trees: whereas the restrictions imposed by Zhang (1996) have no sensible interpretation in the context of fragmentation trees, quality of results may still be sufﬁcient for certain applications.
trees  allows  Aligning  fragmentation  automated classiﬁcation of unknown compounds into compound classes.
Thus, large-scale compound screens can easily be searched for compounds of interest.
This may be useful in the search for signaling molecules, biomarkers, or novel drugs and the identiﬁcation of illegal drugs or toxins.
In conjunction with other methods from  for  an  [16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i272 i265 i273   Copyedited by: zaza  MANUSCRIPT CATEGORY:  Fast alignment of fragmentation trees  systems biology, the concept can help to identify new metabolic pathways based on tandem MS experiments.
ACKNOWLEDGMENTS We thank Aleš Svatoš (MPI for Chemical Ecology, Jena, Germany), Masanori Arita (University of Tokyo, Japan) and David Grant and Dennis Hill (University of Connecticut, Storrs, USA) for providing the MS datasets.
Funding: International Max Planck Research School Jena [stipend to F.H.]
and the Carl-Zeiss-Foundation [to M.C.].
Conﬂict of Interets: Value of two patents may be affected by publication (S.B., F.H.
and F.R.).
REFERENCES Arora,S.
et al.
(1998).
Proof veriﬁcation and the hardness of approximation problems.
J. ACM, 45, 501 555.
Backofen,R.
et al.
(2011).
Sparse RNA folding: time and space efﬁcient algorithms.
Hill,D.W.
et al.
(2008).
Mass spectral metabonomics beyond elemental formula: chemical database querying by matching experimental with computational fragmentation spectra.
Anal.
Chem., 80, 5574 5582.
Horai,H.
et al.
(2010).
MassBank: a public repository for sharing mass spectral data for  life sciences.
J.
Mass Spectrom., 45, 703 714.
Jiang,T.
et al.
(1995).
Alignment of trees: an alternative to tree edit.
Theor.
Comput.
Sci., 143, 137 148.
Last,R.L.
et al.
(2007).
Towards the plant metabolome and beyond.
Nat.
Rev.
Mol.
Cell  Biol., 8, 167 174.
Lederberg,J.
(1965).
Topological mapping of organic molecules.
Proc.
Natl.
Acad.
Sci.
USA, 53, 134 139.
Le,S.Y.
et al.
(1989).
Tree graphs of RNA secondary structures and their comparisons.
Comput.
Biomed.
Res., 22, 461 473.
Li,J.W.-H. and Vederas, J.C. (2009).
Drug discovery and natural products: end of an  era or an endless frontier  Science, 325, 161 165.
Ljubi c,I.
et al.
(2005).
Solving the prize-collecting steiner tree problem to optimality.
In Proceedings of Algorithm Engineering and Experiments (ALENEX 2005), SIAM, pp.
68 76.
Neumann, S. and Böcker, S.  (2010).
Computational mass  spectrometry for  metabolomics   a review.
Anal.
Bioanal.
Chem., 398, 2779 2788.
Oberacher,H.
et al.
(2009).
On the inter-instrument and inter-laboratory transferability of a tandem mass spectral reference library: 1. results of an Austrian multicenter study.
J.
Mass Spectrom., 44, 485 493.
Pagh,R.
and Rodler,F.F.
(2004).
Cuckoo hashing.
J. Algorithms, 51, 122 144.
Rasche,F.
et al.
(2011).
Computing fragmentation trees from tandem mass spectrometry  J. Discrete Algorithms, 9, 12 31.  data.
Anal.
Chem., 83, 1243 1251.
Björklund,A.
et al.
(2007).
Fourier meets Möbius: fast subset convolution.
In Proceedings of ACM Symposium on Theory of Computing (STOC 2007), ACM Press, New York, pp.
67 74.
Böcker,S.
and Rasche,F.
(2008).
Towards de novo identiﬁcation of metabolites by analyzing tandem mass spectra.
Bioinformatics, 24, I49 I55.
[Proceedings of European Conference on Computational Biology (ECCB 2008)].
Canzar,S.
et al.
(2011).
On tree-constrained matchings and generalizations.
International Conference on Automata, Languages and  In Proceedings of Programming (ICALP 2011), Springer, Berlin, Vol.
6755, pp.
98 109.
Rasche,F.
et al.
(2012).
Identifying the unknowns by aligning fragmentation trees.
Anal.
Chem., 84, 3417 3426.
Rauf,I.
et al.
(2012).
Finding maximum colorful subtrees in practice.
In Proceedings of Research in Computational Molecular Biology (RECOMB 2012).
Springer, Berlin, Vol.
7262, pp.
213 223.
Scheubert,K.
et al.
(2011).
Computing fragmentation trees from metabolite multiple mass spectrometry data.
In Proceedings of Research in Computational Molecular Biology (RECOMB 2011), Vol.
6577, pp.
377 391.
Schmidt,B.M.
et al.
(2007).
Revisiting the ancient concept of botanical therapeutics.
Cui,Q.
et al.
(2008).
Metabolite identiﬁcation via the Madison Metabolomics  Nat.
Chem.
Biol., 3, 360 366.
Consortium Database.
Nat.
Biotechnol., 26, 162 164.
Sniedovich,M.
(2006).
Dijkstra s algorithm revisited:  the dynamic programming  Fernie,A.R.et al.
(2004).
Metabolite proﬁling: from diagnostics to systems biology.
Nat.
connexion.
Control Cybern., 35, 599 620.
Rev.
Mol.
Cell Biol., 5, 763 769.
Fiehn,O.
(2008).
Extending the breadth of metabolite proﬁling by gas chromatography  coupled to mass spectrometry.
Trends Analyt.
Chem., 27, 261 269.
Werner,E.
et al.
(2008).
Mass spectrometry for the identiﬁcation of the discriminating signals from metabolomics: current status and future trends.
J. Chromatogr.
B, 871, 143 163.
Halket,J.M.
et al.
(2005).
Chemical derivatization and mass spectral libraries in  Zhang,K.
and Jiang,T.
(1994).
Some MAX SNP-hard results concerning unordered  metabolic proﬁling by GC/MS and LC/MS/MS.
J. Exp.
Bot., 56, 219 243.  labeled trees.
Inf.
Process.
Lett., 49, 249 254.
Herlihy,M.
et al.
(2008).
Hopscotch hashing.
In Proceedings of Symposium on  Zhang,K.
(1996).
A constrained edit distance between unordered labeled trees.
Distributed Computing (DISC 2008), Springer, Berlin, Vol.
5218, pp.
350 364.
Algorithmica, 15, 205 222.
[16:59 29/5/2012 Bioinformatics-bts207.tex]  Page: i273 i265 i273  i273
