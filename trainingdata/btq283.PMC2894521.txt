ABSTRACT Motivation: The anatomy of model species is described in ontologies, which are used to standardize the annotations of experimental data, such as gene expression patterns.
To compare such data between species, we need to establish relations between ontologies describing different species.
Results: We present a new algorithm, and its implementation in the software Homolonto, to create new relationships between anatomical ontologies, based on the homology concept.
Homolonto uses a supervised ontology alignment approach.
Several alignments can be merged, forming homology groups.
We also present an algorithm to generate relationships between these homology groups.
This has been used to build a multi-species ontology, for the database of gene expression evolution Bgee.
Availability: download section of the Bgee websiteContact: marc.robinson-rechavi@unil.ch Supplementary information: Supplementary data are available at Bioinformatics online.
Received on January 14, 2010; revised on May 6, 2010; accepted on May 26, 2010 1 INTRODUCTION Databases dedicated to model species rely on the usage of ontologies, for example the zebrafish anatomy for ZFIN (Sprague et al., 2006), or the Mouse gross anatomy and development (Baldock et al., 2003).
Such ontologies of anatomy and development facilitate the organization of functional data pertaining to a species.
For example, all gene expression patterns described in ZFIN are annotated using the zebrafish anatomical ontology.
A list of such ontologies is kept on the Open Biomedical Ontologies (OBO) website (Smith et al., 2007).
To pool the experimental data from different model species, we need to encode corresponding information between ontologies which describe different anatomies (e.g.
zebrafish and human).
For example, we are interested in integrating and comparing gene expression patterns between several species (Bastian et al., 2008).
The most widely accepted criterion to make such comparisons in biology is homology (Hall, 1994; Hossfeld and Olsson, 2005).
When we compare two elements, whether or not they are derived from the same ancestral element defines our expectation of similarity To whom correspondence should be addressed.
between them, and the interpretation of differences.
For example, if a chicken wing is not homologous to a fly wing, we do not expect the same underlying structures, and similarities can be attributed to functional convergence.
Whereas the chicken wing is homologous (as a limb) to the human arm, thus we do expect the same underlying structures, and differences can be attributed to divergent evolution.
There are different definitions of homology (Roux and Robinson-Rechavi, 2010), and our algorithm does not in itself impose one on the user.
We do recommend choosing an explicit definition and using it consistently throughout the analysis.
In practice, hundreds of terms must be compared between ontologies that may differ both in the actual biology modeled (i.e.
a fish is not a mammal) and in the representation used.
Although a purely manual annotation of homologies is possible, it would be too time consuming to be done for all terms between several divergent species.
Kruger et al.
(2007) have used a manual approach to find similarities between simplified anatomy ontologies for human and mouse.
As both are mammals, they share most structures and terminology.
There are also on-going efforts to integrate anatomical ontologies (Haendel et al., 2008; Washington et al., 2009), which are often geared towards the comparison of phenotypes (Lussier and Li, 2004).
As far as we know, the question of using homology to align anatomical ontologies has never been explicitly addressed.
Since the problem is to find correspondences between the concepts of two ontologies, we draw on methods from schema matching, or ontology alignment (Euzenat and Shvaiko, 2007; Lambrix and He, 2008).
As opposed to more generalist solutions, we present a algorithm which is specialized in the alignment of anatomical ontologies.
The specificities of these ontologies include high redundancy of terms, and few types of relations.
Finally, a specific issue is that structures which have the same name and are related to similar concepts may not be homologous.
This is the case of the insect eye and the mammalian eye.
While some underlying molecular mechanisms are similar, these structures evolved independently and are not considered homologous (discussed in Hall, 1994; Shubin et al., 2009).
Unsupervised alignment algorithms would misleadingly align such similarities; this is for instance the case for the LOOM software used on the NCBO portal (Ghazvinian et al., 2009).
In principle, an alignment algorithm should aim at finding the largest number of true positives, while avoiding false positives.
In practice, our experience is that the size and structure of anatomical ontologies leads to very large numbers of false positives if a naive approach is taken (i.e.
common words).
Thus, the basic aim of Homolonto is to propose in priority to the user the best candidate The Author(s) 2010.
Published by Oxford University Press.
This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/2.5), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.
[10:48 16/6/2010 Bioinformatics-btq283.tex] Page: 1767 17661771 Homolonto pairs of homologs, and avoid the need to consider many irrelevant pairs.
2 SYSTEMS AND METHODS Homolonto is implemented in Java.
Ontologies are read in the OBO format (Smith et al., 2007).
Homolonto is freely available in the download section of the Bgee website (http://bgee.unil.ch/).
3 ALGORITHM 3.1 Principle Ontology alignment is the process of determining correspondences between ontology concepts.
We present our approach based on the classification of ontology matching systems proposed by Euzenat and Shvaiko (2007; Shvaiko and Euzenat, 2005).
Biological ontologies simplify some aspects relative to the general case.
The types of concepts (e.g.
anatomical structures) and the relationships (e.g.
part_of ) are known in advance, and known to be common between the ontologies to align.
Moreover, in the present implementation we only seek to establish one type of relation, homology.
Our algorithm can be described as a composite system (Fig.1), using: (i) language-based comparison of names with tokenization (element level, syntactic technique); (ii) graph-based matching of children of elements (structure level, syntactic technique); (iii) data analysis, e.g.
statistics on word occurrence (structure level, syntactic technique); (iv) external input from the user (element level, external technique; classification following Euzenat and Shvaiko, 2007).
We combine the results in parallel, as opposed to in sequence, by using a sum of scores from different techniques.
Thus, we make use both of schema and element level information.
The algorithm produced in a first step anchors at the element level, generated by language technique, and potentially by the user (external), then uses information from the schema, the elements, and user input, to improve the alignment based on these anchors.
Importantly, each proposition of homology between elements must be validated by the user (external input), to take into account Fig.1.
Homolonto pairwise alignment architecture.
O1 and O2 are ontologies to align.
P and P are lists of propositions.
H is a list of validated homologies (invalidation information).
A is the final alignment, generated when the user chooses to stop iterations.
User input appears twice: to propose original pairings, and to validate propositions.
such cases as the eye, discussed in the Introduction section.
Thus our process is a supervised one.
Finally, we note that the alignment we obtain is of the form many to many, not one to one.
3.2 Definitions A central concept in our algorithm is that of a proposition (similar to suggestion in Lambrix and He, 2008).
A proposition is a pair of terms (also called class in OWL) from the two ontologies for which a score has been computed.
This may have been done based on homonymy (common words) of the term names (also called class label in OWL), or propagation through the ontology.
It is important to note (i) that not all possible propositions (i.e.
pairs of terms) are created during the alignment, and (ii) that the list of propositions evolves during iterations of the algorithm.
For performance, our algorithm is not symmetric.
Propositions are managed relative to one ontology, to align, which is being aligned to the reference ontology (the one loaded first by the user).
This allows us to store explicitly the information that term A of the ontology to align has two propositions, with term X and with term Y, of the reference ontology.
If X has propositions not only with A but also with B of the ontology to align, this will not be taken into account explicitly.
3.3 Algorithm (1) Computing word specific scores: score modifiers are computed for all words of the ontologies being aligned.
Each word present at least once in both ontologies being aligned (O1 and O2) is given a score modifier based on its number of occurrences f (word, O): Mod(word,Oi)=1/(1+log10( f (word,Oi))) (1) Mod(word)=Mod(word,O1)Mod(word,O2) (2) (2) Starting list of propositions (P in Fig.1): to initialize the algorithm we define first obvious similarities between the terms of the ontologies to align.
Based on the assumption that two structures that have the same name are likely homologous, the initial propositions are formed of terms with identical names.
For example, optic cup of ZFA (zebrafish, Table 1) and optic cup of EHDAA (human, Table 1) will form a proposition.
But ventricleand cardiac ventricle will not.
In this process, we also consider the synonym field of the terms.
For example the ZFA term melanocyte (synonym melanophore) will form a proposition with the term melanophore (synonym melanocyte) from XAO (Xenopus, Table 1).
Each pair of names n1, n2, is given a base score, dependent on the words shared: Base_score(n1,n2)= base_homonymy_scoremax(Mod(word))|n1 n2| max(|n1|,|n2|) (3) where |n| is the number of words in n, |n1 n2| is the number of words shared by n1 and n2, and max(Mod(word)) is computed over all shared words.
In the starting list, |n1 n2|=|n1|=|n2| by definition, but this is not the case at further iterations of the algorithm.
The comparison of terms names is intentionally quite basic, and does not take advantage of, e.g.
etymology of words.
In our experience, terms names used in anatomical ontologies are similar 1767 [10:48 16/6/2010 Bioinformatics-btq283.tex] Page: 1768 17661771 G.Parmentier et al.
Table 1.
Summary of the alignments discussed Zebrafish Xenopus Human Mouse Ontologya ZFA XAO EHDAA EMAPA Number of terms 1974 569 2327 3525 with synonyms 1080 122 0 0 with definitions 772 186 0 0 Number of validationsb 189 1959 Number of invalidations 543 1003 Number of unique terms aligned 183 182 1541 1754 a
