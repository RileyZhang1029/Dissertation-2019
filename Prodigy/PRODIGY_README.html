<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <style>*, *:before, *:after {box-sizing: border-box;margin: 0;padding: 0;}html {font-size: 9px;}body {background-color: #eee;color: #1a1e24;font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";font-size: 1.6rem;-webkit-font-smoothing: antialiased;line-height: 1.55;-moz-osx-font-smoothing: grayscale;padding: 0 !important;-ms-text-size-adjust: 100%;-webkit-text-size-adjust: 100%;word-wrap: break-word;}@media screen and (min-width: 52em) {html {font-size: 10px;}body > article > * {margin-left: auto !important;margin-right: auto !important;width: 65%;}pre {border-radius: 4px;}}@media screen and (max-width: 51em) {article > h2,article > h3,article > h4,article > h5,article > h6,article > p,h1#prodigy {padding-left: 2.5rem;padding-right: 2.5rem;}article > ol {margin-left: 2.5rem;padding-right: 2.5rem;}}body > article > p:first-child {margin: 0;}body > article > p:last-child {bottom: -14rem;font-size: 1.4rem;position: relative;text-align: center;width: 100%;}body > article {position: relative;}body > article:before,body > article:after {background-repeat: no-repeat;background-size: 100% 15rem;content: "";display: block;height: 15rem;width: 100%;}body > article:before {background-image: linear-gradient(-2deg, #eee 24.9%, #dfdfdf 25%);}body > article:after {background-image: linear-gradient(-2deg, #dfdfdf 74.9%, #eee 75%);}.logo-link {border-bottom: none !important;left: 2rem;position: absolute;top: 2rem;}.logo {height: 7.5rem;transition: transform 0.5s ease-in-out;width: 7.5rem;}.logo:hover {transform: rotate(360deg);}#top a {border: none;}#top {margin: 0;padding: 0;bottom: 15px;font-size: 14px;position: fixed;right: 20px;text-transform: uppercase;}h2, h3, h4, h5, h6 {font-weight: bold;margin-bottom: 1.6rem;margin-top: 3em;}h1 {border-bottom: none;font-size: 3.8rem;font-weight: bold;padding-bottom: 0.3em;line-height: 1.2;}h1 ~ h1 {background: #c8c8c8;background-image: linear-gradient(-2deg, #eee 24.9%, #dfdfdf 25%);background-repeat: no-repeat;background-size: 100% 15rem;margin: 3em 0 0 0 !important;min-height: 15rem;padding-left: 17.5%;padding-top: 1em;width: 100% !important;}h1 + p {margin-top: 4rem;}h1#prodigy {margin-bottom: 1.25rem;margin-top: 5rem;}h1#prodigy + p {font-size: 2.4rem;padding-right: 10%;}h2 {font-size: 2.8rem;}h3 {font-size: 2.4rem;}h4 {font-size: 2rem;}h5 {font-size: 1.8rem;}h6 {font-size: 1.6rem;}h2 > kbd,h3 > kbd,h4 > kbd,h5 > kbd {background: #252a33;border: none;border-radius: 4px;box-shadow: none;color: #eee !important;display: inline-block;font-family: inherit;font-size: 1.2rem;margin-right: 1rem;padding: 0.15em 0.6em 0.3em;vertical-align: middle;}h2 code, h3 code, h4 code, h5 code, h6 code {font-size: inherit;line-height: auto;}a[href] {border-bottom: 1px solid #c8c8c8;color: inherit;text-decoration: none;transition: border 0.2s ease;}a[href]:hover {border-bottom-color: #565656;}a:focus {outline: 1px dotted currentColor !important;}code, pre, kbd {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;}code {font-size: 14px;line-height: 19px;}pre code {color: #eee !important;}pre {direction: ltr;max-width: 100%;overflow: auto;padding: 0.75em 0;white-space: pre;width: 100%;background: #252a33 !important;color: #eee !important;font-size: 1.4rem;line-height: 1.7;padding: 30px;}*:not(pre) > code,kbd {background: rgba(37, 42, 51, 0.1);border-radius: 4px;box-decoration-break: clone;color: #252a33 !important;margin: 0;padding: 0.2em 0.55em;white-space: nowrap;font-size: 13px;}kbd {background: rgba(255, 255, 255, 0.65);border: 1px solid #c8c8c8;box-shadow: inset 0 -1px 0 #c8c8c8;text-transform: uppercase;}p, table, pre, blockquote {margin-bottom: 3rem;}blockquote {background: #dfdfdf !important;border: none;border-radius: 4px;padding: 2.5rem;}blockquote ul {list-style: none;}blockquote p {margin-bottom: 0;}hr {border: 0;border-bottom: 2px solid #dfdfdf !important;height: 7.5rem;margin-left: 0 !important;margin-right: 0 !important;width: 100% !important;}img {max-width: 100%;max-height: 100%;}article > ol,article > ul {padding-left: 1.5em;}article > ol ul {margin-left: 1.5em;}ol ol,ul ol {list-style-type: lower-roman;}ul ul ol,ul ol ol,ol ul ol,ol ol ol {list-style-type: lower-alpha;}table {border-collapse: collapse;display: block;max-width: 100%;overflow: auto;text-align: left;width: 100%;}thead, tbody, tr {width: 100%;}table th {border-bottom: 2px solid #252a33 !important;font-size: 1.4rem;font-weight: bold;text-transform: uppercase;text-align: left;}table th,table td {padding: 0.8rem 1.3rem !important;vertical-align: top;}table td {border: none !important;}table td:not(:last-child) {border-right: 1px solid #c8c8c8 !important;}details > summary {cursor: pointer;font-weight: bold;font-size: 1.2em;}.hljs {display: block;overflow-x: auto;padding: 0.5em;color: #eee;}.hljs-comment,.hljs-quote {color: #949e9b;}.hljs-keyword,.hljs-selector-tag,.hljs-literal {color: #ff0091;}.hljs-string,.hljs-regexp,.hljs-variable,.hljs-template-variable,.hljs-addition {color: #faca60;}.hljs-number {color: #b084eb;}.hljs-tag,.hljs-name,.hljs-type,.hljs-selector-class,.hljs-selector-id {color: #6ef6e3;}.hljs-symbol,.hljs-bullet,.hljs-built_in,.hljs-builtin-name,.hljs-attr,.hljs-link {color: #6ef6e3;}.hljs-params,.hljs-attribute {color: #eee;}.hljs-meta,.hljs-title,.hljs-section {color: #61e5fc;}.hljs-emphasis {font-style: italic;}.hljs-strong {font-weight: bold;}.hljs-link {text-decoration: underline;}.emoji {height: 20px;}.text.language-text > [class^="hljs"] {color: #eee !important;}/* Print */@media print {body {background: none;}p {widows: 3;}pre {white-space: pre-wrap;}pre, blockquote, table tr {page-break-inside: avoid;}h1 ~ h1 {background: transparent !important;height: initial;min-height: initial;padding-left: 0 !important;}h2, h3, h4, h5, h6, table thead, table:first-child {page-break-after: avoid;}hr {display: block;page-break-after: always;visibility: hidden;}h1#prodigy,body > article > h2:first-child {margin-top: 0;}.logo-link {position: static;}}</style>
    </head>
    <body>
        <article>
            <a href="https://explosion.ai" class="logo-link"><img src="https://explosion.ai/assets/img/logo.svg" width="125" height="125" class="logo" /></a>

            <h1 id="prodigy">
                <svg aria-label="Prodigy" viewBox="0 0 540 158" width="250" height="73">
                    <path d="M70.6 48.6c7 7.3 10.5 17 10.5 29.2s-3.3 22-10.4 29.2c-7 7.3-16 11-27 11-9.4 0-16.8-2.6-21.7-8v44.7H0V39h20.7v8c4.8-6.3 12.4-9.5 23-9.5 11 0 20 3.7 27 11zM22 76v3.6c0 12 7.2 19.8 18.2 19.8 11.2 0 18.7-8 18.7-21.6S51.3 56.2 40 56.2C29.2 56.2 22 64 22 76zM133.8 59.4c-12.6 0-20.5 7-20.5 17.8v39.3h-22V39h21v8.8c4-6.4 11.3-9.6 21.4-9.6v21.2zM209.5 107c-7.6 7.4-17.5 11.2-29.5 11.2s-22-3.8-29.7-11c-7.6-7.6-11.5-17.3-11.5-29.3 0-12.2 4-22 11.5-29.3 7.8-7.3 17.7-11 29.7-11s22 3.7 29.5 11c7.8 7.3 11.7 17 11.7 29.2 0 11.8-4 21.6-11.7 29zM180 56.3c-5.7 0-10.3 2-13.8 5.8s-5.2 9-5.2 15.7c0 6.7 1.8 12 5.2 15.7 3.4 3.8 8 5.7 13.8 5.7s10.3-1.8 13.8-5.6 5.2-9 5.2-15.7c0-6.8-1.8-12-5.2-15.7-3.5-3.8-8-5.8-13.8-5.8zM313 116.5h-20.5v-8c-4.4 5.6-12.7 9.7-23 9.7-11 0-20-3.8-27-11-7-7.5-10.5-17.2-10.5-29.4s3.5-22 10.3-29.2c7-7.3 16-11 27-11 9.7 0 17 2.6 22 8V0H313v116.5zm-58.8-38.7c0 13.6 7.5 21.4 18.7 21.4 10.8 0 18.2-7.3 18.2-19.8V76c0-12.2-7.3-19.8-18.3-19.8-11.3 0-18.8 8-18.8 21.6zM354 13.6c0 3.6-1.2 6.8-3.8 9.3-5 4.8-13.6 4.8-18.6 0C323.2 15.3 330-.3 341 .3c7.3 0 13 6 13 13.2zm-2 103h-22V39h22v77.5zM425 47v-8h20.6v80.4c0 11.2-3.6 20-10.6 26.8-7 6.7-16.6 10-28.5 10-23.4 0-37-11.4-40-29.8l21.8-.8c1 7.6 7.6 12 17.4 12 11.2 0 18-5.8 18-16.6v-11c-5 5.4-12.4 8-21.8 8-11 0-20-3.7-27-11s-10.4-17-10.4-29.2 3.5-22 10.3-29.2c7-7.3 16-11 27-11 10.6 0 18.3 3 23 9.5zM387 78c0 13.6 7.5 21.6 18.7 21.6 11 0 18.3-7.6 18.3-19.8V76c0-12.2-7.3-19.8-18.3-19.8-11.2 0-18.7 8-18.7 21.6zM488.8 154.8H465l19.8-45L454.5 39h24l18 46.2L514 39h24.3l-49.7 115.8z"/>
                </svg>
            </h1>

            <p>Radically efficient machine teaching. An annotation tool powered by active
learning. From the makers of <a href="https://spacy.io">spaCy</a>. For more info, see the
<a href="https://prodi.gy/docs">Prodigy website</a> and check out the
<a href="https://support.prodi.gy">support forum</a>.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ol>
<li><a href="#getting-started"><strong>Getting started</strong></a><ul>
<li><a href="#glossary">Glossary</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#database-setup">Database setup</a><ul>
<li><a href="#sqlite">SQLite</a></li>
<li><a href="#mysql">MySQL</a></li>
<li><a href="#postgresql">PostgreSQL</a></li>
<li><a href="#permissions-and-user-privileges">Permissions and user privileges</a></li></ul></li>
<li><a href="#annotation-ui">Annotation UI</a><ul>
<li><a href="#annotation-interfaces">Annotation interfaces</a></li>
<li><a href="#key-bindings-and-swipe-gestures">Key bindings and swipe gestures</a></li>
<li><a href="#themes">Themes</a></li>
<li><a href="#custom-interfaces">Custom interfaces</a></li>
<li><a href="#javascript-and-css">JavaScript & CSS</a></li></ul></li>
<li><a href="#multi-user-sessions">Multi-user Sessions</a></li>
<li><a href="#importing-existing-data">Importing existing data</a></li>
<li><a href="#debugging-and-logging">Debugging & logging</a></li>
<li><a href="#environment-variables">Environment variables</a></li></ul></li>
<li><a href="#workflows-videos"><strong>Workflows & Videos</strong></a><ul>
<li><a href="#workflow-first-steps"><kbd>WORKFLOW</kbd> First steps</a></li>
<li><a href="#video-new-entity-type"><kbd>VIDEO</kbd> Training a new entity type on Reddit comments</a></li>
<li><a href="#video-training-an-insults-classifier"><kbd>VIDEO</kbd> Training an insults classifier</a></li>
<li><a href="#video-faq1"><kbd>VIDEO</kbd> Tips & tricks for NLP, annotation & training</a></li>
<li><a href="#workflow-text-classification"><kbd>WORKFLOW</kbd> Text Classification</a></li>
<li><a href="#workflow-named-entity-recognition"><kbd>WORKFLOW</kbd> Named Entity Recognition</a></li>
<li><a href="#workflow-custom-recipes"><kbd>WORKFLOW</kbd> Custom Recipes</a></li></ul></li>
<li><a href="#recipes"><strong>Recipes</strong></a><ul>
<li><a href="#built-in-recipes">Built-in recipes</a><ul>
<li><strong>Named Entity Recognition</strong><ul>
<li><a href="#teach-nerteach"><kbd>TEACH</kbd> ner.teach</a></li>
<li><a href="#teach-nerbatch-train"><kbd>TEACH</kbd> ner.batch-train</a></li>
<li><a href="#evaluate-nertrain-curve"><kbd>EVALUATE</kbd> ner.train-curve</a></li>
<li><a href="#teach-nermatch"><kbd>TEACH</kbd> ner.match</a></li>
<li><a href="#teach-nermanual"><kbd>TEACH</kbd> ner.manual</a></li>
<li><a href="#teach-nermake-gold"><kbd>TEACH</kbd> ner.make-gold</a></li>
<li><a href="#teach-nersilver-to-gold"><kbd>TEACH</kbd> ner.silver-to-gold</a></li>
<li><a href="#evaluate-nereval"><kbd>EVALUATE</kbd> ner.eval</a></li>
<li><a href="#evaluate-nereval-ab"><kbd>EVALUATE</kbd> ner.eval-ab</a></li>
<li><a href="#explore-nerprint-best"><kbd>EXPLORE</kbd> ner.print-best</a></li>
<li><a href="#explore-nerprint-stream"><kbd>EXPLORE</kbd> ner.print-stream</a></li>
<li><a href="#explore-nerprint-dataset"><kbd>EXPLORE</kbd> ner.print-dataset</a></li>
<li><a href="#manage-nergold-to-spacy"><kbd>MANAGE</kbd> ner.gold-to-spacy</a></li>
<li><a href="#manage-neriob-to-gold"><kbd>MANAGE</kbd> ner.iob-to-gold</a></li></ul></li>
<li><strong>Text Classification</strong><ul>
<li><a href="#teach-textcatteach"><kbd>TEACH</kbd> textcat.teach</a></li>
<li><a href="#teach-textcatmanual"><kbd>TEACH</kbd> textcat.manual</a></li>
<li><a href="#teach-textcatbatch-train"><kbd>TEACH</kbd> textcat.batch-train</a></li>
<li><a href="#evaluate-textcattrain-curve"><kbd>EVALUATE</kbd> textcat.train-curve</a></li>
<li><a href="#evaluate-textcateval"><kbd>EVALUATE</kbd> textcat.eval</a></li>
<li><a href="#explore-textcatprint-stream"><kbd>EXPLORE</kbd> textcat.print-stream</a></li>
<li><a href="#explore-textcatprint-dataset"><kbd>EXPLORE</kbd> textcat.print-dataset</a></li></ul></li>
<li><strong>Part-of-speech Tagging</strong><ul>
<li><a href="#teach-posteach"><kbd>TEACH</kbd> pos.teach</a></li>
<li><a href="#teach-posbatch-train"><kbd>TEACH</kbd> pos.batch-train</a></li>
<li><a href="#teach-postrain-curve"><kbd>EVALUATE</kbd> pos.train-curve</a></li>
<li><a href="#evaluate-posmake-gold"><kbd>EVALUATE</kbd> pos.make-gold</a></li>
<li><a href="#manage-posgold-to-spacy"><kbd>MANAGE</kbd> pos.gold-to-spacy</a></li></ul></li>
<li><strong>Dependency Parsing</strong><ul>
<li><a href="#teach-depteach"><kbd>TEACH</kbd> dep.teach</a></li>
<li><a href="#teach-depbatch-train"><kbd>TEACH</kbd> dep.batch-train</a></li>
<li><a href="#teach-deptrain-curve"><kbd>EVALUATE</kbd> dep.train-curve</a></li></ul></li>
<li><strong>Vectors & Terminology</strong><ul>
<li><a href="#teach-termstrain-vectors"><kbd>TEACH</kbd> terms.train-vectors</a></li>
<li><a href="#teach-termsteach"><kbd>TEACH</kbd> terms.teach</a></li>
<li><a href="#manage-termsto-patterns"><kbd>MANAGE</kbd> terms.to-patterns</a></li></ul></li>
<li><strong>Computer Vision</strong><ul>
<li><a href="#explore-imagemanual"><kbd>TEACH</kbd> image.manual</a></li>
<li><a href="#explore-imagetest"><kbd>EXPLORE</kbd> image.test</a></li></ul></li>
<li><strong>Other Recipes & Commands</strong><ul>
<li><a href="#teach-mark"><kbd>TEACH</kbd> mark</a></li>
<li><a href="#evaluate-review"><kbd>EVALUATE</kbd> review</a></li>
<li><a href="#evaluate-compare"><kbd>EVALUATE</kbd> compare</a></li>
<li><a href="#manage-pipe"><kbd>MANAGE</kbd> pipe</a></li>
<li><a href="#manage-prodigy"><kbd>MANAGE</kbd> prodigy</a></li>
<li><a href="#manage-dataset"><kbd>MANAGE</kbd> dataset</a></li>
<li><a href="#manage-stats"><kbd>EXPLORE</kbd> stats</a></li>
<li><a href="#manage-db-in"><kbd>MANAGE</kbd> db-in</a></li>
<li><a href="#manage-db-out"><kbd>MANAGE</kbd> db-out</a></li>
<li><a href="#manage-db-merge"><kbd>MANAGE</kbd> db-merge</a></li>
<li><a href="#manage-drop"><kbd>MANAGE</kbd> drop</a></li></ul></li></ul></li>
<li><a href="#custom-recipes">Custom recipes</a><ul>
<li><a href="#recipe-components">Recipe components</a></li>
<li><a href="#example-recipe-classifying-tweets">Example recipe: Classifying tweets</a></li>
<li><a href="#modifying-existing-recipes">Modifying existing recipes</a></li>
<li><a href="#testing-recipes">Testing recipes</a></li></ul></li></ul></li>
<li><a href="#loaders"><strong>Loaders</strong></a><ul>
<li><a href="#file-loaders">File loaders</a></li>
<li><a href="#corpus-loaders">Corpus loaders</a></li>
<li><a href="#live-apis">Live APIs</a></li></ul></li>
<li><a href="#models"><strong>Models</strong></a><ul>
<li><a href="#model-api">Model API</a></li>
<li><a href="#model-entityrecognizer">EntityRecognizer</a></li>
<li><a href="#model-textclassifier">TextClassifier</a></li>
<li><a href="#model-patternmatcher">PatternMatcher</a></li></ul></li>
<li><a href="#user-api"><strong>API</strong></a><ul>
<li><a href="#top-level-functions">Top-level functions</a><ul>
<li><a href="#function-prodigyserve"><kbd>FUNCTION</kbd> serve</a></li>
<li><a href="#decorator-prodigyrecipe"><kbd>DECORATOR</kbd> @recipe</a></li>
<li><a href="#dict-prodigyrecipe-args"><kbd>DICT</kbd> recipe_args</a></li>
<li><a href="#function-prodigyget-recipe"><kbd>FUNCTION</kbd> get_recipe</a></li>
<li><a href="#function-prodigyset-recipe"><kbd>FUNCTION</kbd> set_recipe</a></li>
<li><a href="#function-prodigyget-config"><kbd>FUNCTION</kbd> get_config</a></li>
<li><a href="#function-prodigyget-stream"><kbd>FUNCTION</kbd> get_stream</a></li>
<li><a href="#function-prodigyget-loader"><kbd>FUNCTION</kbd> get_loader</a></li>
<li><a href="#function-prodigyset_hashes"><kbd>FUNCTION</kbd> set_hashes</a></li>
<li><a href="#function-prodigyget_schema"><kbd>FUNCTION</kbd> get_schema</a></li>
<li><a href="#function-prodigylog"><kbd>FUNCTION</kbd> log</a></li></ul></li>
<li><a href="#filters">Filters</a></li>
<li><a href="#sorters">Sorters</a></li>
<li><a href="#preprocess">Preprocess</a></li>
<li><a href="#controller">Controller</a></li>
<li><a href="#db">Database</a></li>
<li><a href="#rest-api">REST API</a><ul>
<li><a href="#get-project"><kbd>GET</kbd> /project</a></li>
<li><a href="#get-get-questions"><kbd>GET</kbd> /get_questions</a></li>
<li><a href="#post-give-answers"><kbd>POST</kbd> /give_answers</a></li></ul></li>
<li><a href="#entry-points">Entry Points</a></li></ul></li>
<li><a href="#formats"><strong>Formats</strong></a><ul>
<li><a href="#input-formats">Input formats</a><ul>
<li><a href="#jsonl">JSONL</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#csv">CSV</a></li>
<li><a href="#txt">TXT</a></li>
<li><a href="#comparison-files">Comparison files</a></li>
<li><a href="#match-patterns">Match patterns</a></li>
<li><a href="#images">Images</a></li></ul></li>
<li><a href="#annotation-task-formats">Annotation task formats</a><ul>
<li><a href="#annotated-task">Annotated task</a></li>
<li><a href="#text">Text</a></li>
<li><a href="#ner">NER</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#image">Image</a></li>
<li><a href="#object-detection-and-image-segmentation">Object Detection & Image Segmentation</a></li>
<li><a href="#classification">Classification</a></li>
<li><a href="#html">HTML</a></li>
<li><a href="#choice">Choice</a></li>
<li><a href="#compare">Compare</a></li>
<li><a href="#review">Review</a></li></ul></li></ul></li>
<li><a href="https://prodi.gy/docs/changelog"><strong>Changelog</strong></a></li>
</ol>
<h1 id="getting-started">Getting started</h1>
<h2 id="glossary">Glossary</h2>
<p>In this document, you'll come across a variety of terms specific to collecting
annotations with Prodigy. Here's a quick overview of the most common ones,
including a short description and links for more information.</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>annotation task</strong></td>
<td>A single question you're collecting feedback on from the annotator. For example, whether an entity is correct or whether a label applies to a text. Internally, annotation tasks are simple dictionaries containing the task properties like the text, the entity spans or the labels. Annotation tasks are also often referred to as "(annotation) examples".</td>
</tr>
<tr>
<td><strong>annotation interface</strong></td>
<td>The visual presentation of the annotation task. For example, text with highlighted entities, text with a category label, an image or a multiple-choice question. In the code, this is also often referred to as the <code>view_id</code>. <a href="#annotation-interfaces">See here</a> for a list of available options.</td>
</tr>
<tr>
<td><strong>dataset</strong></td>
<td>A named collection of annotated tasks. A new dataset is usually created for each project or experiment. The data can be exported or used to train a model later on.</td>
</tr>
<tr>
<td><strong>session</strong></td>
<td>A single annotation session, from starting the Prodigy server to exiting it. You can start multiple sessions that add data to the same dataset. The annotations of each sessions will also be stored as a separate dataset, named after the timestamp. This lets you inspect or delete individual sessions.</td>
</tr>
<tr>
<td><strong>database</strong></td>
<td>The <a href="#database-setup">storage backend</a> used to save your datasets. Prodigy currently supports SQLite (default), PostgreSQL and MySQL out-of-the-box, but also lets you integrate <a href="#database">custom solutions</a>.</td>
</tr>
<tr>
<td><strong>recipe</strong></td>
<td>A Python function that can be executed from the command line and starts the Prodigy server for a specific task – for example, correcting entity predictions or annotating text classification labels. Prodigy comes with a range of <a href="#recipes">built-in recipes</a>, but also allows you to <a href="#custom-recipes">write your own</a>.</td>
</tr>
<tr>
<td><strong>stream</strong></td>
<td>An iterable of annotation tasks, e.g. a generator that yields dictionaries. When you load in your data from a file or an API, Prodigy will convert it to a stream. Streams can be annotated in order, or be filtered and reordered to only show the most relevant examples.</td>
</tr>
<tr>
<td><strong>loader</strong></td>
<td>A function that loads data and returns a stream of annotation tasks. Prodigy comes with <a href="#file-loaders">built-in loaders</a> for the most common file types and a selection of live APIs, but you can also create your own functions.</td>
</tr>
<tr>
<td><strong>sorter</strong></td>
<td>A function that takes a stream of <code>(score, example)</code> tuples and yields the examples in a different order, based on the score. For example, to prefer uncertain or high scores. Prodigy comes with several <a href="#sorters">built-in sorters</a> that are used in the active learning-powered recipes.</td>
</tr>
<tr>
<td><strong>spaCy model</strong></td>
<td>One of the available pre-trained <a href="https://spacy.io/models">statistical language models</a> for spaCy. Models can be <a href="#spacy-models">installed</a> as Python packages and are avalable in different sizes and for different languages. They can be used as the basis for training your own model with Prodigy.</td>
</tr>
<tr>
<td><strong>active learning</strong></td>
<td>Using the model to select examples for annotation based on the current state of the model. Prodigy, the selection is usually based on examples the model is most uncertain about, i.e. the ones with a prediction closest to 50/50.</td>
</tr>
<tr>
<td><strong>batch training</strong></td>
<td>Training a new model from a dataset of collected annotations. Using larger batches of data and multiple iterations usually leads to better results than just updating the model in the loop. This is why you usually want to collect annotations first, and then use them to batch train a model from scratch.</td>
</tr>
</tbody>
</table>
<h2 id="installation">Installation</h2>
<p>The download link lets you choose between Prodigy wheels for all supported
platforms. It also includes the downloadable API documentation. You can install 
Prodigy by pointing pip to the local path of the respective wheel. Note that
Prodigy currently requires <strong>Python 3.5+</strong> and the latest
<a href="https://spacy.io/usage/v2"><strong>spaCy v2.0</strong></a>.</p>
<pre><code><span class="hljs-attribute">pip</span> install prodigy<span class="hljs-regexp">*.whl</span>
</code></pre>
<p>The above command will install the Prodigy package in your current environment,
create your Prodigy home directory and register the commands <code>prodigy</code> and <code>pgy</code>
(a shortcut). You can also add an installable wheel to your project's
<a href="https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format"><code>requirements.txt</code></a>
to install Prodigy on setup.</p>
<blockquote>
  <p><strong>About the "is not a supported wheel on this platform" error:</strong> Double-check
  that you've downloaded the correct wheel and make sure your version of pip is
  up to date. If it still doesn't work, check if the file name matches your
  platform (<code>distutils.util.get_platform()</code>) and rename the file if necessary.
  For more details, see <a href="https://github.com/MacPython/wiki/wiki/Spinning-wheels">this article on Python wheels</a>. Essentially,
  <strong>Python wheels are only archives</strong> containing the source files – so you can
  also just <strong>unpack the wheel</strong> and place the contained <code>prodigy</code> package in
  your <code>site-packages</code> directory.</p>
</blockquote>
<h3 id="cli-commands">CLI commands</h3>
<p>On installation, Prodigy will set up the alias commands <code>prodigy</code> and <code>pgy</code>. This
should work fine and out-of-the-box on most macOS and Linux setups. If not, you
can always run the commands by prefixing them with <code>python -m</code>, for example:
<code>python -m prodigy stats</code>. Alternatively, you can create your own alias, and
<a href="https://askubuntu.com/questions/17536/how-do-i-create-a-permanent-bash-alias">add it to your <code>.bashrc</code></a>
to make it permanent:</p>
<pre><code class="bash language-bash"><span class="hljs-built_in">alias</span> prodigy=<span class="hljs-string">"python -m prodigy"</span>
</code></pre>
<p>If you're using Windows, you can also create a custom activation script as a
<code>.ps1</code> file and run it in your environment, or add it to your PowerShell profile.
See <a href="https://support.prodi.gy/t/using-prodigy-commands-on-windows/102">this thread</a>
for more details.</p>
<pre><code class="powershell language-powershell"><span class="hljs-keyword">Function</span> global:pdgy { python -m prodigy <span class="hljs-variable">$args</span>}
<span class="hljs-keyword">Function</span> global:prodigy { python -m prodigy <span class="hljs-variable">$args</span>}
<span class="hljs-keyword">Function</span> global:spacy { python -m spacy <span class="hljs-variable">$args</span>}
</code></pre>
<h3 id="spacy-models">spaCy models</h3>
<p>To use Prodigy's built-in recipes for NER or Text Classification, you'll also
need to install a spaCy model – for example, the <a href="https://spacy.io/models/en#en_core_web_sm">small English model</a>,
<code>en_core_web_sm</code> (around 34 MB).</p>
<pre><code><span class="hljs-keyword">python</span> -m spacy download en_core_web_sm
</code></pre>
<blockquote>
  <p><strong>Using Prodigy with your own spaCy models:</strong> If you have trained your own
  spaCy model, you can load them into Prodigy using the path to the model
  directory. You can also use the
  <a href="https://spacy.io/api/cli#package"><code>spacy package</code> command</a> to turn
  it into a Python package, and install it in your current environment. All
  Prodigy recipes that allow a <code>spacy_model</code> argument can either take the name
  of an installed model package, or the path to a valid model package directory.
  Keep in mind that Prodigy uses spaCy v2.x, so if your model was trained with
  inputs from spaCy v1.x, you need to <strong>retrain your model</strong> with the new version.</p>
</blockquote>
<h2 id="configuration">Configuration</h2>
<p>When you first run Prodigy, it will create a folder <code>.prodigy</code> in your home
directory. By default, this will be the location where Prodigy looks for its
configuration file, <code>prodigy.json</code>. You can change this directory via the
environment variable <code>PRODIGY_HOME</code>:</p>
<pre><code><span class="hljs-attr">PRODIGY_HOME</span>=/custom/prodigy/home
</code></pre>
<p>When you run Prodigy, it will first check if a <strong>global configuration file</strong>
exists. It will also check the <strong>current working directory</strong> for a <code>prodigy.json</code>
or <code>.prodigy.json</code>. This allows you to overwrite specific settings on a
project-by-project basis.</p>
<h3 id="prodigyjson">prodigy.json</h3>
<pre><code class="json language-json">{
    <span class="hljs-attr">"theme"</span>: <span class="hljs-string">"basic"</span>,
    <span class="hljs-attr">"custom_theme"</span>: {},
    <span class="hljs-attr">"batch_size"</span>: <span class="hljs-number">10</span>,
    <span class="hljs-attr">"port"</span>: <span class="hljs-number">8080</span>,
    <span class="hljs-attr">"host"</span>: <span class="hljs-string">"localhost"</span>,
    <span class="hljs-attr">"cors"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"db"</span>: <span class="hljs-string">"sqlite"</span>,
    <span class="hljs-attr">"db_settings"</span>: {},
    <span class="hljs-attr">"api_keys"</span>: {},
    <span class="hljs-attr">"validate"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"auto_create"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"auto_exclude_current"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"instant_submit"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"feed_overlap"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"show_stats"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"hide_meta"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"show_flag"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"instructions"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"swipe"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"split_sents_threshold"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"diff_style"</span>: <span class="hljs-string">"words"</span>,
    <span class="hljs-attr">"html_template"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"global_css"</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">"javascript"</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">"writing_dir"</span>: <span class="hljs-string">"ltr"</span>,
    <span class="hljs-attr">"hide_true_newline_tokens"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"ner_manual_require_click"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"ner_manual_label_style"</span>: <span class="hljs-string">"list"</span>,
    <span class="hljs-attr">"choice_style"</span>: <span class="hljs-string">"single"</span>,
    <span class="hljs-attr">"choice_auto_accept"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"darken_image"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">"show_bounding_box_center"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"preview_bounding_boxes"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"shade_bounding_boxes"</span>: <span class="hljs-literal">false</span>
}
</code></pre>
<table>
<thead>
<tr>
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>theme</code></td>
<td>Name of UI theme to use.</td>
<td><code>"basic"</code></td>
</tr>
<tr>
<td><code>custom_theme</code></td>
<td>Custom UI theme overrides, keyed by name.</td>
<td><code>{}</code></td>
</tr>
<tr>
<td><code>batch_size</code></td>
<td>Number of tasks to return to and receive back from the web app at once. A low batch size means more frequent updates.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>port</code></td>
<td>Port to use for serving the web application. Can be overwritten by the <code>PRODIGY_PORT</code> environment variable.</td>
<td><code>8080</code></td>
</tr>
<tr>
<td><code>host</code></td>
<td>Host to use for serving the web application. Can be overwritten by the <code>PRODIGY_HOST</code> environment variable.</td>
<td><code>"localhost"</code></td>
</tr>
<tr>
<td><code>cors</code></td>
<td>Enable or disable <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">cross-origin resource sharing</a> (CORS) to allow the REST API to receive requests from other domains.</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>db</code></td>
<td>Name of database to use.</td>
<td><code>"sqlite"</code></td>
</tr>
<tr>
<td><code>db_settings</code></td>
<td>Additional settings for the respective databases.</td>
<td><code>{}</code></td>
</tr>
<tr>
<td><code>api_keys</code></td>
<td>Live API keys, keyed by <a href="#live-apis">API loader ID</a>.</td>
<td><code>{}</code></td>
</tr>
<tr>
<td><code>validate</code></td>
<td>Validate incoming tasks and raise an error with more details if the format is incorrect.</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>auto_create</code></td>
<td>Automatically create dataset if it doesn't exist in database.</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>auto_exclude_current</code></td>
<td>Automatically exclude examples already present in current dataset.</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>instant_submit</code></td>
<td>Instantly submit a task after it's answered in the app, skipping the history and immediately triggering the update callback if available.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>feed_overlap</code></td>
<td>Whether to send out each example once so it's annotated by <em>someone</em> (<code>false</code>) or whether to send out each example to every session (<code>true</code>, default). Should be used with <a href="#multi-user-sessions">custom user sessions</a> set via the app (via <code>/?session=user_name</code>).</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>show_stats</code></td>
<td>Show additional stats, like annotation decision counts, in the sidebar.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>hide_meta</code></td>
<td>Hide the meta information displayed on annotation cards.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>show_flag</code></td>
<td>Show a flag icon in the top right corner that lets you bookmark a task for later. Will add <code>"flagged": true</code> to the task.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>instructions</code></td>
<td>Path to a text file with instructions for the annotator (HTML allowed). Will be displayed as a help modal in the UI.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>swipe</code></td>
<td>Enable swipe gestures on touch devices (left for <kbd>accept</kbd>, right for <kbd>reject</kbd>).</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>split_sents_threshold</code></td>
<td>Minimum character length of a text to be split by the <code>split_sentences</code> preprocessor, mostly used in NER recipes. If <code>false</code>, all multi-sentence texts will be split.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>diff_style</code></td>
<td>Style to use for visual diffs. <code>"words"</code>, <code>"chars"</code> or <code>"sentences"</code>.</td>
<td><code>"words"</code></td>
</tr>
<tr>
<td><code>html_template</code></td>
<td>Optional <a href="https://mustache.github.io">Mustache</a> template to for content in the <code>html</code> annotation interface. All task properties are available as variables.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>global_css</code></td>
<td>CSS overrides added to the global scope. Takes a string value of the CSS code.</td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>javascript</code></td>
<td>Custom JavaScript added to the global scope. Takes a string value of the JavaScript code.</td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>writing_dir</code></td>
<td>Writing direction. Mostly important for manual text annotation interfaces.</td>
<td><code>ltr</code></td>
</tr>
<tr>
<td><code>hide_true_newline_tokens</code></td>
<td>Don't add real line breaks to tokens in manual annotation mode and only use <code>↵</code> symbols.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>ner_manual_require_click</code></td>
<td>In manual NER annotation mode, don't auto-add the selection as an entity and require an additional button click to convert the selection to an entity.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>ner_manual_label_style</code></td>
<td>Style of label set in manual NER mode. <code>"list"</code> for list of keyboard-accessible buttons or <code>"dropdown"</code>.</td>
<td><code>"list"</code></td>
</tr>
<tr>
<td><code>choice_style</code></td>
<td>Style of choice interface, "single" or "multiple".</td>
<td><code>"single"</code></td>
</tr>
<tr>
<td><code>choice_auto_accept</code></td>
<td>Automatically accept a single-choice option when selecting it – without having to click the <kbd>accept</kbd> button.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>darken_image</code></td>
<td>Darken an image in image detection or segmentation mode for better visibility of the coloured bounding boxes. For example, <code>0.25</code> will darken the image by 25%.</td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>show_bounding_box_center</code></td>
<td>Show a dot marking the center of a bounding box.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>preview_bounding_boxes</code></td>
<td>Also show image spans with <code>"hidden": true</code> in the background to preview other bounding boxes detected in the same image. This can help with making the annotation decision, because you get to preview potentially better analyses.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>shade_bounding_boxes</code></td>
<td>Display bounding boxes with an opaque background color. Mostly used for annotating larger image segments.</td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
<h3 id="using-prodigy-with-docker">Using Prodigy with Docker</h3>
<p>By default, Prodigy starts the web server on <code>localhost</code> and port <code>8080</code>. If
you're running Prodigy via a <a href="https://www.docker.com/">Docker</a> container or a
similar containerized environment, you'll have to set the host to <code>0.0.0.0</code>.
Simply edit your <code>prodigy.json</code> and add the following:</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"host"</span>: <span class="hljs-string">"0.0.0.0"</span>
}
</code></pre>
<p>See <a href="https://support.prodi.gy/t/oserror-errno-99-cannot-assign-requested-address/89">this thread</a>
for more details and background. The above approach should also work in other
environments if you come across the following error on startup:</p>
<pre><code>OSError: [Errno 99] Cannot assign requested<span class="hljs-built_in"> address
</span></code></pre>
<h2 id="database-setup">Database setup</h2>
<p>By default, Prodigy uses <a href="https://www.sqlite.org">SQLite</a> to store annotations
in a simple database file in your Prodigy home directory. If you want to use the
default database with its default settings, <strong>no further configuration is
required</strong> and you can start using Prodigy straight away. Alternatively, you can
choose to use Prodigy with <a href="https://www.mysql.com">MySQL</a> or
<a href="https://www.postgresql.org">PostgreSQL</a>, or write your own custom recipe to
plug in any other storage solution.</p>
<p>Prodigy uses the <a href="http://docs.peewee-orm.com/en/latest/"><code>peewee</code> package</a> to
manage the database integration. This gives you a lot of flexibility in terms of
setup and debugging, and allows you to use more advanced features via the
<a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html">Playhouse extension</a>.
For more details on custom database solutions, see the <a href="#db">database API documentation</a>.</p>
<blockquote>
  <p><strong>Why do I need a database?</strong> Prodigy uses the database to store all
  annotations by project and annotation session. Even if you're only using
  Prodigy with a model in the loop, you'll usually want a record of the
  collected annotations as a backup, or to use them as evaulation data. Prodigy
  is also very powerful without a model in the loop – for example to bootstrap
  word lists or collect feedback on the output of two models and generate
  evaluation data for machine translation or image classification.</p>
</blockquote>
<h3 id="sqlite">SQLite</h3>
<p>The default database option that stores all annotations in a flat
<a href="https://www.sqlite.org">SQLite</a> database file. Unless otherwise specified, the
database is created in the Prodigy home directory.</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"db"</span>: <span class="hljs-string">"sqlite"</span>,
    <span class="hljs-attr">"db_settings"</span>: {
        <span class="hljs-attr">"sqlite"</span>: {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"prodigy.db"</span>,
            <span class="hljs-attr">"path"</span>: <span class="hljs-string">"/custom/path"</span>
        }
    }
}
</code></pre>
<table>
<thead>
<tr>
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>Database file name. To only store the database in memory, use <code>:memory:</code>.</td>
<td><code>prodigy.db</code></td>
</tr>
<tr>
<td><code>path</code></td>
<td>Path to directory containing database file.</td>
<td><code>PRODIGY_HOME</code></td>
</tr>
<tr>
<td>…</td>
<td><a href="https://docs.python.org/2/library/sqlite3.html#sqlite3.connect"><code>sqlite3</code></a> connection parameters.</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="mysql">MySQL</h3>
<p>The settings for a MySQL database can take any <a href="http://mysql-python.sourceforge.net/MySQLdb.html#some-mysql-examples">MySQLdb</a> or <a href="https://github.com/PyMySQL/PyMySQL/blob/f08f01fe8a59e8acfb5f5add4a8fe874bec2a196/pymysql/connections.py#L494-L513">PyMySQL</a> connection parameters, depending on your database driver. Please note that
Prodigy won't install any database drivers, so you'll have to take care of this
step and install the driver of your choice.</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"db"</span>: <span class="hljs-string">"mysql"</span>,
    <span class="hljs-attr">"db_settings"</span>: {
        <span class="hljs-attr">"mysql"</span>: {
            <span class="hljs-attr">"host"</span>: <span class="hljs-string">"localhost"</span>,
            <span class="hljs-attr">"user"</span>: <span class="hljs-string">"username"</span>,
            <span class="hljs-attr">"passwd"</span>: <span class="hljs-string">"xxx"</span>,
            <span class="hljs-attr">"db"</span>: <span class="hljs-string">"prodigy"</span>
        }
    }
}
</code></pre>
<h3 id="postgresql">PostgreSQL</h3>
<p>The settings for a PostgreSQL database can take any
<a href="http://initd.org/psycopg/docs/module.html#psycopg2.connect"><code>psycopg2</code></a>
connection parameters.</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"db"</span>: <span class="hljs-string">"postgresql"</span>,
    <span class="hljs-attr">"db_settings"</span>: {
        <span class="hljs-attr">"postgresql"</span>: {
            <span class="hljs-attr">"dbname"</span>: <span class="hljs-string">"prodigy"</span>,
            <span class="hljs-attr">"user"</span>: <span class="hljs-string">"username"</span>,
            <span class="hljs-attr">"password"</span>: <span class="hljs-string">"xxx"</span>
        }
    }
}
</code></pre>
<h3 id="permissions-and-user-privileges">Permissions and user privileges</h3>
<p>When setting up your database integration, you might not want to give your
user permission to perform <em>all</em> operations. Prodigy uses the following
operations, some of which are optional and only required for certain commands
or initial setup:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th style="text-align:center;">Required</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SELECT</code></td>
<td style="text-align:center;">✅</td>
<td>Retrieving datasets and annotations.</td>
</tr>
<tr>
<td><code>INSERT</code></td>
<td style="text-align:center;">✅</td>
<td>Adding datasets and annotations.</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td style="text-align:center;">✅</td>
<td>Updating datasets and annotations.</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td style="text-align:center;">❎</td>
<td>Deleting datasets. Only used for the <code>prodigy drop</code> command, so permission can be omitted if you don't need this feature or prefer to delete records manually.</td>
</tr>
<tr>
<td><code>CREATE</code></td>
<td style="text-align:center;">❎</td>
<td>Creation of tables <code>Dataset</code>, <code>Example</code> and <code>Link</code>. Not required if you create them manually.</td>
</tr>
</tbody>
</table>
<p>To test your database connection, you can also write a simple Python script that
connects to Prodigy's database and performs the most important operations.
For more details, see the <a href="#db">database API docs</a> or check out
<a href="https://support.prodi.gy/t/what-db-privileges-does-prodigy-use/271">this thread on the support forum</a>.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.db <span class="hljs-keyword">import</span> connect   <span class="hljs-comment"># import the database connector</span>

db = connect()                              <span class="hljs-comment"># uses the settings in your prodigy.json</span>
db.add_dataset(<span class="hljs-string">'test_dataset'</span>)              <span class="hljs-comment"># add a dataset</span>
<span class="hljs-keyword">assert</span> <span class="hljs-string">'test_dataset'</span> <span class="hljs-keyword">in</span> db                 <span class="hljs-comment"># check that the dataset was added</span>
examples = [{<span class="hljs-string">'text'</span>: <span class="hljs-string">'hello world'</span>, <span class="hljs-string">'_task_hash'</span>: <span class="hljs-number">123</span>, <span class="hljs-string">'_input_hash'</span>: <span class="hljs-number">456</span>}]
db.add_examples(examples, [<span class="hljs-string">'test_dataset'</span>])  <span class="hljs-comment"># add examples to the dataset</span>
dataset = db.get_dataset(<span class="hljs-string">'test_dataset'</span>)     <span class="hljs-comment"># retrieve a dataset</span>
<span class="hljs-keyword">assert</span> len(dataset) == <span class="hljs-number">1</span>                     <span class="hljs-comment"># check that the examples were added</span>
</code></pre>
<h2 id="annotation-ui">Annotation UI</h2>
<p>The web app includes a range of built-in annotation interfaces, key bindings and
mobile swipe gestures and fully customisable UI themes. When you annotate a
task, the decision – accept, reject or ignore – is added to the task as the
<code>answer</code> key. The ten most recent decisions are shown in the sidebar and remain
editable, either by clicking "undo", or by selecting them from the history.
Annotated tasks are sent back to the REST API in batches. To save the current
progress manually, you can always hit the save button, or press
<kbd>command+s</kbd> or <kbd>ctrl+s</kbd>.</p>
<h3 id="annotation-interfaces">Annotation interfaces</h3>
<p>The web app lets you annotate a variety of different formats, including plain
text, named entities, categorisation, images and A/B comparisons, as well as
raw HTML.</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>ID</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Text</strong></td>
<td><code>text</code></td>
<td>Annotate plain text.</td>
</tr>
<tr>
<td><strong>Named Entity Recognition</strong></td>
<td><code>ner</code></td>
<td>Annotate named entities.</td>
</tr>
<tr>
<td><strong>Named Entity Recognition (manual)</strong></td>
<td><code>ner_manual</code></td>
<td>Annotate named entities by highlighting spans and selecting a label.</td>
</tr>
<tr>
<td><strong>Part-of-speech Tagging</strong></td>
<td><code>pos</code></td>
<td>Annotate part-of-speech tags.</td>
</tr>
<tr>
<td><strong>Part-of-speech Tagging (manual)</strong></td>
<td><code>pos_manual</code></td>
<td>Annotate part-of-speech tags by highlighting tokens and selecting a tag.</td>
</tr>
<tr>
<td><strong>Dependencies</strong></td>
<td><code>dep</code></td>
<td>Annotate (syntactic) dependencies and relations.</td>
</tr>
<tr>
<td><strong>Classification</strong></td>
<td><code>classification</code></td>
<td>Annotate labelled text or images.</td>
</tr>
<tr>
<td><strong>Image</strong></td>
<td><code>image</code></td>
<td>Annotate images and image segments.</td>
</tr>
<tr>
<td><strong>Image (manual)</strong></td>
<td><code>image_manual</code></td>
<td>Draw bounding boxes and polygon segments interactively.</td>
</tr>
<tr>
<td><strong>Choice</strong></td>
<td><code>choice</code></td>
<td>Annotate text, images, HTML or entities as multiple or single choice.</td>
</tr>
<tr>
<td><strong>Compare</strong></td>
<td><code>compare</code></td>
<td>Compare two examples and an optional baseline.</td>
</tr>
<tr>
<td><strong>Diff</strong></td>
<td><code>diff</code></td>
<td>Compare two text examples and an optional baseline via a visual diff.</td>
</tr>
<tr>
<td><strong>HTML</strong></td>
<td><code>html</code></td>
<td>Annotate any HTML content.</td>
</tr>
<tr>
<td><strong>Review</strong></td>
<td><code>review</code></td>
<td>Review existing annotations and resolve conflicts.</td>
</tr>
</tbody>
</table>
<h3 id="key-bindings-and-swipe-gestures">Key bindings and swipe gestures</h3>
<p>For more convenient annotation, you can use the following key bindings. You can
also enable swipe gestures on touch devices by setting <code>"swipe": true</code> in your
Prodigy configuration. This will let you swipe left for <kbd>accept</kbd> and
swipe right for <kbd>reject</kbd>.</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Description</th>
<th>Key options</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>accept</code></td>
<td>Accept an annotation.</td>
<td><kbd>a</kbd></td>
</tr>
<tr>
<td><code>reject</code></td>
<td>Reject an annotation.</td>
<td><kbd>x</kbd></td>
</tr>
<tr>
<td><code>ignore</code></td>
<td>Ignore an annotation.</td>
<td><kbd>space</kbd></td>
</tr>
<tr>
<td><code>undo</code></td>
<td>Undo the last annotation decision.</td>
<td><kbd>backspace</kbd>, <kbd>del</kbd></td>
</tr>
<tr>
<td><code>save</code></td>
<td>Save the current buffer of annotations.</td>
<td><kbd>command+s</kbd>, <kbd>ctrl+s</kbd></td>
</tr>
<tr>
<td><code>flag</code></td>
<td>Flag an example to "bookmark" it for later. Requires <code>"show_flag": true</code> to be set in the config.</td>
<td><kbd>f</kbd></td>
</tr>
<tr>
<td><code>help</code></td>
<td>Show annotation instructions, if available.</td>
<td><kbd>h</kbd></td>
</tr>
<tr>
<td><code>choice</code></td>
<td>Select a label in a manual interface or an option in a <a href="#choice"><code>choice</code></a> interface.</td>
<td><kbd>0</kbd> - <kbd>9</kbd></td>
</tr>
</tbody>
</table>
<p>The numbers <kbd>1</kbd> to <kbd>9</kbd> map to the options 1 through 9, and
<kbd>0</kbd> maps to option 10. For interfaces with more than 10 options, e.g.
manual annotation with larger label sets, the options 11 though 20
are available via <kbd>shift</kbd>+<kbd>num</kbd> and 21 through 30 via
<kbd>shift</kbd>+<kbd>alt</kbd>+<kbd>num</kbd>. For example, <kbd>shift</kbd>+<kbd>6</kbd> will select option 16,
and <kbd>shift</kbd>+<kbd>alt</kbd>+<kbd>0</kbd> option 30.</p>
<p>The <code>image_manual</code> interface also supports the following keyboard shortcuts:</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Description</th>
<th>Key options</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rect</code></td>
<td>Draw a rectangular shape.</td>
<td><kbd>r</kbd></td>
</tr>
<tr>
<td><code>polygon</code></td>
<td>Draw a polygon shape.</td>
<td><kbd>t</kbd>, <kbd>p</kbd></td>
</tr>
<tr>
<td><code>delete</code></td>
<td>Delete the selected shape.</td>
<td><kbd>d</kbd></td>
</tr>
<tr>
<td><code>reset</code></td>
<td>Reset the image to its original or previous state.</td>
<td><kbd>q</kbd></td>
</tr>
<tr>
<td><code>exit</code></td>
<td>Exit the current shape.</td>
<td><kbd>escape</kbd></td>
</tr>
</tbody>
</table>
<h3 id="themes">Themes</h3>
<p>Prodigy comes with three built-in theme options. To change the theme, simply
edit the <code>theme</code> setting in your configuration file and restart the web app.</p>
<blockquote>
  <p><strong>Theme options:</strong> <code>basic</code> (default), <code>eighties</code>, <code>spacy</code>, <code>brutalist</code></p>
</blockquote>
<p>You can also overwrite a range of colours and other layout properties under the
<code>custom_theme</code> setting to customise the look and feel of the application.</p>
<table>
<thead>
<tr>
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>accept</code></td>
<td>Color to visualise "accept" action.</td>
<td><code>#4fd364</code></td>
</tr>
<tr>
<td><code>reject</code></td>
<td>Color to visualise "reject" action.</td>
<td><code>#f74c4a</code></td>
</tr>
<tr>
<td><code>ignore</code></td>
<td>Color to visualise "ignore" action.</td>
<td><code>#b9b9b9</code></td>
</tr>
<tr>
<td><code>undo</code></td>
<td>Color to visualise "undo" action.</td>
<td><code>#b9b9b9</code></td>
</tr>
<tr>
<td><code>bgCard</code></td>
<td>Background of annotation card.</td>
<td><code>#ffffff</code></td>
</tr>
<tr>
<td><code>bgPage</code></td>
<td>Page background.</td>
<td><code>#f6f6f6</code></td>
</tr>
<tr>
<td><code>bgSidebar</code></td>
<td>General sidebar background.</td>
<td><code>#54606e</code></td>
</tr>
<tr>
<td><code>bgSidebarDark</code></td>
<td>Darker shade of sidebar color for header and accents.</td>
<td><code>#384451</code></td>
</tr>
<tr>
<td><code>bgHighlight</code></td>
<td>Background of highlighted text, e.g. entities.</td>
<td><code>#ffe184</code></td>
</tr>
<tr>
<td><code>bgLowlight</code></td>
<td>Background of subtly highlighted text, e.g. spans outside entities.</td>
<td><code>#d9d9d9</code></td>
</tr>
<tr>
<td><code>bgCardTitle</code></td>
<td>Background color of card title, e.g. text category.</td>
<td><code>#583fcf</code></td>
</tr>
<tr>
<td><code>bgProgress</code></td>
<td>Color of progress bar.</td>
<td><code>#ffffff</code></td>
</tr>
<tr>
<td><code>bgButton</code></td>
<td>Default annotation button background (disabled).</td>
<td><code>#b9b9b9</code></td>
</tr>
<tr>
<td><code>bgMeta</code></td>
<td>Background of card meta text.</td>
<td><code>#f6f6f6</code></td>
</tr>
<tr>
<td><code>colorText</code></td>
<td>General text color.</td>
<td><code>#444444</code></td>
</tr>
<tr>
<td><code>colorMeta</code></td>
<td>Text color of card meta text.</td>
<td><code>#939393</code></td>
</tr>
<tr>
<td><code>colorMessage</code></td>
<td>Text color of loading or error message if no card is displayed.</td>
<td><code>#6e6e6e</code></td>
</tr>
<tr>
<td><code>colorSidebar</code></td>
<td>Text color in sidebar.</td>
<td><code>#ffffff</code></td>
</tr>
<tr>
<td><code>colorSidebarHeadline</code></td>
<td>Text color of sidebar headlines.</td>
<td><code>#ffffff</code></td>
</tr>
<tr>
<td><code>colorSidebarLabel</code></td>
<td>Text color of of sidebar subheadlines, e.g. "Dataset".</td>
<td><code>#b9b9b9</code></td>
</tr>
<tr>
<td><code>colorButton</code></td>
<td>Icon color of annotation buttons.</td>
<td><code>#ffffff</code></td>
</tr>
<tr>
<td><code>colorHighlightLabel</code></td>
<td>Text color of label on highlighted text, e.g. entity label.</td>
<td><code>#583fcf</code></td>
</tr>
<tr>
<td><code>colorCardTitle</code></td>
<td>Text color of card title, e.g. category.</td>
<td><code>#ffffff</code></td>
</tr>
<tr>
<td><code>cardBorder</code></td>
<td>Border around card.</td>
<td><code>1px solid #ddd</code></td>
</tr>
<tr>
<td><code>cardShadow</code></td>
<td>Box shadow around card.</td>
<td><code>1px 1px 5px #ddd</code></td>
</tr>
<tr>
<td><code>cardBorderRadius</code></td>
<td>Border radius of card.</td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>sidebarBorder</code></td>
<td>Right border on sidebar.</td>
<td><code>none</code></td>
</tr>
<tr>
<td><code>labels</code></td>
<td>Custom highlight colors for labels, keyed by label name.</td>
<td>see below</td>
</tr>
</tbody>
</table>
<p>You can also customise a theme's fonts. The primary font is used for most text,
while the secondary font is used for headlines and labels.</p>
<table>
<thead>
<tr>
<th>Setting</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fontPrimary</code></td>
<td><code>"Lato", "Trebuchet MS", Roboto, Helvetica, Arial, sans-serif</code></td>
</tr>
<tr>
<td><code>fontSecondary</code></td>
<td><code>"Roboto Condensed", "Arial Narrow", sans-serif</code></td>
</tr>
</tbody>
</table>
<p>Themes can also overwrite some of the default text and container sizes:</p>
<table>
<thead>
<tr>
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>largeText</code></td>
<td>Large annotation card text (for short texts).</td>
<td><code>3.75rem</code></td>
</tr>
<tr>
<td><code>mediumText</code></td>
<td>Medium annotation card text (for medium texts).</td>
<td><code>2.4rem</code></td>
</tr>
<tr>
<td><code>smallText</code></td>
<td>Small annotation card text (for long texts).</td>
<td><code>2rem</code></td>
</tr>
<tr>
<td><code>buttonSize</code></td>
<td>Width and height of annotation buttons.</td>
<td><code>100px</code></td>
</tr>
<tr>
<td><code>progressHeight</code></td>
<td>Height of progress bar.</td>
<td><code>10px</code></td>
</tr>
<tr>
<td><code>cardMaxWidth</code></td>
<td>Maximum width of card.</td>
<td><code>675px</code></td>
</tr>
<tr>
<td><code>cardMinWidth</code></td>
<td>Minimal width of card.</td>
<td><code>300px</code></td>
</tr>
<tr>
<td><code>cardMinHeight</code></td>
<td>Minimal height of card.</td>
<td><code>100px</code></td>
</tr>
</tbody>
</table>
<p>Using the <code>labels</code> setting, a theme can specify custom highlight colors for
entity labels, part-of-speech tags etc. The colors will be used in both the
manual and non-manual interfaces. If no label color is set, the default
<code>bgHighlight</code> is used.</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"labels"</span>: {
        <span class="hljs-attr">"VERB"</span>: <span class="hljs-string">"#ffa9b8"</span>,
        <span class="hljs-attr">"NOUN"</span>: <span class="hljs-string">"#d1caff"</span>,
        <span class="hljs-attr">"PROPN"</span>: <span class="hljs-string">"#b4e8fc"</span>,
        <span class="hljs-attr">"ADJ"</span>: <span class="hljs-string">"#d3fe7d"</span>,
        <span class="hljs-attr">"ADV"</span>: <span class="hljs-string">"#9effd6"</span>,
        <span class="hljs-attr">"CONJ"</span>: <span class="hljs-string">"#ffa973"</span>,
        <span class="hljs-attr">"CCONJ"</span>: <span class="hljs-string">"#ffa973"</span>,
        <span class="hljs-attr">"PUNCT"</span>: <span class="hljs-string">"#ddd"</span>
    }
}
</code></pre>
<h3 id="custom-interfaces">Custom interfaces</h3>
<p>The <code>html</code> interface lets you render any plain HTML content, specified as the
<code>"html"</code> key in the annotation task.</p>
<pre><code class="json language-json">{ <span class="hljs-attr">"html"</span>: <span class="hljs-string">"&lt;img src='image.jpg'&gt;"</span> }
</code></pre>
<p>If you don't want to include the full markup in every task, you can also specify
a <code>html_template</code> in your global or the project's <code>prodigy.json</code> config file.
Prodigy uses <a href="https://mustache.github.io/">Mustache</a> to render the templates,
and makes all task properties are available as variables wrapped double curly
braces, e.g. <code>{{text}}</code>. Using HTML templates, you can visualise complex,
nested data without having to convert your input to match Prodigy's format.
When you annotate the task, Prodigy will simply add an <code>"answer"</code> key.</p>
<p>For example, let's say your annotation tasks look like this:</p>
<pre><code class="json language-json">{ <span class="hljs-attr">"title"</span>: <span class="hljs-string">"This is a title"</span>, <span class="hljs-attr">"photo"</span>: <span class="hljs-string">"image.jpg"</span>, <span class="hljs-attr">"data"</span>: { <span class="hljs-attr">"value"</span>: <span class="hljs-string">"This is a value"</span> } }
</code></pre>
<p>You could then write the following HTML template that has access to the task
properties as template variables, including the nested <code>data.value</code>:</p>
<pre><code class="html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{{data.value}}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"{{photo}}"</span> /&gt;</span>
</code></pre>
<p>All theme settings will also be available to the custom interface via the
<code>{{theme}}</code> variable. This lets you re-use Prodigy's colour and styles, without
having to hard-code them into your template. For example:</p>
<pre><code class="html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: {{theme.bgHighlight}}"</span>&gt;</span>{{text}}<span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span>
</code></pre>
<h3 id="javascript-and-css">JavaScript and CSS</h3>
<p>The <code>"global_css"</code> config setting lets you pass in a string of CSS overrides
that will be added to the global scope of the app. This lets you customise
styles beyond just the colour theme. As of v1.7.0, the Prodigy app exposes the
following human-readable class names:</p>
<table>
<thead>
<tr>
<th>Class name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.prodigy-root</code></td>
<td>Root element the app is rendered into.</td>
</tr>
<tr>
<td><code>.prodigy-buttons</code></td>
<td>Row of action buttons (accept, reject, ignore, undo).</td>
</tr>
<tr>
<td><code>.prodigy-container</code></td>
<td>Container of the annotation card (including title, content, meta).</td>
</tr>
<tr>
<td><code>.prodigy-content</code></td>
<td>Main content of the annotation card (containing the text or image).</td>
</tr>
<tr>
<td><code>.prodigy-title</code></td>
<td>Title bar containing the label(s).</td>
</tr>
<tr>
<td><code>.prodigy-meta</code></td>
<td>Meta information in the bottom right corner of the annotation card.</td>
</tr>
</tbody>
</table>
<p>In addition to the class names, the root element also exposes the
following data attributes:</p>
<table>
<thead>
<tr>
<th>Data attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data-prodigy-view-id</code></td>
<td>The name of the current interface, i.e. <code>"ner_manual"</code>.</td>
</tr>
<tr>
<td><code>data-prodigy-recipe</code></td>
<td>The name of the current recipe, i.e. <code>ner.manual</code> or <code>terms.teach</code>.</td>
</tr>
</tbody>
</table>
<p>This lets you implement custom styling specific to individual recipes or interfaces in the same global stylesheet. For example:</p>
<pre><code class="css language-css"><span class="hljs-selector-attr">[data-prodigy-view-id='ner_manual']</span> <span class="hljs-selector-class">.prodigy-title</span> {
    <span class="hljs-comment">/* Change background for the title/labels bar only in the manual NER interface */</span>
    <span class="hljs-attribute">background</span>: green;
}

<span class="hljs-selector-attr">[data-prodigy-recipe='custom-recipe']</span> <span class="hljs-selector-class">.prodigy-buttons</span> {
    <span class="hljs-comment">/* Hide the action buttons only in a custom recipe "custom-recipe"  */</span>
    <span class="hljs-attribute">display</span>: none;
}
</code></pre>
<p>As of v1.7.0, the <code>"javascript"</code> config setting is available across all
interfaces and lets you pass in a string of JavaScript code that will be
executed in the global scope. This lets you implement fully custom interfaces
that modify and interact with the current incoming task. The following internals
are exposed via the global <code>window.prodigy</code> object:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>viewId</code></td>
<td>string</td>
<td>The ID of the current interface, e.g. <code>'ner_manual'</code>.</td>
</tr>
<tr>
<td><code>config</code></td>
<td>object</td>
<td>The user configuration settings (e.g. <code>prodigy.json</code> plus recipe config).</td>
</tr>
<tr>
<td><code>content</code></td>
<td>object</td>
<td>The content of the current task (e.g. <code>{'text': 'Some text'}</code>).</td>
</tr>
<tr>
<td><code>theme</code></td>
<td>object</td>
<td>Theme variables like colors.</td>
</tr>
<tr>
<td><code>update</code></td>
<td>function</td>
<td>Update the current task. Takes an object with the updates and performs a shallow (!) merge.</td>
</tr>
<tr>
<td><code>answer</code></td>
<td>function</td>
<td>Answer the current task. Takes the string value of the answer, e.g. <code>'accept'</code>.</td>
</tr>
</tbody>
</table>
<p>Here's a simple example of a custom HTML template and JavaScript function that
allows toggling a button to change the task text from uppercase to lowercase,
and vice versa. For more details and inspiration, check out
<a href="https://support.prodi.gy/t/302/5">this thread on the forum</a>.</p>
<pre><code class="html language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"custom-button"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">"updateText()"</span>&gt;</span>
    👇 Text to uppercase
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{{text}}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
</code></pre>
<pre><code class="javascript language-javascript"><span class="hljs-keyword">let</span> upper = <span class="hljs-literal">false</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateText</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> text = <span class="hljs-built_in">window</span>.prodigy.content.text
    <span class="hljs-keyword">const</span> newText = !upper ? text.toUpperCase() : text.toLowerCase()
    <span class="hljs-built_in">window</span>.prodigy.update({ <span class="hljs-attr">text</span>: newText })
    upper = !upper
    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.custom-button'</span>).textContent =
        <span class="hljs-string">'👇 Text to '</span> + (upper ? <span class="hljs-string">'lowercase'</span> : <span class="hljs-string">'uppercase'</span>)
}
</code></pre>
<p>You can also listen to the following custom events fired by the app:</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>prodigymount</code></td>
<td>The app has mounted.</td>
</tr>
<tr>
<td><code>prodigyupdate</code></td>
<td>The UI was updated.</td>
</tr>
<tr>
<td><code>prodigyanswer</code></td>
<td>The user answered a question.</td>
</tr>
<tr>
<td><code>prodigyspanselected</code></td>
<td>A span was selected in the manual NER interface.</td>
</tr>
</tbody>
</table>
<p>Some events expose additional data via the <code>details</code> property. For example, the
<code>prodigyanswer</code> event exposes the task that was answered, as well as the answer
that was chosen (<code>'accept'</code>, <code>'reject'</code> or <code>'ignore'</code>).</p>
<pre><code class="javascript language-javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'prodigyanswer'</span>, event =&gt; {
    <span class="hljs-keyword">const</span> { answer, task } = event.detail
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The answer was: '</span>, answer)
})
</code></pre>
<h2 id="multi-user-sessions">Multi-user sessions</h2>
<blockquote>
  <p>This update was shipped in preparation of the upcoming
  <a href="https://support.prodi.gy/t/805">Prodigy Scale</a>, a full-featured, standalone
  application for large-scale multi-user annotation project powered by Prodigy.</p>
</blockquote>
<p>As of v1.7.0, Prodigy supports multiple named sessions within the <strong>same instance</strong>.
This makes it easier to implement custom multi-user workflows and controlling
the data that's sent out to individual annotators.</p>
<p>To create a custom named session, add <code>?session=xxx</code> to the annotation app URL.
For example, annotator Alex may access a running Prodigy project via
<code>http://localhost:8080/?session=alex</code>. Internally, this will request and
send back annotations with a session identifier consisting of the current dataset
name and the session ID – for example, <code>ner_person-alex</code>. Every time annotator
Alex labels examples for this dataset, their annotations will be associated
with this session identifier.</p>
<p>The <code>"feed_overlap"</code> setting in your <code>prodigy.json</code> or recipe config lets you
configure how examples should be sent out across multiple sessions. By default
(<code>true</code>), each example in the dataset will be sent out <strong>once for each session</strong>,
so you'll end up with overlapping annotations (e.g. one per example per annotator).
Setting <code>"feed_overlap"</code> to <code>false</code> will send out each example in the data
<strong>once</strong> to whoever is available. As a result, your data will have each example
labelled only once in total.</p>
<p>As of v1.8.0, the <code>PRODIGY_ALLOWED_SESSIONS</code> environment variable lets you
define comma-separated string names of sessions that are allowed to be set
via the app. For instance, <code>PRODIGY_ALLOWED_SESSIONS=alex,jo</code> would only allow
<code>?session=alex</code> and <code>?session=jo</code>, and other parameters would raise an error.</p>
<h2 id="importing-existing-data">Importing existing data</h2>
<p>To use existing annotations collected with other tools in Prodigy, you can
import them via the <a href="#manage-db-in"><code>db-in</code></a> command. You can import data of
all file formats <a href="#input-formats">supported by Prodigy</a>. However, JSON or JSONL
is usually recommended, as it gives you more flexibility. By default, all
examples will be set to <code>"answer": "accept"</code>. You can specify a different answer
using the <code>--answer</code> argument on the command line.</p>
<pre><code><span class="hljs-title">prodigy</span> db-<span class="hljs-keyword">in</span> my_dataset /path/to/<span class="hljs-class"><span class="hljs-keyword">data</span>.jsonl</span>
</code></pre>
<h3 id="tips-and-tricks">Tips and tricks</h3>
<ul>
<li><p>If you're planning to use Prodigy to add more annotations to your datasets,
or to train your model via the <code>batch-train</code> recipes, keep in mind that you'll
need <strong>both positive and negative examples</strong>. If your set only contains correct
examples with <code>"answer": "accept"</code>, your model may learn that "everything is
'accept'", which will give you a great accuracy of 100% on your data – but
pretty useless results in general. Ideally, you should add roughly the same
amount of examples for <code>"accept"</code> and <code>"rejects"</code>. In many cases, it's easy to
create incorrect examples programmatically to at least cover testing purposes –
for example by swapping out the labels, or randomly modifying other example
properties.</p></li>
<li><p>When you're labelling and classifying data with Prodigy, remember that you're
always collecting <code>"accept"</code> and <code>"reject"</code> feedback <strong>on the entire task,
including the label</strong>. Prodigy also assumes that labels are <strong>not mutually
exclusive</strong>. This means that you might have to adjust your labeling
scheme so Prodigy's models can interpret it correctly. For example, if your
existing dataset classifies movie reviews and uses the label <code>0</code> for "negative"
and <code>1</code> for "positive", you could set <code>"label": "POSITIVE"</code> on all examples,
and mark the ones with a <code>1</code> label as <code>"answer": "accept"</code>, and the ones with a
<code>0</code> label as <code>"answer": "reject"</code>. If you don't change the label, Prodigy will
treat <code>"0"</code> and <code>"1"</code> as independent categories,</p></li>
</ul>
<h2 id="debugging-and-logging">Debugging and logging</h2>
<p>If Prodigy raises an error, or you come across unexpected results, it's often
helpful to run the debugging mode to keep track of what's happening, and how
your data flows through the application. Prodigy uses the
<a href="https://docs.python.org/2/library/logging.html"><code>logging</code> module</a> to provide
logging information across the different components. The logging mode can be
set as the environment variable <code>PRODIGY_LOGGING</code>. Both logging modes log the
same events, but differ in the verbosity of the output.</p>
<table>
<thead>
<tr>
<th>Logging mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>basic</code></td>
<td>Only log timestamp and event description with most important data.</td>
</tr>
<tr>
<td><code>verbose</code></td>
<td>Also log additional information, like annotation data and function arguments, if available.</td>
</tr>
</tbody>
</table>
<pre><code class="bash language-bash">PRODIGY_LOGGING=basic prodigy ner.teach my_dataset en_core_web_sm my_data.jsonl
PRODIGY_LOGGING=verbose prodigy.textcat.teach my_dataset en_core_web_sm my_data.jsonl
</code></pre>
<p><details>
    <summary>Example output of <code>PRODIGY_LOGGING=basic</code></summary></p>
<pre><code>$ PRODIGY_LOGGING=basic prodigy ner.teach test en_core_web_sm <span class="hljs-string">"rats"</span> --api guardian
<span class="hljs-symbol">
13:</span><span class="hljs-number">11</span>:<span class="hljs-number">39</span> - <span class="hljs-string">DB:</span> Connecting to database <span class="hljs-string">'sqlite'</span>
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span> - <span class="hljs-string">RECIPE:</span> Calling recipe <span class="hljs-string">'ner.teach'</span>
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span> - <span class="hljs-string">RECIPE:</span> Starting recipe ner.teach
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span> - <span class="hljs-string">LOADER:</span> Loading stream from API <span class="hljs-string">'guardian'</span>
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span> - <span class="hljs-string">LOADER:</span> Using API <span class="hljs-string">'guardian'</span> with query <span class="hljs-string">'rats'</span>
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">42</span> - <span class="hljs-string">MODEL:</span> Added sentence boundary detector to model pipeline
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">43</span> - <span class="hljs-string">RECIPE:</span> Initialised EntityRecognizer with model en_core_web_sm
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">43</span> - <span class="hljs-string">SORTER:</span> Resort stream to prefer uncertain examples (bias <span class="hljs-number">0.8</span>)
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">43</span> - <span class="hljs-string">PREPROCESS:</span> Splitting sentences
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">44</span> - <span class="hljs-string">MODEL:</span> Predicting spans <span class="hljs-keyword">for</span> batch (batch size <span class="hljs-number">64</span>)
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">44</span> - <span class="hljs-string">Model:</span> Sorting batch by entity type (batch size <span class="hljs-number">32</span>)
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">44</span> - <span class="hljs-string">CONTROLLER:</span> Initialising from recipe
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">44</span> - <span class="hljs-string">DB:</span> Loading dataset <span class="hljs-string">'test'</span> (<span class="hljs-number">168</span> examples)
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">44</span> - <span class="hljs-string">DB:</span> Creating dataset <span class="hljs-string">'2017-11-20_13-07-44'</span>

  ✨  Starting the web server at <span class="hljs-string">http:</span><span class="hljs-comment">//localhost:8080 ...</span>
  Open the app <span class="hljs-keyword">in</span> your browser and start annotating!
<span class="hljs-symbol">
13:</span><span class="hljs-number">11</span>:<span class="hljs-number">59</span> - <span class="hljs-string">GET:</span> /project
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">59</span> - <span class="hljs-string">GET:</span> /get_questions
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">59</span> - <span class="hljs-string">CONTROLLER:</span> Iterating over stream
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">59</span> - <span class="hljs-string">Model:</span> Sorting batch by entity type (batch size <span class="hljs-number">32</span>)
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">59</span> - <span class="hljs-string">CONTROLLER:</span> Returning a batch of tasks from the queue
<span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">59</span> - <span class="hljs-string">RESPONSE:</span> /get_questions (<span class="hljs-number">10</span> examples)
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">07</span> - <span class="hljs-string">GET:</span> /get_questions
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">07</span> - <span class="hljs-string">CONTROLLER:</span> Returning a batch of tasks from the queue
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">07</span> - <span class="hljs-string">RESPONSE:</span> /get_questions (<span class="hljs-number">10</span> examples)
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">07</span> - <span class="hljs-string">POST:</span> /give_answers (received <span class="hljs-number">7</span>)
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">07</span> - <span class="hljs-string">CONTROLLER:</span> Receiving <span class="hljs-number">7</span> answers
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">07</span> - <span class="hljs-string">MODEL:</span> Updating with <span class="hljs-number">7</span> examples
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span> - <span class="hljs-string">MODEL:</span> Updated model (loss <span class="hljs-number">0.0172</span>)
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span> - <span class="hljs-string">PROGRESS:</span> Estimating progress of <span class="hljs-number">0.0909</span>
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span> - <span class="hljs-string">DB:</span> Getting dataset <span class="hljs-string">'test'</span>
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span> - <span class="hljs-string">DB:</span> Getting dataset <span class="hljs-string">'2017-11-20_13-07-44'</span>
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span> - <span class="hljs-string">DB:</span> Added <span class="hljs-number">7</span> examples to <span class="hljs-number">2</span> datasets
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span> - <span class="hljs-string">CONTROLLER:</span> Added <span class="hljs-number">7</span> answers to dataset <span class="hljs-string">'test'</span> <span class="hljs-keyword">in</span> database SQLite
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span> - <span class="hljs-string">RESPONSE:</span> /give_answers
<span class="hljs-number">13</span>:<span class="hljs-number">12</span>:<span class="hljs-number">11</span> - <span class="hljs-string">DB:</span> Saving database

Saved <span class="hljs-number">7</span> annotations to database SQLite
<span class="hljs-string">Dataset:</span> test
Session <span class="hljs-string">ID:</span> <span class="hljs-number">2017</span><span class="hljs-number">-11</span><span class="hljs-number">-20</span>_13<span class="hljs-number">-07</span><span class="hljs-number">-44</span>
</code></pre>
<p></details></p>
<blockquote>
  <p><strong>⚠️ Important note:</strong> <code>verbose</code> logging will output the full examples that
  are being processed by Prodigy, which can potentially produce very large logs.
  So you'll usually want to write the log to a file. Also keep in mind that by
  the <code>verbose</code> mode will log anything that's passed around the application,
  including <strong>potentially sensitive data</strong> like the database credentials, API
  keys and all annotation example data.</p>
</blockquote>
<h3 id="custom-logging">Custom logging</h3>
<p>If you're developing custom recipes, you can use Prodigy's <code>log</code> helper function
to add your own entries to the log. The <code>log</code> function takes the following
arguments:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message</code></td>
<td>unicode</td>
<td>The basic message to display, e.g. "RECIPE: Starting recipe ner.teach".</td>
</tr>
<tr>
<td><code>details</code></td>
<td>-</td>
<td>Optional details to log only in <code>verbose</code> mode.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python"><span class="hljs-keyword">import</span> prodigy

<span class="hljs-meta">@prodigy.recipe('custom-recipe')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_custom_recipe</span><span class="hljs-params">(dataset, stream_arg)</span>:</span>
    progigy.log(<span class="hljs-string">"RECIPE: Starting recipe custom-recipe"</span>, locals())
    stream = load_my_stream(stream_arg)
    prodigy.log(<span class="hljs-string">"RECIPE: Loaded stream with argument {}"</span>.format(stream_arg))
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'dataset'</span>: dataset,
        <span class="hljs-string">'stream'</span>: stream
    }
</code></pre>
<h2 id="environment-variables">Environment variables</h2>
<p>Prodigy lets you set the following environment variables:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PRODIGY_HOME</code></td>
<td>Use a custom path for the Prodigy home directory. Defaults to the equivalent of <code>~/.prodigy</code>.</td>
</tr>
<tr>
<td><code>PRODIGY_LOGGING</code></td>
<td>Enable logging. Values can be either <code>basic</code> (simple logging) or <code>verbose</code> (more details per entry).</td>
</tr>
<tr>
<td><code>PRODIGY_PORT</code></td>
<td>Overwrite the port used to serve the Prodigy app and REST API. Supersedes the settings in the global, local and recipe-specific config.</td>
</tr>
<tr>
<td><code>PRODIGY_HOST</code></td>
<td>Overwrite the host used to serve the Prodigy app and REST API. Supersedes the settings in the global, local and recipe-specific config.</td>
</tr>
<tr>
<td><code>PRODIGY_ALLOWED_SESSIONS</code></td>
<td>Define comma-separated string names of <a href="#multi-user-sessions">multi-user session</a> names that are allowed in the app.</td>
</tr>
<tr>
<td><code>PRODIGY_BASIC_AUTH_USER</code></td>
<td>Add super basic authentication to the app. String user name to accept.</td>
</tr>
<tr>
<td><code>PRODIGY_BASIC_AUTH_PASS</code></td>
<td>Add super basic authentication to the app. String password to accept.</td>
</tr>
</tbody>
</table>
<h1 id="workflows--videos">Workflows &amp; Videos</h1>
<h2 id="workflow-first-steps"><kbd>WORKFLOW</kbd> First steps</h2>
<p>This workflow shows how to get started with Prodigy, run your first annotation
project and train and use a model updated with the annotations. It also includes
sample data sets and a quick guide on how to load in your own data.</p>
<p><a href="https://prodi.gy/docs/workflow-first-steps"><strong>READ WORKFLOW</strong></a></p>
<h2 id="video-new-entity-type"><kbd>VIDEO</kbd> Training a new entity type on Reddit comments</h2>
<p>In this video we'll show you how to use Prodigy to train a <strong>phrase recognition system</strong> for a new concept by adding a <strong>new entity label</strong> to spaCy's named entity recognizer. Specifically, we'll train a model to detect references to drugs and pharmaceuticals, using text from one of the largest online communities of US opiate users on Reddit. Millions of words of conversation from this community are publicly available, going back a number of years. This seems like a good resource for investigating questions about the emergence and progress of the opioid crisis.</p>
<p><a href="https://prodi.gy/docs/video-new-entity-type"><strong>WATCH VIDEO</strong></a></p>
<h2 id="video-faq1"><kbd>VIDEO</kbd> Tips &amp; tricks for NLP, annotation &amp; training</h2>
<p>In this video, we'll be talking about a few frequently asked questions and share some general tips and tricks for how to structure your NLP annotation projects, how to design your label schemes and how to solve common problems.</p>
<p><a href="https://prodi.gy/docs/video-faq1"><strong>WATCH VIDEO</strong></a></p>
<h2 id="workflow-text-classification"><kbd>WORKFLOW</kbd> Text Classification</h2>
<p>This workflow explains how to train and evaluate a text classification system
using Prodigy. You can use this tutorial to solve problems such as <strong>sentiment
analysis</strong>, chatbot <strong>intent detection</strong>, and <strong>flagging abusive or fraudulent
behaviours</strong>. In this example, we'll stream issue titles from the GitHub API,
and create a system to predict whether an issue is about the project
documentation.</p>
<p><a href="https://prodi.gy/docs/workflow-text-classification"><strong>READ WORKFLOW</strong></a></p>
<h2 id="workflow-named-entity-recognition"><kbd>WORKFLOW</kbd> Named Entity Recognition</h2>
<p>In this example, we'll improve the accuracy of spaCy's default English model at
recovering <strong>product or brand names in social media</strong>, a common requirement for
online reputation management and tracking what opinions people are expressing.
In around 30 minutes, we created over 1000 annotations from the Reddit comments
corpus. After retraining with the new annotations, we did a quick analysis of
500 comments from the following month.</p>
<p><a href="https://prodi.gy/docs/workflow-named-entity-recognition"><strong>READ WORKFLOW</strong></a></p>
<h2 id="workflow-custom-recipes"><kbd>WORKFLOW</kbd> Custom Recipes</h2>
<p>A Prodigy recipe is a Python function that can be run via the command line.
Prodigy comes with lots of useful recipes, and it's very easy to write your own.
All you have to do is wrapp the <code>@prodigy.recipe</code> decorator around your function.
This workflow shows how custom recipes work in detail, including an example of
<strong>classifying customer feedback sentiment</strong> using the <code>choice</code> interface.</p>
<p><a href="https://prodi.gy/docs/workflow-custom-recipes"><strong>READ WORKFLOW</strong></a></p>
<h1 id="recipes">Recipes</h1>
<p>A Prodigy recipe is a Python function that can be run via the command line.
Prodigy comes with lots of useful recipes, and it's very easy to write your own.
All you have to do is add the <code>@prodigy.recipe</code> decorator around your function,
which should return a dictionary of components, specifying the stream of
examples, and optionally the web view, database, progress calculator, and
callbacks on update, load and exit.</p>
<p>Recipes don't have to start the web server – you can also use the recipe
decorator as a quick way to make your Python function into a command-line
utility. This is useful for batch training, database management, and data
exploration.</p>
<h2 id="built-in-recipes">Built-in recipes</h2>
<p>Prodigy comes with built-in recipes of the following categories:</p>
<table>
<thead>
<tr>
<th>Recipe type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>TEACH</kbd></td>
<td>Interactively annotate and train models.</td>
</tr>
<tr>
<td><kbd>EVALUATE</kbd></td>
<td>Test models and interactively create evaluation sets.</td>
</tr>
<tr>
<td><kbd>EXPLORE</kbd></td>
<td>Preview data and annotations from the command line.</td>
</tr>
<tr>
<td><kbd>MANAGE</kbd></td>
<td>Organise your data sets and annotation projects.</td>
</tr>
</tbody>
</table>
<p>For more examples of the recipes and their output, see the
<a href="https://prodi.gy/docs/recipes">Prodigy website</a>.</p>
<h3 id="teach-nerteach"><kbd>TEACH</kbd> ner.teach</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>ner</code></li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a>, a label to annotate and a text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Training, updating and correcting NER models.</li>
  </ul>
</blockquote>
<p>Collect the best possible training data for a named entity recognition
model with the model in the loop. Based on your annotations, Prodigy will
decide which questions to ask next. All annotations will be stored in the
database. You can stream in examples from a file or a live API. If no
stream source is specified, it defaults to <code>sys.stdin</code>, letting you
pipe through data via the <code>pipe</code> recipe or your own scripts.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.teach</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclude]</span> <span class="hljs-selector-attr">[--unsegmented]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to annotate. Accepts single label or comma-separated list. If not set, all available labels will be returned.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--patterns</code>, <code>-pt</code></td>
<td>unicode (option)</td>
<td>Optional path to match patterns file to filter out entities.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy ner<span class="hljs-selector-class">.teach</span> [dataset] en_core_web_sm tweets<span class="hljs-selector-class">.jsonl</span> --<span class="hljs-selector-tag">label</span> PERSON
prodigy ner<span class="hljs-selector-class">.teach</span> [dataset] en_core_web_sm <span class="hljs-string">"White House"</span> --api twitter --<span class="hljs-selector-tag">label</span> PERSON
</code></pre>
<h3 id="teach-nerbatch-train"><kbd>TEACH</kbd> ner.batch-train</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained or blank <a href="https://spacy.io/models">spaCy model</a> and a dataset containing NER annotations.</li>
  <li><strong>Saves:</strong> Updated model.</li>
  <li><strong>Use cases:</strong> Training, updating and correcting NER models.</li>
  </ul>
</blockquote>
<p>Batch train a Named Entity Recognition model from annotations. Prodigy
will export the best result to the output directory, and include a JSONL
file of the training and evaluation examples. You can either supply a
dataset ID containing the evaluation data, or choose to split off a
percentage of examples for evaluation. By default, 50% is split off for
datasets under 1000 examples, and 20% for sets over 1000 examples. The
<code>factor</code> specifies the portion of examples to train on – e.g.
<code>0.2</code> for 20% or <code>1</code> for all examples. If no output directory
is specified, no model will be exported.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.batch-train</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[--output]</span> <span class="hljs-selector-attr">[--factor]</span> <span class="hljs-selector-attr">[--dropout]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--batch-size]</span> <span class="hljs-selector-attr">[--beam-width]</span> <span class="hljs-selector-attr">[--eval-id]</span> <span class="hljs-selector-attr">[--eval-split]</span> <span class="hljs-selector-attr">[--unsegmented]</span> <span class="hljs-selector-attr">[--no-missing]</span> <span class="hljs-selector-attr">[--silent]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--output</code>, <code>-o</code></td>
<td>unicode (positional)</td>
<td>Path to output directory.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to train. Accepts single label or comma-separated list. If not set, all available labels will be used.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--factor</code>, <code>-f</code></td>
<td>float (option)</td>
<td>Portion of the examples to train on, e.g <code>0.5</code> for 50%.</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>--dropout</code>, <code>-d</code></td>
<td>float (option)</td>
<td>Dropout rate.</td>
<td><code>0.2</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of training iterations.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-b</code></td>
<td>int (option)</td>
<td>Training batch size.</td>
<td><code>32</code></td>
</tr>
<tr>
<td><code>--beam-width</code>, <code>-bw</code></td>
<td>int (option)</td>
<td>Training beam width.</td>
<td><code>16</code></td>
</tr>
<tr>
<td><code>--init-tok2vec</code>, <code>-t2v</code></td>
<td>unicode (option)</td>
<td>Path to <a href="https://spacy.io/api/cli#pretrain">pretrained weights</a> for the token-to-vector parts of the model. Experimental.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-id</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Optional ID of a dataset containing evaluation examples.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-split</code>, <code>-es</code></td>
<td>float (option)</td>
<td>If no evaluation ID is provided, split off a portion of the training examples for evaluation. Defaults to <code>0.2</code> for over 1000 training examples.</td>
<td><code>0.5</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--no-missing</code>, <code>-NM</code></td>
<td>bool (flag)</td>
<td>Assume all correct spans are in the gold annotation, and any spans not in the gold annotation are incorrect.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--silent</code>, <code>-S</code></td>
<td>bool (flag)</td>
<td>Don't print any updates.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-nertrain-curve"><kbd>EVALUATE</kbd> ner.train-curve</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained or blank <a href="https://spacy.io/models">spaCy model</a> and a dataset containing NER annotations.</li>
  <li><strong>Saves:</strong> -</li>
  <li><strong>Use cases:</strong> Evaluating a trained NER model, determine the quality of the annotations.</li>
  </ul>
</blockquote>
<p>Batch-train models with different portions of the training examples and
print the accuracy figures and accuracy improvements. <code>n_samples</code>
is the numer of sample models to train at different stages. For instance,
<code>10</code> will train models for 10% of the examples, 20%, 30% and so on.
This recipe is useful to determine the quality of the collected
annotations, and whether more training examples will improve the
accuracy. As a rule of thumb, if accuracy improves within the last 25%,
training with more examples will likely result in better accuracy.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.train-curve</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--dropout]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--batch-size]</span> <span class="hljs-selector-attr">[--eval-id]</span> <span class="hljs-selector-attr">[--eval-split]</span> <span class="hljs-selector-attr">[--unsegmented]</span> <span class="hljs-selector-attr">[--no-missing]</span> <span class="hljs-selector-attr">[--n-samples]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to train. Accepts single label or comma-separated list. If not set, all available labels will be used.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--dropout</code>, <code>-d</code></td>
<td>float (option)</td>
<td>Dropout rate.</td>
<td><code>0.2</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of training iterations.</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-b</code></td>
<td>int (option)</td>
<td>Training batch size.</td>
<td><code>32</code></td>
</tr>
<tr>
<td><code>--beam-width</code>, <code>-bw</code></td>
<td>int (option)</td>
<td>Training beam width.</td>
<td><code>16</code></td>
</tr>
<tr>
<td><code>--init-tok2vec</code>, <code>-t2v</code></td>
<td>unicode (option)</td>
<td>Path to <a href="https://spacy.io/api/cli#pretrain">pretrained weights</a> for the token-to-vector parts of the model. Experimental.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-id</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Optional ID of a dataset containing evaluation examples.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-split</code>, <code>-es</code></td>
<td>float (option)</td>
<td>If no evaluation ID is provided, split off a portion of the training examples for evaluation. Defaults to <code>0.2</code> for over 1000 training examples.</td>
<td><code>0.5</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--no-missing</code>, <code>-NM</code></td>
<td>bool (flag)</td>
<td>Assume all correct spans are in the gold annotation, and any spans not in the gold annotation are incorrect.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--n-samples</code>, <code>-ns</code></td>
<td>int (option)</td>
<td>Number of samples to train, e.g. <code>10</code> for results at 10%, 20% and so on.</td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="teach-nermatch"><kbd>TEACH</kbd> ner.match</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>ner</code></li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a> for tokenization, a patterns file (e.g. created using <code>terms.to-patterns</code>) and a text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Matching and annotating entity examples based on large terminology lists, e.g. to train a new entity type.</li>
  </ul>
</blockquote>
<p>Suggest phrases that match a given patterns file, and mark whether they are
examples of the entity you're interested in. The patterns file can include
exact strings or token patterns for use with spaCy's <code>Matcher</code> class. You can
bootstrap match patterns by creating a terminology list using the <code>terms.teach</code>
recipe and converting it using <code>terms.to-patterns</code>.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.match</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--patterns]</span> <span class="hljs-selector-attr">[--exclude]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--patterns</code>, <code>-pt</code></td>
<td>unicode (option)</td>
<td>Path to patterns file.</td>
<td>-</td>
</tr>
<tr>
<td><code>--resume</code>, <code>-R</code></td>
<td>bool (flag)</td>
<td>Resume from existing dataset and update matcher model accordingly.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy ner<span class="hljs-selector-class">.match</span> [dataset] en_core_web_sm tweets<span class="hljs-selector-class">.jsonl</span> --patterns patterns<span class="hljs-selector-class">.jsonl</span>
</code></pre>
<h3 id="teach-nermanual"><kbd>TEACH</kbd> ner.manual</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>ner_manual</code></li>
  <li><strong>Requirements:</strong> A pre-trained or blank <a href="https://spacy.io/models">spaCy model</a> for tokenization, a set of labels to annotate and a text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Manually labelling entity spans.</li>
  </ul>
</blockquote>
<p>Mark entity spans in a text by highlighting them and selecting the respective
labels. The model is used to tokenize the text to allow less sensitive
highlighting, since the token boundaries are used to set the entity spans. The
label set can be defined as a comma-separated list on the command line or as
a path to a text file with one label per line. If no labels are specified,
Prodigy will check if labels are present in the model. This recipe does not require an entity recognizer, and doesn't do any active
learning.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.manual</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclude]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>One or more labels to annotate. Supports a comma-separated list or a path to a file with one label per line. If no labels are set, Prodigy will check the model for available labels.</td>
<td>-</td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy ner<span class="hljs-selector-class">.manual</span> [dataset] en_core_web_sm tweets<span class="hljs-selector-class">.jsonl</span> --<span class="hljs-selector-tag">label</span> PERSON,ORG
prodigy ner<span class="hljs-selector-class">.manual</span> [dataset] en_core_web_sm <span class="hljs-string">"White House"</span> --api guardian --<span class="hljs-selector-tag">label</span> news_labels<span class="hljs-selector-class">.txt</span>
</code></pre>
<h3 id="teach-nermake-gold"><kbd>TEACH</kbd> ner.make-gold</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>ner_manual</code></li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a> for tokenization and NER, a set of labels to annotate and a text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Creating gold data for Named Entity Recognition.</li>
  </ul>
</blockquote>
<p>Create gold-standard data for NER by correcting the model's suggestions. The
spaCy model will be used to predict entities contained in the text, which the
annotator can remove and correct if necessary.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.make-gold</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclude]</span> <span class="hljs-selector-attr">[--unsegmented]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>One or more labels to annotate. Supports a comma-separated list or a path to a file with one label per line. If no labels are set, Prodigy will check the model for available labels.</td>
<td>-</td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="teach-nersilver-to-gold"><kbd>TEACH</kbd> ner.silver-to-gold</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>ner_manual</code></li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a> for tokenization and NER, a set of labels to annotate and one or more datasets with binary accept/reject annotations.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Creating gold-standard data with no missing values based on existing binary datasets.</li>
  </ul>
</blockquote>
<p>Take existing "silver" datasets with binary accept/reject annotations, merge the
annotations to find the best possible analysis given the constraints defined in
the annotations, and manually edit it to create a perfect and complete "gold"
dataset.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.silver-to-gold</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[silver_datasets]</span> <span class="hljs-selector-attr">[spacy_model]</span>  <span class="hljs-selector-attr">[--label]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID to save annotations to.</td>
<td>-</td>
</tr>
<tr>
<td><code>silver_datasets</code></td>
<td>unicode (positional)</td>
<td>Comma-separated names of existing binary datasets to convert.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>One or more labels to annotate. Supports a comma-separated list or a path to a file with one label per line. If no labels are set, Prodigy will check the model for available labels.</td>
<td>-</td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-nereval"><kbd>EVALUATE</kbd> ner.eval</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>ner</code></li>
  <li><strong>Requirements:</strong> A trained NER model.</li>
  <li><strong>Saves:</strong> Annotations to the database.</li>
  <li><strong>Use cases:</strong> Evaluating a trained NER model, create an evaluation set.</li>
  </ul>
</blockquote>
<pre><code>prodigy ner.eval [<span class="hljs-string">dataset</span>] [<span class="hljs-string">spacy_model</span>] [<span class="hljs-string">source</span>] [<span class="hljs-string">--api</span>] [<span class="hljs-string">--loader</span>] [<span class="hljs-string">--label</span>] [<span class="hljs-string">--exclude</span>][<span class="hljs-symbol">--unsegmented</span>] [--whole-text]
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID (of evaluation set).</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to evaluate. Accepts single label or comma-separated list. If not set, all available labels will be returned.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--whole-text</code>, <code>-W</code></td>
<td>bool (flag)</td>
<td>Make accept/reject refer to whole text whole text (not single span).</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-nereval-ab"><kbd>EVALUATE</kbd> ner.eval-ab</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>compare</code></li>
  <li><strong>Requirements:</strong> Two models to compare (e.g. before and after training).</li>
  <li><strong>Saves:</strong> Annotations to the database.</li>
  <li><strong>Use cases:</strong> Evaluating a trained NER model and comparing it to the baseline.</li>
  </ul>
</blockquote>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.eval-ab</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[before_model]</span> <span class="hljs-selector-attr">[after_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclude]</span> <span class="hljs-selector-attr">[--unsegmented]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID (of evaluation set).</td>
<td>-</td>
</tr>
<tr>
<td><code>before_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>after_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to evaluate. Accepts single label or comma-separated list. If not set, all available labels will be returned.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="explore-nerprint-best"><kbd>EXPLORE</kbd> ner.print-best</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a> and a dataset containing raw text.</li>
  <li><strong>Use cases:</strong> Predicting the highest-scoring parse for examples in a dataset. Piping the output forward for annotation with <code>ner.manual</code>.</li>
  </ul>
</blockquote>
<p>Predict the highest-scoring parse for examples in a dataset. Scores are
calculated using the annotations in the dataset, and the statistical model.
The annotation examples will be printed on the command line, so they can be
piped forward to a recipe like <code>mark</code>, or saved to a file.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.print-best</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID of set containing raw text examples, e.g. created via <a href="#manage-db-in"><code>db-in</code></a>. Will be updated with the annotations.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="explore-nerprint-stream"><kbd>EXPLORE</kbd> ner.print-stream</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A text source or API.</li>
  <li><strong>Use cases:</strong> Inspecting a stream and the model's predictions on the data.</li>
  </ul>
</blockquote>
<p>Pretty-print annotations from a stream on the command line. When piping the
stream to <code>less</code> to view it, remember to use the <code>-R</code> flag so that the color
displays correctly. If no stream source is specified, it defaults to <code>sys.stdin</code>,
letting you pipe through data via the <a href="#manage-pipe"><code>pipe</code> recipe</a>.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.print-stream</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to print. Accepts single label or comma-separated list. If not set, all available labels will be shown.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="explore-nerprint-dataset"><kbd>EXPLORE</kbd> ner.print-dataset</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A dataset containing annotations.</li>
  <li><strong>Use cases:</strong> Inspecting collected annotations.</li>
  </ul>
</blockquote>
<p>Pretty-print annotations from a given dataset on the command line. When piping
the stream to <code>less</code> to view it, remember to use the <code>-R</code> flag so that the color
displays correctly.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.print-dataset</span> <span class="hljs-selector-attr">[dataset]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID (of evaluation set).</td>
<td>-</td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="manage-nergold-to-spacy"><kbd>MANAGE</kbd> ner.gold-to-spacy</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A dataset created by <code>ner.manual</code> or <code>ner.make-gold</code>, containing texts and <code>"spans"</code>.</li>
  <li><strong>Saves:</strong> Converted annotations in JSONL format.</li>
  <li><strong>Use cases:</strong> Converting entity annotations to spaCy's training format.</li>
  </ul>
</blockquote>
<p>Convert a dataset of gold-standard NER annotations (created with <code>ner.manual</code>
or <code>ner.make-gold</code>) into training data for spaCy. See the
<a href="https://spacy.io/usage/training#ner">spaCy training documentation</a> for more
details. Will export a JSONL file with one entry per line:</p>
<pre><code class="json language-json">[<span class="hljs-string">"I like London"</span>, { <span class="hljs-attr">"entities"</span>: [[<span class="hljs-number">7</span>, <span class="hljs-number">13</span>, <span class="hljs-string">"LOC"</span>]] }]
</code></pre>
<p>Exporting annotations in <a href="https://spacy.io/api/annotation#biluo">BILUO</a> format
requires a spaCy model for tokenization, which should be the same model used
during annotation. The BILUO data will look like this:</p>
<pre><code class="json language-json">[<span class="hljs-string">"I like London"</span>, [<span class="hljs-string">"O"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"U-LOC"</span>, <span class="hljs-string">"O"</span>]]
</code></pre>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.gold-to-spacy</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[output_file]</span> <span class="hljs-selector-attr">[--spacy-model]</span> <span class="hljs-selector-attr">[--biluo]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>output_file</code></td>
<td>unicode (positonal)</td>
<td>Path to output file. If not set, the converted annotations will be printed to <code>stdout</code>.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--spacy-model</code>, <code>-sm</code></td>
<td>unicode (option)</td>
<td>Optional spaCy model for tokenization, required for BILUO mode.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--biluo</code>, <code>-B</code></td>
<td>bool (flag)</td>
<td>Encode labelled spans into per-token BILUO tags.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="manage-neriob-to-gold"><kbd>MANAGE</kbd> ner.iob-to-gold</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> An input file with line per text, with whitespace-delimited tokens.</li>
  <li><strong>Saves:</strong> Converted annotations in JSONL format.</li>
  <li><strong>Use cases:</strong> Converting a file with IOB tags into JSONL format for use in Prodigy.</li>
  </ul>
</blockquote>
<p>Convert a file with IOB tags into JSONL format for use in Prodigy. The input
format should have one line per text, with whitespace-delimited tokens. Each
token should have two or more fields delimited by the <code>|</code> character. The first
field should be the text, and the last an IOB or IOB2 formatted NER tag. If
no output is specified, the output is printed to <code>stdout</code>.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">ner</span><span class="hljs-selector-class">.iob-to-gold</span> <span class="hljs-selector-attr">[input_file]</span> <span class="hljs-selector-attr">[output_file]</span>
</code></pre>
<h4 id="example-iob">Example (IOB)</h4>
<pre><code class="html language-html">Then|RB|O ,|,|O the|DT|I-MISC International|NNP|I-MISC became|VBD|O polarised|VBN|O
</code></pre>
<h4 id="example-iob2">Example (IOB2):</h4>
<pre><code class="html language-html">Then|RB|O ,|,|O the|DT|B-MISC International|NNP|I-MISC became|VBD|O polarised|VBN|O
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>input_file</code></td>
<td>Path (positional)</td>
<td>Path to IOB or IOB2 formatted NER annotations</td>
<td>-</td>
</tr>
<tr>
<td><code>output_file</code></td>
<td>Path (positonal)</td>
<td>Path of the output <code>.jsonl</code> file. If not set, the output is printed to <code>stdout</code>.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="teach-textcatteach"><kbd>TEACH</kbd> textcat.teach</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>classification</code></li>
  <li><strong>Requirements:</strong> One or more labels to annotate and a loadable text source, e.g. a file or an API.</li>
  <li><strong>Saves:</strong> Updated model, annotations to database</li>
  <li><strong>Use cases:</strong> Training, updating and correcting text classification models</li>
  </ul>
</blockquote>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">textcat</span><span class="hljs-selector-class">.teach</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--patterns]</span> <span class="hljs-selector-attr">[--exclude]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Category label to apply.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>--patterns</code>, <code>-pt</code></td>
<td>unicode (option)</td>
<td>Optional path to match patterns file to filter out examples containing terms and phrases.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--long-text</code>, <code>-L</code></td>
<td>bool (flag)</td>
<td>Enable "long" mode for long text classification. Will extract most relevant sentences from long examples and display them in context.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--init-tok2vec</code>, <code>-t2v</code></td>
<td>unicode (option)</td>
<td>Path to <a href="https://spacy.io/api/cli#pretrain">pretrained weights</a> for the token-to-vector parts of the model. Experimental.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy teach-textcat [dataset] en_core_web_sm articles.jsonl --<span class="hljs-keyword">label</span><span class="bash"> POSITIVE
</span>prodigy teach-textcat [dataset] en_core_web_sm <span class="hljs-string">"Silicon Valley"</span> --<span class="hljs-keyword">label</span><span class="bash"> POSITIVE --api nyt
</span></code></pre>
<h3 id="teach-textcatmanual"><kbd>TEACH</kbd> textcat.manual</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>choice</code> / <code>classification</code> (single categories)</li>
  <li><strong>Requirements:</strong> One or more labels to annotate and a loadable text source, e.g. a file or an API.</li>
  <li><strong>Saves:</strong> Annotations to the database</li>
  <li><strong>Use cases:</strong> Select one or more categories that apply to a text</li>
  </ul>
</blockquote>
<p>Manually annotate categories that apply to a text. If more than one label is
specified, categories are added as multiple choice options. If the <code>--exclusive</code>
flag is set, categories become mutually exclusive, meaning that only one can be
selected during annotation.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">textcat</span><span class="hljs-selector-class">.manual</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclusive]</span> <span class="hljs-selector-attr">[--exclude]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Category label to apply.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>--exclusive, -E</code></td>
<td>bool (flag)</td>
<td>Treat labels as mutually exclusive. If not set, an example may have multiple correct classes.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="teach-textcatbatch-train"><kbd>TEACH</kbd> textcat.batch-train</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a> and a dataset containing annotations.</li>
  <li><strong>Saves:</strong> Updated model</li>
  <li><strong>Use cases:</strong> Training, updating and correcting text classification models</li>
  </ul>
</blockquote>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">textcat</span><span class="hljs-selector-class">.batch-train</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[input_model]</span> <span class="hljs-selector-attr">[--output]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--factor]</span> <span class="hljs-selector-attr">[--dropout]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--batch-size]</span> <span class="hljs-selector-attr">[--eval-id]</span> <span class="hljs-selector-attr">[--eval-split]</span> <span class="hljs-selector-attr">[--exclusive]</span> <span class="hljs-selector-attr">[--silent]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>input_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--output</code>, <code>-o</code></td>
<td>unicode (option)</td>
<td>Path to output directory.</td>
<td>-</td>
</tr>
<tr>
<td><code>--lang</code>, <code>-la</code></td>
<td>unicode (option)</td>
<td>Optional ISO code of language to use if starting with blank model (instead of input model). Needs to be a <a href="http://spacy.io/usage/models#languages">language supported by spaCy</a>, or <code>'xx'</code> for language-neutral.</td>
<td><code>'en'</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Category label to apply.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>--factor</code>, <code>-f</code></td>
<td>float (option)</td>
<td>Portion of the examples to train on, e.g <code>0.5</code> for 50%.</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>--dropout</code>, <code>-d</code></td>
<td>float (option)</td>
<td>Dropout rate.</td>
<td><code>0.2</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of training iterations.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-b</code></td>
<td>int (option)</td>
<td>Training batch size.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>--init-tok2vec</code>, <code>-t2v</code></td>
<td>unicode (option)</td>
<td>Path to <a href="https://spacy.io/api/cli#pretrain">pretrained weights</a> for the token-to-vector parts of the model. Experimental.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-id</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Optional ID of a dataset containing evaluation examples.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-split</code>, <code>-es</code></td>
<td>float (option)</td>
<td>If no evaluation ID is provided, split off a portion of the training examples for evaluation. Defaults to <code>0.2</code> for over 1000 training examples.</td>
<td><code>0.5</code></td>
</tr>
<tr>
<td><code>--exclusive, -E</code></td>
<td>bool (flag)</td>
<td>Treat labels as mutually exclusive. If not set, an example may have multiple correct classes.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--silent</code>, <code>-S</code></td>
<td>bool (flag)</td>
<td>Don't print any updates.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-textcattrain-curve"><kbd>EVALUATE</kbd> textcat.train-curve</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a> and a dataset containing annotations.</li>
  <li><strong>Saves:</strong> -</li>
  <li><strong>Use cases:</strong> Evaluating a trained text classification model, determine the quality of the annotations</li>
  </ul>
</blockquote>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">textcat</span><span class="hljs-selector-class">.train-curve</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[input_model]</span> <span class="hljs-selector-attr">[--dropout]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--batch-size]</span> <span class="hljs-selector-attr">[--eval-id]</span> <span class="hljs-selector-attr">[--eval-split]</span> <span class="hljs-selector-attr">[--n-samples]</span> <span class="hljs-selector-attr">[--exclusive]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>input_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--dropout</code>, <code>-d</code></td>
<td>float (option)</td>
<td>Dropout rate.</td>
<td><code>0.2</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of training iterations.</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-b</code></td>
<td>int (option)</td>
<td>Training batch size.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>--init-tok2vec</code>, <code>-t2v</code></td>
<td>unicode (option)</td>
<td>Path to <a href="https://spacy.io/api/cli#pretrain">pretrained weights</a> for the token-to-vector parts of the model. Experimental.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-id</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Optional ID of a dataset containing evaluation examples.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-split</code>, <code>-es</code></td>
<td>float (option)</td>
<td>If no evaluation ID is provided, split off a portion of the training examples for evaluation. Defaults to <code>0.2</code> for over 1000 training examples.</td>
<td><code>0.5</code></td>
</tr>
<tr>
<td><code>--n-samples</code>, <code>-ns</code></td>
<td>int (option)</td>
<td>Number of samples to train, e.g. <code>10</code> for results at 10%, 20% and so on.</td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>--exclusive, -E</code></td>
<td>bool (flag)</td>
<td>Treat labels as mutually exclusive. If not set, an example may have multiple correct classes.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-textcateval"><kbd>EVALUATE</kbd> textcat.eval</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>classification</code></li>
  <li><strong>Requirements:</strong> A trained text classification model.</li>
  <li><strong>Saves:</strong> Annotations to the database.</li>
  <li><strong>Use cases:</strong> Evaluating a trained text classification model, create an evaluation set.</li>
  </ul>
</blockquote>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">textcat</span><span class="hljs-selector-class">.eval</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[input_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span>  <span class="hljs-selector-attr">[--exclude]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID (of evaluation set).</td>
<td>-</td>
</tr>
<tr>
<td><code>input_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Category label to apply.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="explore-textcatprint-stream"><kbd>EXPLORE</kbd> textcat.print-stream</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A text source or API.</li>
  <li><strong>Use cases:</strong> Inspecting a stream and the model's predictions on the data.</li>
  </ul>
</blockquote>
<p>Pretty-print annotations from a stream on the command line. When piping the
stream to <code>less</code> to view it, remember to use the <code>-R</code> flag so that the color
displays correctly. If no stream source is specified, it defaults to <code>sys.stdin</code>,
letting you pipe through data via the <a href="#manage-pipe"><code>pipe</code> recipe</a>.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">textcat</span><span class="hljs-selector-class">.print-stream</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID (of evaluation set).</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Category label to apply.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="explore-textcatprint-dataset"><kbd>EXPLORE</kbd> textcat.print-dataset</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A dataset containing annotations.</li>
  <li><strong>Use cases:</strong> Inspecting collected annotations.</li>
  </ul>
</blockquote>
<p>Pretty-print annotations from a given dataset on the command line. When piping
the stream to <code>less</code> to view it, remember to use the <code>-R</code> flag so that the color
displays correctly.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">textcat</span><span class="hljs-selector-class">.print-dataset</span> <span class="hljs-selector-attr">[dataset]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID (of evaluation set).</td>
<td>-</td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="teach-posteach"><kbd>TEACH</kbd> pos.teach</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>pos</code></li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a>, one or more part-of-speech tags to annotate and a text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Training, updating and correcting part-of-speech tagging models.</li>
  </ul>
</blockquote>
<p>Collect the best possible training data for a part-of-speech tagging
model with the model in the loop. Based on your annotations, Prodigy will
decide which questions to ask next. All annotations will be stored in the
database. You can stream in examples from a file or a live API. If no
stream source is specified, it defaults to <code>sys.stdin</code>, letting you
pipe through data via the <code>pipe</code> recipe or your own scripts.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">pos</span><span class="hljs-selector-class">.teach</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclude]</span> <span class="hljs-selector-attr">[--unsegmented]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to annotate. Accepts single label or comma-separated list. If not set, all available labels will be returned.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--tag-map</code>, <code>tm</code></td>
<td>unicode / Path (option)</td>
<td>Path to JSON <a href="https://spacy.io/usage/adding-languages#tag-map">mapping table for POS tags</a>. Read from the spaCy tagger model if not provided.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy pos<span class="hljs-selector-class">.teach</span> [dataset] en_core_web_sm tweets<span class="hljs-selector-class">.jsonl</span> --<span class="hljs-selector-tag">label</span> VERB,NOUN
</code></pre>
<h3 id="teach-posbatch-train"><kbd>TEACH</kbd> pos.batch-train</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained or blank <a href="https://spacy.io/models">spaCy model</a> and a dataset containing part-of-speech annotations.</li>
  <li><strong>Saves:</strong> Updated model.</li>
  <li><strong>Use cases:</strong> Training, updating and correcting part-of-speech tagging models.</li>
  </ul>
</blockquote>
<p>Batch train a part-of-speech tagging model from annotations. Prodigy
will export the best result to the output directory, and include a JSONL
file of the training and evaluation examples. You can either supply a
dataset ID containing the evaluation data, or choose to split off a
percentage of examples for evaluation. By default, 50% is split off for
datasets under 1000 examples, and 20% for sets over 1000 examples. The
<code>factor</code> specifies the portion of examples to train on – e.g.
<code>0.2</code> for 20% or <code>1</code> for all examples. If no output directory
is specified, no model will be exported.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">pos</span><span class="hljs-selector-class">.batch-train</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[--output]</span> <span class="hljs-selector-attr">[--factor]</span> <span class="hljs-selector-attr">[--dropout]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--batch-size]</span> <span class="hljs-selector-attr">[--beam-width]</span> <span class="hljs-selector-attr">[--eval-id]</span> <span class="hljs-selector-attr">[--eval-split]</span> <span class="hljs-selector-attr">[--silent]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--output</code>, <code>-o</code></td>
<td>unicode (positional)</td>
<td>Path to output directory.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to train. Accepts single label or comma-separated list. If not set, all available labels will be used.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--tag-map</code>, <code>tm</code></td>
<td>unicode / Path (option)</td>
<td>Path to JSON <a href="https://spacy.io/usage/adding-languages#tag-map">mapping table for POS tags</a>. Read from the spaCy tagger model if not provided.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--factor</code>, <code>-f</code></td>
<td>float (option)</td>
<td>Portion of the examples to train on, e.g <code>0.5</code> for 50%.</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>--dropout</code>, <code>-d</code></td>
<td>float (option)</td>
<td>Dropout rate.</td>
<td><code>0.2</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of training iterations.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-b</code></td>
<td>int (option)</td>
<td>Training batch size.</td>
<td><code>32</code></td>
</tr>
<tr>
<td><code>--beam-width</code>, <code>-bw</code></td>
<td>int (option)</td>
<td>Training beam width.</td>
<td><code>16</code></td>
</tr>
<tr>
<td><code>--eval-id</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Optional ID of a dataset containing evaluation examples.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-split</code>, <code>-es</code></td>
<td>float (option)</td>
<td>If no evaluation ID is provided, split off a portion of the training examples for evaluation. Defaults to <code>0.2</code> for over 1000 training examples.</td>
<td><code>0.5</code></td>
</tr>
<tr>
<td><code>--silent</code>, <code>-S</code></td>
<td>bool (flag)</td>
<td>Don't print any updates.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-postrain-curve"><kbd>EVALUATE</kbd> pos.train-curve</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained or blank <a href="https://spacy.io/models">spaCy model</a> and a dataset containing part-of-speech annotations.</li>
  <li><strong>Saves:</strong> -</li>
  <li><strong>Use cases:</strong> Evaluating a trained part-of-speech tagging model, determine the quality of the annotations.</li>
  </ul>
</blockquote>
<p>Batch-train models with different portions of the training examples and
print the accuracy figures and accuracy improvements. <code>n_samples</code>
is the numer of sample models to train at different stages. For instance,
<code>10</code> will train models for 10% of the examples, 20%, 30% and so on.
This recipe is useful to determine the quality of the collected
annotations, and whether more training examples will improve the
accuracy. As a rule of thumb, if accuracy improves within the last 25%,
training with more examples will likely result in better accuracy.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">pos</span><span class="hljs-selector-class">.train-curve</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--dropout]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--batch-size]</span> <span class="hljs-selector-attr">[--eval-id]</span> <span class="hljs-selector-attr">[--eval-split]</span> <span class="hljs-selector-attr">[--n-samples]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to train. Accepts single label or comma-separated list. If not set, all available labels will be used.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--tag-map</code>, <code>tm</code></td>
<td>unicode / Path (option)</td>
<td>Path to JSON <a href="https://spacy.io/usage/adding-languages#tag-map">mapping table for POS tags</a>. Read from the spaCy tagger model if not provided.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--dropout</code>, <code>-d</code></td>
<td>float (option)</td>
<td>Dropout rate.</td>
<td><code>0.2</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of training iterations.</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-b</code></td>
<td>int (option)</td>
<td>Training batch size.</td>
<td><code>32</code></td>
</tr>
<tr>
<td><code>--beam-width</code>, <code>-bw</code></td>
<td>int (option)</td>
<td>Training beam width.</td>
<td><code>16</code></td>
</tr>
<tr>
<td><code>--eval-id</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Optional ID of a dataset containing evaluation examples.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-split</code>, <code>-es</code></td>
<td>float (option)</td>
<td>If no evaluation ID is provided, split off a portion of the training examples for evaluation. Defaults to <code>0.2</code> for over 1000 training examples.</td>
<td><code>0.5</code></td>
</tr>
<tr>
<td><code>--n-samples</code>, <code>-ns</code></td>
<td>int (option)</td>
<td>Number of samples to train, e.g. <code>10</code> for results at 10%, 20% and so on.</td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-posmake-gold"><kbd>EVALUATE</kbd> pos.make-gold</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>ner_manual</code></li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a> for tokenization and tagging, a set of labels to annotate and a text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Creating gold data for part-of-speech tagging.</li>
  </ul>
</blockquote>
<p>Create gold-standard data for part-of-speech tagging by correcting the model's
suggestions. The spaCy model will be used to predict part-of-speech tags, which
annotator can remove and correct if necessary. It's often more efficient to
focus on a few labels at a time, instead of annotating all labels jointly. The
<code>--fine-grained</code> flag enables annotation of the fine-grained tags (i.e.
<code>Token.tag_</code> instead of <code>Token.pos_</code>). Note that this can lead to unexpected
results and very long tags for some language models that use fine-grained tags
composed of morphological features, like spaCy's default Italian or Dutch models.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">pos</span><span class="hljs-selector-class">.make-gold</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclude]</span> <span class="hljs-selector-attr">[--unsegmented]</span> <span class="hljs-selector-attr">[--fine-grained]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>One or more tags to annotate. Supports a comma-separated list or a path to a file with one label per line. If not set, all tags are shown.</td>
<td>-</td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--fine-grained</code>, <code>-FG</code></td>
<td>bool (flag)</td>
<td>Use fine-grained part-of-speech tags, i.e. <code>Token.tag_</code> instead of <code>Token.pos_</code>.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="manage-posgold-to-spacy"><kbd>MANAGE</kbd> pos.gold-to-spacy</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A dataset created by <code>pos.make-gold</code>, containing texts and <code>"spans"</code> for each part-of-speech tag.</li>
  <li><strong>Saves:</strong> Converted annotations in JSONL format.</li>
  <li><strong>Use cases:</strong> Converting POS annotations to spaCy's training format.</li>
  </ul>
</blockquote>
<p>Convert a dataset with annotated part-of-speech tags to the format required to
train spaCy's part-of-speech tagger. The data will be formatted in the "simple
training style" and can be read in and used to update the tagger. See the
<a href="https://spacy.io/usage/training#example-train-tagger">spaCy training documentation</a>
for more details. The recipe will export a JSONL file with one entry per line
that looks like this:</p>
<pre><code class="json language-json">[<span class="hljs-string">"I like eggs"</span>, { <span class="hljs-attr">"tags"</span>: [<span class="hljs-string">"NOUN"</span>, <span class="hljs-string">"VERB"</span>, <span class="hljs-string">"NOUN"</span>] }][
    (<span class="hljs-string">"I like ripe bananas"</span>, { <span class="hljs-attr">"tags"</span>: [<span class="hljs-string">"NOUN"</span>, <span class="hljs-string">"VERB"</span>, <span class="hljs-string">"-"</span>, <span class="hljs-string">"NOUN"</span>] })
]
</code></pre>
<p>spaCy's tagger can also be updated from partial annotations, which will be
exported with the tag <code>-</code>. Note that this converter currently expects all
annotated spans to be single tokens. If multiple tokens were highlighted as one
tag, the example will be skipped.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">pos</span><span class="hljs-selector-class">.gold-to-spacy</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[output_file]</span> <span class="hljs-selector-attr">[--fine-grained]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>output_file</code></td>
<td>unicode (positonal)</td>
<td>Path to output file. If not set, the converted annotations will be printed to <code>stdout</code>.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--fine-grained</code>, <code>-FG</code></td>
<td>bool (flag)</td>
<td>Save annotations as fine-grained part-of-speech tags, i.e. to train <code>Token.tag_</code> instead of <code>Token.pos_</code>.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="teach-depteach"><kbd>TEACH</kbd> dep.teach</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>dep</code></li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a>, one or more labels to annotate and a text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Training, updating and correcting dependency parsing models.</li>
  </ul>
</blockquote>
<p>Collect the best possible training data for a dependency parsing
model with the model in the loop. Based on your annotations, Prodigy will
decide which questions to ask next. All annotations will be stored in the
database. You can stream in examples from a file or a live API. If no
stream source is specified, it defaults to <code>sys.stdin</code>, letting you
pipe through data via the <code>pipe</code> recipe or your own scripts.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">dep</span><span class="hljs-selector-class">.teach</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclude]</span> <span class="hljs-selector-attr">[--unsegmented]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to annotate. Accepts single label or comma-separated list. If not set, all available labels will be returned.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--unsegmented</code>, <code>-U</code></td>
<td>bool (flag)</td>
<td>Don't split sentences.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy dep<span class="hljs-selector-class">.teach</span> [dataset] en_core_web_sm tweets<span class="hljs-selector-class">.jsonl</span>
</code></pre>
<h3 id="teach-depbatch-train"><kbd>TEACH</kbd> dep.batch-train</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained or blank <a href="https://spacy.io/models">spaCy model</a> and a dataset containing dependency annotations.</li>
  <li><strong>Saves:</strong> Updated model.</li>
  <li><strong>Use cases:</strong> Training, updating and correcting dependency parsing models.</li>
  </ul>
</blockquote>
<p>Batch train a dependency parsing model from annotations. Prodigy
will export the best result to the output directory, and include a JSONL
file of the training and evaluation examples. You can either supply a
dataset ID containing the evaluation data, or choose to split off a
percentage of examples for evaluation. By default, 50% is split off for
datasets under 1000 examples, and 20% for sets over 1000 examples. The
<code>factor</code> specifies the portion of examples to train on – e.g.
<code>0.2</code> for 20% or <code>1</code> for all examples. If no output directory
is specified, no model will be exported.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">dep</span><span class="hljs-selector-class">.batch-train</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[--output]</span> <span class="hljs-selector-attr">[--factor]</span> <span class="hljs-selector-attr">[--dropout]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--batch-size]</span> <span class="hljs-selector-attr">[--beam-width]</span> <span class="hljs-selector-attr">[--eval-id]</span> <span class="hljs-selector-attr">[--eval-split]</span> <span class="hljs-selector-attr">[--silent]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--output</code>, <code>-o</code></td>
<td>unicode (positional)</td>
<td>Path to output directory.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to train. Accepts single label or comma-separated list. If not set, all available labels will be used.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--factor</code>, <code>-f</code></td>
<td>float (option)</td>
<td>Portion of the examples to train on, e.g <code>0.5</code> for 50%.</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>--dropout</code>, <code>-d</code></td>
<td>float (option)</td>
<td>Dropout rate.</td>
<td><code>0.2</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of training iterations.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-b</code></td>
<td>int (option)</td>
<td>Training batch size.</td>
<td><code>32</code></td>
</tr>
<tr>
<td><code>--beam-width</code>, <code>-bw</code></td>
<td>int (option)</td>
<td>Training beam width.</td>
<td><code>16</code></td>
</tr>
<tr>
<td><code>--eval-id</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Optional ID of a dataset containing evaluation examples.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-split</code>, <code>-es</code></td>
<td>float (option)</td>
<td>If no evaluation ID is provided, split off a portion of the training examples for evaluation. Defaults to <code>0.2</code> for over 1000 training examples.</td>
<td><code>0.5</code></td>
</tr>
<tr>
<td><code>--silent</code>, <code>-S</code></td>
<td>bool (flag)</td>
<td>Don't print any updates.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-deptrain-curve"><kbd>EVALUATE</kbd> dep.train-curve</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained or blank <a href="https://spacy.io/models">spaCy model</a> and a dataset containing dependency annotations.</li>
  <li><strong>Saves:</strong> -</li>
  <li><strong>Use cases:</strong> Evaluating a trained dependency parsing model, determine the quality of the annotations.</li>
  </ul>
</blockquote>
<p>Batch-train models with different portions of the training examples and
print the accuracy figures and accuracy improvements. <code>n_samples</code>
is the numer of sample models to train at different stages. For instance,
<code>10</code> will train models for 10% of the examples, 20%, 30% and so on.
This recipe is useful to determine the quality of the collected
annotations, and whether more training examples will improve the
accuracy. As a rule of thumb, if accuracy improves within the last 25%,
training with more examples will likely result in better accuracy.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">dep</span><span class="hljs-selector-class">.train-curve</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--dropout]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--batch-size]</span> <span class="hljs-selector-attr">[--eval-id]</span> <span class="hljs-selector-attr">[--eval-split]</span> <span class="hljs-selector-attr">[--n-samples]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label(s) to train. Accepts single label or comma-separated list. If not set, all available labels will be used.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--dropout</code>, <code>-d</code></td>
<td>float (option)</td>
<td>Dropout rate.</td>
<td><code>0.2</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of training iterations.</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-b</code></td>
<td>int (option)</td>
<td>Training batch size.</td>
<td><code>32</code></td>
</tr>
<tr>
<td><code>--beam-width</code>, <code>-bw</code></td>
<td>int (option)</td>
<td>Training beam width.</td>
<td><code>16</code></td>
</tr>
<tr>
<td><code>--eval-id</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Optional ID of a dataset containing evaluation examples.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--eval-split</code>, <code>-es</code></td>
<td>float (option)</td>
<td>If no evaluation ID is provided, split off a portion of the training examples for evaluation. Defaults to <code>0.2</code> for over 1000 training examples.</td>
<td><code>0.5</code></td>
</tr>
<tr>
<td><code>--n-samples</code>, <code>-ns</code></td>
<td>int (option)</td>
<td>Number of samples to train, e.g. <code>10</code> for results at 10%, 20% and so on.</td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="teach-termstrain-vectors"><kbd>TEACH</kbd> terms.train-vectors</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A text source, <a href="https://radimrehurek.com/gensim/">Gensim</a>, a loadable <a href="https://spacy.io/models">spaCy model</a></li>
  <li><strong>Saves:</strong> Word vectors to a directory</li>
  <li><strong>Use cases:</strong> Training word vectors, bootstrapping terminology lists</li>
  </ul>
</blockquote>
<p>Train a <a href="https://en.wikipedia.org/wiki/Word2vec">Word2vec</a> or
<a href="https://explosion.ai/blog/sense2vec-with-spacy">Sense2vec</a> semantic similarity
model, using <a href="https://spacy.io">spaCy</a> and <a href="https://radimrehurek.com/gensim/">Gensim</a>.
For best results, you should provide a lot of input text (at least 10 million
words). Because training is a batch process, the input stream must be
fixed-length.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">terms</span><span class="hljs-selector-class">.train-vectors</span> <span class="hljs-selector-attr">[output_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--loader]</span> <span class="hljs-selector-attr">[--spacy-model]</span> <span class="hljs-selector-attr">[--lang]</span> <span class="hljs-selector-attr">[--size]</span> <span class="hljs-selector-attr">[--window]</span> <span class="hljs-selector-attr">[--min-count]</span> <span class="hljs-selector-attr">[--negative]</span> <span class="hljs-selector-attr">[--n-iter]</span> <span class="hljs-selector-attr">[--n-workers]</span> <span class="hljs-selector-attr">[--merge-ents]</span> <span class="hljs-selector-attr">[--merge-nps]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>output_model</code></td>
<td>unicode (positional)</td>
<td>Output directory.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>File path or standard input.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--spacy-model</code>, <code>-sm</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--lang</code>, <code>-la</code></td>
<td>unicode (positional)</td>
<td>ISO code of language to use if starting with a blank model.</td>
<td><code>xx</code></td>
</tr>
<tr>
<td><code>--size</code>, <code>-d</code></td>
<td>int (option)</td>
<td>Dimension of the word vectors.</td>
<td><code>128</code></td>
</tr>
<tr>
<td><code>--window</code>, <code>-w</code></td>
<td>int (option)</td>
<td>Context window size.</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>--min-count</code>, <code>-m</code></td>
<td>int (option)</td>
<td>Minimum count.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>--negative</code>, <code>-g</code></td>
<td>int (option)</td>
<td>Number of negative samples.</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>--n-iter</code>, <code>-n</code></td>
<td>int (option)</td>
<td>Number of iterations.</td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>--n-workers</code>, <code>-nw</code></td>
<td>int (option)</td>
<td>Number of workers.</td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>--filename</code>, <code>-f</code></td>
<td>unicode (option)</td>
<td>Name of model file.</td>
<td><code>word2vec.bin</code></td>
</tr>
<tr>
<td><code>--merge-ents</code>, <code>-E</code></td>
<td>bool (flag)</td>
<td>Merge entities.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--merge-nps</code>, <code>-N</code></td>
<td>bool (flag)</td>
<td>Merge noun phrases.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Word2Vec trains a lookup table that provides a "meaning" vector for each term in
your vocabulary. Terms which occur in similar contexts will be mapped to similar
vectors. Given enough examples of a word, the model is able to build an accurate
picture of its usage in context, which reveals a lot (but not all) about its
meaning. The vectors can then be used like a thesaurus, or as input to a neural
network model.</p>
<h3 id="teach-termsteach"><kbd>TEACH</kbd> terms.teach</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>text</code></li>
  <li><strong>Requirements:</strong> A loadable <a href="https://spacy.io/models">spaCy model</a> with word vectors, a list of seed terms</li>
  <li><strong>Saves:</strong> Annotations to the database</li>
  <li><strong>Use cases:</strong> Building a terminology list, pre-processing entitiy candidates for NER training</li>
  </ul>
</blockquote>
<p>Build a terminology list interactively using a model's word vectors and seed
terms, either a comma-separated list or a text file containing one term per
line.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">terms</span><span class="hljs-selector-class">.teach</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[spacy_model]</span> <span class="hljs-selector-attr">[--seeds]</span> <span class="hljs-selector-attr">[--resume]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://spacy.io/models">spaCy model</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--seeds</code>, <code>-s</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of path to file with seed terms (one term per line).</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>--resume</code>, <code>-R</code></td>
<td>bool (flag)</td>
<td>Resume from existing terms dataset and update target vector accordingly.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="manage-termsto-patterns"><kbd>MANAGE</kbd> terms.to-patterns</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A dataset of seed terms, e.g. collected using <code>terms.teach</code>.</li>
  <li><strong>Saves:</strong> Match patterns to a JSONL file.</li>
  <li><strong>Use cases:</strong> Converting seed terms to match patterns to use with <code>ner.match</code> (to collect training data for a new entity type) and <code>ner.teach</code> (to filter examples for annotation).</li>
  </ul>
</blockquote>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">terms</span><span class="hljs-selector-class">.to-patterns</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[output_file]</span> <span class="hljs-selector-attr">[--label]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>output_file</code></td>
<td>unicode (positional)</td>
<td>Optional path to an output file.</td>
<td><code>sys.stdout</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label to assign to the patterns.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy terms<span class="hljs-selector-class">.to-patterns</span> [dataset] /tmp/fruits_patterns<span class="hljs-selector-class">.jsonl</span> --<span class="hljs-selector-tag">label</span> FRUIT
</code></pre>
<h3 id="teach-imagemanual"><kbd>EXPLORE</kbd> image.manual</h3>
<blockquote>
  <ul>
  <li><strong>⚠️ Important note:</strong> This recipe was introduced in <code>v1.5.0</code> and is still experimental.</li>
  <li><strong>Annotation interface:</strong> <code>image_manual</code></li>
  <li><strong>Requirements:</strong> An image source, e.g. a directory of image files or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Adding bounding boxes and polygon segments to images, creating training data for computer vision models.</li>
  </ul>
</blockquote>
<p>Annotate images by drawing rectangular bounding boxes and polygon shapes. Each
shape will be added to the task's <code>"spans"</code> with its label, colour and a <code>"points"</code>
property containing the <code>[x, y]</code> pixel coordinate tuples.
<a href="#object-detection-and-image-segmentation">See here</a> for more details on the
JSONL format. Rectangular shapes can be added by clicking or dragging. Polygon
shapes can be closed by clicking on the start point, or by double-clicking
anywhere on the image. To select an existing shape, click on its label or
bounding box. Selecting a shape allows you to change its label or delete it
from the image.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">image</span><span class="hljs-selector-class">.manual</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--label]</span> <span class="hljs-selector-attr">[--exclude]</span> <span class="hljs-selector-attr">[--darken]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to a directory containing image files, or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>One or more labels to annotate. Supports a comma-separated list or a path to a file with one label per line.</td>
<td>-</td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--darken</code>, <code>-D</code></td>
<td>bool (flag)</td>
<td>Darken image to make boxes stand out more.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy image<span class="hljs-selector-class">.manual</span> [dataset] /path/to/images --<span class="hljs-selector-tag">label</span> PERSON,ANIMAL,PLANT,CAR
prodigy image<span class="hljs-selector-class">.manual</span> [dataset] <span class="hljs-string">"food"</span> --api unsplash --<span class="hljs-selector-tag">label</span> FRUIT,VEGETABLE
</code></pre>
<h3 id="explore-imagetest"><kbd>EXPLORE</kbd> image.test</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>image</code></li>
  <li><strong>Requirements:</strong> Development environment on macOS, OSX or Linux and <a href="https://github.com/explosion/lightnet">LightNet</a>. A pre-trained <a href="https://github.com/explosion/lightnet">LightNet model (YOLOv2)</a> and an image source, e.g. a directory of image files or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to database.</li>
  <li><strong>Use cases:</strong> Testing Prodigy's image annotation interface, getting example predictions on your images.</li>
  </ul>
</blockquote>
<p>Test Prodigy's built-in object detection interface using one of the
<a href="https://pjreddie.com/darknet/yolo/">YOLOv2</a> object detection models via the
<a href="https://github.com/explosion/lightnet">LightNet</a> library. The recipe will load
in images from a directory or API, and create one task per detected object.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-tag">image</span><span class="hljs-selector-class">.test</span> <span class="hljs-selector-attr">[dataset]</span> <span class="hljs-selector-attr">[lightnet_model]</span> <span class="hljs-selector-attr">[source]</span> <span class="hljs-selector-attr">[--api]</span> <span class="hljs-selector-attr">[--exclude]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>lightnet_model</code></td>
<td>unicode (positional)</td>
<td>Loadable <a href="https://github.com/explosion/lightnet">LightNet model</a> (YOLOv2).</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to a directory containing image files, or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>pip install lightnet
<span class="hljs-keyword">python</span> -m lightnet download tiny-yolo
<span class="hljs-keyword">python</span> -m lightnet download yolo

prodigy <span class="hljs-keyword">image</span>.test [dataset] tiny-yolo /path/to/images
prodigy <span class="hljs-keyword">image</span>.test [dataset] yolo <span class="hljs-string">"people"</span> --api unsplash
</code></pre>
<h3 id="teach-mark"><kbd>TEACH</kbd> mark</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> any</li>
  <li><strong>Requirements:</strong> A text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> Annotations to the database</li>
  <li><strong>Use cases:</strong> Creating evaluation sets, annotating a stream without a model in the loop</li>
  </ul>
</blockquote>
<p>Start the annotation server without any of the clever training logic. It just
displays what it's given, and saves your decisions to the database. When using
<code>mark</code> for evaluation, you'll usually want to add the <code>--memorize</code> flag, to
enable the answer cache. This prevents you from being asked exactly the same
question twice within the same dataset. Most powerful in combination with
<a href="#manage-pipe"><code>pipe</code></a>.</p>
<pre><code>prodigy mark <span class="hljs-string">[dataset]</span> <span class="hljs-string">[source]</span> <span class="hljs-string">[--api]</span> <span class="hljs-string">[--loader]</span> <span class="hljs-string">[--label]</span> <span class="hljs-string">[--view-id]</span> <span class="hljs-string">[--memorize]</span>  <span class="hljs-string">[--exclude]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--label</code>, <code>-l</code></td>
<td>unicode (option)</td>
<td>Label to apply in classification mode.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>--view-id</code>, <code>-v</code></td>
<td>unicode (option)</td>
<td>Annotation interface to use.</td>
<td><code>'text'</code></td>
</tr>
<tr>
<td><code>--memorize</code>, <code>-M</code></td>
<td>bool (flag)</td>
<td>Enable answer cache and don't ask the same question twice.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-review"><kbd>EVALUATE</kbd> review</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>review</code></li>
  <li><strong>Requirements:</strong> One or more datasets with (overlapping) annotations</li>
  <li><strong>Saves:</strong> Reviewed annotations to database</li>
  <li><strong>Use cases:</strong> Reviewing annotations and resolving conflicts in existing annotations created by multiple annotators</li>
  </ul>
</blockquote>
<p>Review existing annotations created by multiple annotators and resolve potential
conflicts by creating one final "master annotation". Can be used for both binary
and manual annotations. If the annotations were created with a manual
interface, the "most popular" version will be pre-selected automatically.</p>
<p><strong>Important note:</strong> If you're using this recipe with annotations created in
Prodigy v1.7.1 or lower, you'll need to define a <code>--view-id</code> argument with the
annotation interface ID to use. For example, <code>'ner_manual'</code> or
<code>'classification'</code>.</p>
<pre><code>prodigy review <span class="hljs-string">[dataset]</span> <span class="hljs-string">[a_file]</span> <span class="hljs-string">[b_file]</span> <span class="hljs-string">[--no-random]</span> <span class="hljs-string">[--diff]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID to save reviewed annotations.</td>
<td>-</td>
</tr>
<tr>
<td><code>input_sets</code></td>
<td>unicode (positional)</td>
<td>Comma-separated names of datasets to review.</td>
<td>-</td>
</tr>
<tr>
<td><code>--view-id</code>, <code>-v</code></td>
<td>unicode (option)</td>
<td>Default view_id (e.g. <code>ner</code> or <code>ner_manual</code>) to use if none present in the task.</td>
<td>-</td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="evaluate-compare"><kbd>EVALUATE</kbd> compare</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> <code>compare</code>, <code>diff</code></li>
  <li><strong>Requirements:</strong> Output of two models in Prodigy's <a href="#compare-format">JSONL format</a></li>
  <li><strong>Saves:</strong> Annotations to database</li>
  <li><strong>Use cases:</strong> A/B evaluation, machine translation, summarisation, text generation, dialog structure</li>
  </ul>
</blockquote>
<pre><code>prodigy compare <span class="hljs-string">[dataset]</span> <span class="hljs-string">[a_file]</span> <span class="hljs-string">[b_file]</span> <span class="hljs-string">[--no-random]</span> <span class="hljs-string">[--diff]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Prodigy dataset ID.</td>
<td>-</td>
</tr>
<tr>
<td><code>a_file</code></td>
<td>unicode (positional)</td>
<td>System responses in <a href="#comparison-files">JSONL format</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>b_file</code></td>
<td>unicode (positional)</td>
<td>Baseline responses in <a href="#comparison-files">JSONL format</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>--no-random</code>, <code>-nr</code></td>
<td>bool (flag)</td>
<td>Don't randomise which annotation is shown as the "correct" suggestion (always use the first option).</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--diff</code>, <code>-D</code></td>
<td>bool (flag)</td>
<td>Show examples as visual diff.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="manage-pipe"><kbd>MANAGE</kbd> pipe</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> A pre-trained <a href="https://spacy.io/models">spaCy model</a>, a label to annotate and a text source, e.g. a file or an API. If a live API requires a key, it needs to be available in Prodigy's configuration file.</li>
  <li><strong>Saves:</strong> -</li>
  <li><strong>Use cases:</strong> Inspecting or modifying a stream</li>
  </ul>
</blockquote>
<p>Load examples from an input source, and print them as newline-delimited JSON.
This makes it easy to filter the stream with command-line utilities such as
<code>grep</code>. It's also often useful to inspect the stream, by piping to <code>less</code>. If
you're using one of Prodigy's recipes to pretty-print annotations, don't forget
to set the <code>-R</code> flag with <code>less</code> so that the color displays correctly.</p>
<pre><code>prodigy pipe <span class="hljs-string">[source]</span> <span class="hljs-string">[--api]</span> <span class="hljs-string">[--loader]</span> <span class="hljs-string">[--from-dataset]</span> <span class="hljs-string">[--exclude]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source</code></td>
<td>unicode (positional)</td>
<td>Path to text source or search query if API loader is used.</td>
<td><code>sys.stdin</code></td>
</tr>
<tr>
<td><code>--api</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Optional ID of API loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--from-dataset</code>, <code>-D</code></td>
<td>Pipe from a dataset, using the dataset ID specified via <code>source</code>.</td>
<td><code>False</code></td>
<td></td>
</tr>
<tr>
<td><code>--exclude</code>, <code>-e</code></td>
<td>unicode (option)</td>
<td>Comma-separated list of dataset IDs whose annotations to exclude.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="manage-dataset"><kbd>MANAGE</kbd> dataset</h3>
<blockquote>
  <ul>
  <li><strong>Annotation interface:</strong> -</li>
  <li><strong>Requirements:</strong> -</li>
  <li><strong>Saves:</strong> A new dataset and meta data to the database</li>
  <li><strong>Use cases:</strong> Creating a new dataset</li>
  </ul>
</blockquote>
<p>Create a new dataset in the database. A dataset ID is required for most recipes
and lets you group annotations together. The additional meta information, like
author and description, is also displayed in the web application.</p>
<p>When you start annotating, Prodigy will also create a session dataset, using the
timestamp as the dataset ID. This lets you view, export or discard annotations
of a specific session. To see all dataset and session IDs, use the
<a href="#manage-stats"><code>stats</code> command</a> with the flag <code>-ls</code>.</p>
<pre><code>prodigy dataset <span class="hljs-string">[dataset]</span> <span class="hljs-string">[description]</span> <span class="hljs-string">[--author]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Unique dataset ID. Will be used to store annotations in the database.</td>
<td>-</td>
</tr>
<tr>
<td><code>description</code></td>
<td>unicode (positional)</td>
<td>Short description of the dataset.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--author</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>Dataset author or annotator.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments.</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code><span class="hljs-attribute">prodigy</span> dataset tech_orgs <span class="hljs-string">"Annotate tech orgs"</span>
</code></pre>
<h3 id="manage-prodigy"><kbd>MANAGE</kbd> prodigy …</h3>
<p>Run a built-in or custom Prodigy recipe. The <code>-F</code> option lets you load a recipe
from a simple Python file, containing one or more recipe functions. All recipe
arguments will be available from the command line. To print usage info and a
list of available arguments, use the <code>--help</code> flag.</p>
<pre><code>prodigy <span class="hljs-string">[recipe_name]</span> <span class="hljs-string">[*recipe_arguments]</span> <span class="hljs-string">[-F]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>recipe_name</code></td>
<td>positional</td>
<td>Recipe name.</td>
</tr>
<tr>
<td><code>*recipe_arguments</code></td>
<td>-</td>
<td>Recipe arguments.</td>
</tr>
<tr>
<td><code>-F</code></td>
<td>unicode (option)</td>
<td>Path to recipe file to load custom recipe.</td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments (command-line only).</td>
</tr>
</tbody>
</table>
<h2 id="manage-stats"><kbd>MANAGE</kbd> stats</h2>
<p>Print Prodigy and database statistics. Specifying a dataset ID will show
detailed stats for the dataset, like annotation counts and meta data. You can
also choose to list all available dataset or session IDs.</p>
<pre><code>prodigy stats <span class="hljs-string">[dataset]</span> <span class="hljs-string">[--list-datasets]</span> <span class="hljs-string">[--list-sessions]</span> <span class="hljs-string">[--no-format]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Optional Prodigy dataset ID.</td>
</tr>
<tr>
<td><code>--list-datasets</code>, <code>-l</code></td>
<td>flag</td>
<td>List IDs of all datasets in the database.</td>
</tr>
<tr>
<td><code>--list-sessions</code>, <code>-ls</code></td>
<td>flag</td>
<td>List IDs of all datasets and sessions in the database.</td>
</tr>
<tr>
<td><code>--no-format</code>, <code>-nf</code></td>
<td>flag</td>
<td>Don't pretty-print the stats and print a simple dict instead.</td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>flag</td>
<td>Show help message and available arguments.</td>
</tr>
</tbody>
</table>
<pre><code>prodigy stats <span class="hljs-keyword">new</span><span class="hljs-type">s_headlines</span> -l

✨  Prodigy stats

Version            <span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
Database Name      SQLite
Database Id        sqlite
Total Datasets     <span class="hljs-number">5</span>
Total Sessions     <span class="hljs-number">23</span>

✨  Dataset <span class="hljs-string">'news_headlines'</span>

Dataset            <span class="hljs-keyword">new</span><span class="hljs-type">s_headlines</span>
Created            <span class="hljs-number">2017</span><span class="hljs-number">-07</span><span class="hljs-number">-29</span> <span class="hljs-number">15</span>:<span class="hljs-type">29</span>:<span class="hljs-number">28</span>
Description        Annotate <span class="hljs-keyword">new</span><span class="hljs-type">s</span> headlines
Author             Ines
Annotations        <span class="hljs-number">1550</span>
Accept             <span class="hljs-number">671</span>
Reject             <span class="hljs-number">435</span>
Ignore             <span class="hljs-number">444</span>
</code></pre>
<h2 id="manage-db-in"><kbd>MANAGE</kbd> db-in</h2>
<blockquote>
  <ul>
  <li><strong>Requirements:</strong> A loadable file containing annotations</li>
  <li><strong>Saves:</strong> Annotations to the database</li>
  <li><strong>Use cases:</strong> Importing existing annotations</li>
  </ul>
</blockquote>
<p>Import existing annotations to the database. Can load all file types supported
by Prodigy. To import NER annotations, the files should be converted into
Prodigy's JSONL <a href="#annotation-task-format">annotation format</a>.</p>
<pre><code>prodigy db-in <span class="hljs-string">[dataset]</span> <span class="hljs-string">[in_file]</span> <span class="hljs-string">[--loader]</span> <span class="hljs-string">[--answer]</span> <span class="hljs-string">[--overwrite]</span> <span class="hljs-string">[--dry]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Dataset ID to import or export.</td>
<td>-</td>
</tr>
<tr>
<td><code>in_file</code></td>
<td>unicode (positional)</td>
<td>Path to input annotation file.</td>
<td>-</td>
</tr>
<tr>
<td><code>--loader</code>, <code>-lo</code></td>
<td>unicode (option)</td>
<td>Optional ID of text source loader. If not set, source file extension is used to determine loader.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--answer</code>, <code>-a</code></td>
<td>unicode (option)</td>
<td>String to set as <code>"answer"</code> key if none is present.</td>
<td><code>'accept'</code></td>
</tr>
<tr>
<td><code>--overwrite</code>, <code>-O</code></td>
<td>bool (flag)</td>
<td>Overwrite existing answers.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--dry</code>, <code>-D</code></td>
<td>bool (flag)</td>
<td>Perform a dry run and don't save any files.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments.</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy db-in tech_orgs <span class="hljs-string">/tmp/annotations.jsonl</span> <span class="hljs-params">--answer</span> accept <span class="hljs-params">--overwrite</span>
</code></pre>
<h2 id="manage-db-out"><kbd>MANAGE</kbd> db-out</h2>
<blockquote>
  <ul>
  <li><strong>Requirements:</strong> A dataset containing annotations</li>
  <li><strong>Saves:</strong> A JSONL file containing the annotations</li>
  <li><strong>Use cases:</strong> Exporting from the database</li>
  </ul>
</blockquote>
<p>Export annotations in Prodigy's <a href="#annotation-task-format">JSONL format</a>. If the
output directory doesn't exist, it will be created. If no output directory is
specified, the annotations will be printed instead.</p>
<pre><code>prodigy <span class="hljs-keyword">db</span>-<span class="hljs-keyword">out</span> [dataset] [--<span class="hljs-keyword">out</span>-<span class="hljs-keyword">dir</span>] [--dry]
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode (positional)</td>
<td>Dataset ID to import or export.</td>
<td>-</td>
</tr>
<tr>
<td><code>out_dir</code></td>
<td>unicode (positional)</td>
<td>Path to output directory to export annotation file to.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>--flagged-only</code>, <code>F</code></td>
<td>bool (flag)</td>
<td>Only export examples that were flagged in the UI. Requires <code>"show_flag": true</code> to be set in the config.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--dry</code>, <code>-D</code></td>
<td>bool (flag)</td>
<td>Perform a dry run and don't save any files.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments.</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy <span class="hljs-keyword">db</span>-<span class="hljs-keyword">out</span> tech_orgs /tmp/annotations
</code></pre>
<h2 id="manage-db-merge"><kbd>MANAGE</kbd> db-merge</h2>
<blockquote>
  <ul>
  <li><strong>Requirements:</strong> Two or more datasets containing annotations</li>
  <li><strong>Saves:</strong> A new dataset containing the annotations of the input dataset</li>
  <li><strong>Use cases:</strong> Merging several datasets (e.g. for different labels) into one</li>
  </ul>
</blockquote>
<p>Merge two or more existing datasets into a new set. Keeps a copy of the original
datasets and creates a new set for the merged examples. The output dataset needs
to be empty. If it doesn't exist yet, it will be created.</p>
<pre><code>prodigy db-merge <span class="hljs-string">[in_sets]</span> <span class="hljs-string">[out_sets]</span> <span class="hljs-string">[--dry]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>in_sets</code></td>
<td>unicode (positional)</td>
<td>Comma-separated names of datasets to merge.</td>
<td>-</td>
</tr>
<tr>
<td><code>out_set</code></td>
<td>unicode (positional)</td>
<td>Name of dataset to save the merged examples to.</td>
<td>-</td>
</tr>
<tr>
<td><code>--dry</code>, <code>-D</code></td>
<td>bool (flag)</td>
<td>Perform a dry run and don't save anything.</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>bool (flag)</td>
<td>Show help message and available arguments.</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>prodigy db-merge <span class="hljs-keyword">new</span><span class="hljs-type">s_person</span>,<span class="hljs-keyword">new</span><span class="hljs-type">s_org</span>,<span class="hljs-keyword">new</span><span class="hljs-type">s_product</span> <span class="hljs-keyword">new</span><span class="hljs-type">s_training</span>
</code></pre>
<h2 id="manage-drop"><kbd>MANAGE</kbd> drop</h2>
<p>Remove a dataset or annotation session from a project. Can't be undone. To see
all dataset and session IDs in the database, use <code>prodigy stats -ls</code>.</p>
<pre><code>prodigy <span class="hljs-keyword">drop</span> [<span class="hljs-keyword">dataset</span>]
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>positional</td>
<td>Dataset or session ID.</td>
</tr>
<tr>
<td><code>--batch-size</code>, <code>-n</code></td>
<td>option</td>
<td>Delete examples in batches of the given size. Prevents possible database error for large datasets.</td>
</tr>
<tr>
<td><code>--help</code>, <code>-h</code></td>
<td>flag</td>
<td>Show help message and available arguments.</td>
</tr>
</tbody>
</table>
<h2 id="custom-recipes">Custom recipes</h2>
<blockquote>
  <p><strong>More details and examples: <a href="/docs/workflow-custom-recipes">Custom Recipes Workflow</a></strong></p>
</blockquote>
<p>Prodigy makes it easy to write your own recipes. For example, you might want to
stream in text from different file formats, a database or an API, implement
custom text processing logic and plug in your own models. The <code>@prodigy.recipe</code>
decorator turns a Python function into a Prodigy recipe, and lets you assign it
a name and argument annotations for easy command-line usage.</p>
<pre><code><span class="hljs-selector-tag">prodigy</span> <span class="hljs-selector-attr">[recipe_name]</span> <span class="hljs-selector-attr">[...args]</span> <span class="hljs-selector-tag">-F</span> <span class="hljs-selector-tag">recipe</span><span class="hljs-selector-class">.py</span>
</code></pre>
<pre><code class="python language-python"><span class="hljs-meta">@prodigy.recipe(recipe_name, **annotations)</span>
</code></pre>
<p>A recipe is a simple Python function that returns a dictionary of its
components. The arguments of the recipe function will become available from the
command line and let you pass in parameters like the dataset ID, the text source
and other settings.</p>
<p>Recipes can receive a name and a variable number of argument annotations,
following the <a href="https://github.com/micheles/plac">Plac</a> syntax. The built-in
<code>recipe_args</code> dictionary contains a range of annotations for commonly used
arguments – for example, the project or view ID. Argument annotations, as well
as the recipe function's docstring will also be displayed when you use the
<code>--help</code> flag on the command line.</p>
<pre><code class="python language-python"><span class="hljs-keyword">import</span> prodigy

<span class="hljs-meta">@prodigy.recipe('recipe_name',</span>
    dataset=prodigy.recipe_args[<span class="hljs-string">'dataset'</span>],
    query=(<span class="hljs-string">"Search query"</span>, <span class="hljs-string">"positional"</span>, <span class="hljs-keyword">None</span>, str)
)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twitter_recipe</span><span class="hljs-params">(dataset, query)</span>:</span>
    <span class="hljs-string">"""A custom recipe."""</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'dataset'</span>: dataset,
        <span class="hljs-string">'view_id'</span>: <span class="hljs-string">'text'</span>,
        <span class="hljs-string">'stream'</span>: [],
        <span class="hljs-string">'update'</span>: <span class="hljs-keyword">None</span>,
        <span class="hljs-string">'db'</span>: <span class="hljs-keyword">True</span>,
        <span class="hljs-string">'progress'</span>: <span class="hljs-keyword">None</span>,
        <span class="hljs-string">'on_load'</span>: <span class="hljs-keyword">None</span>,
        <span class="hljs-string">'on_exit'</span>: <span class="hljs-keyword">None</span>,
        <span class="hljs-string">'get_session_id'</span>: <span class="hljs-keyword">None</span>,
        <span class="hljs-string">'exclude'</span>: <span class="hljs-keyword">None</span>,
        <span class="hljs-string">'config'</span>: {}
    }
</code></pre>
<h3 id="recipe-components">Recipe components</h3>
<p>The components returned by the recipe need to include an iterable <code>stream</code>, a
<code>view_id</code> and a <code>dataset</code> (if you want to use the storage to save the
annotations to the database). The following components can be defined by a
recipe:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode</td>
<td>ID of the current project. Used to associate the annotation with a project in the database.</td>
</tr>
<tr>
<td><code>view_id</code></td>
<td>unicode</td>
<td>Annotation interface to use.</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>Stream of annotation tasks in Prodigy's JSON format.</td>
</tr>
<tr>
<td><code>update</code></td>
<td>callable</td>
<td>Function invoked when Prodigy receives annotations. Can be used to update a model.</td>
</tr>
<tr>
<td><code>db</code></td>
<td>-</td>
<td>Storage ID, <code>True</code> for default database, <code>False</code> for no database or <a href="#db">custom database class</a>.</td>
</tr>
<tr>
<td><code>progress</code></td>
<td>callable</td>
<td>Function that takes the count of annotated tasks in the session and in total as its arguments and returns a progress value.</td>
</tr>
<tr>
<td><code>on_load</code></td>
<td>callable</td>
<td>Function that is executed when Prodigy is started. Can be used to update a model with existing annotations.</td>
</tr>
<tr>
<td><code>on_exit</code></td>
<td>callable</td>
<td>Function that is executed when the user exits Prodigy. Can be used to save a model's state to disk or export other data.</td>
</tr>
<tr>
<td><code>get_session_id</code></td>
<td>callable</td>
<td>Function that returns a custom session ID. If not set, a timestamp is used.</td>
</tr>
<tr>
<td><code>exclude</code></td>
<td>list</td>
<td>List of dataset IDs whose annotations to exclude.</td>
</tr>
<tr>
<td><code>config</code></td>
<td>dict</td>
<td>Recipe-specific configuration. Can be overwritten by the global and project config.</td>
</tr>
</tbody>
</table>
<h4 id="stream">Stream</h4>
<blockquote>
  <ul>
  <li><strong>Helpers:</strong> <code>prodigy.components.loaders</code>, <code>prodigy.components.sorters</code>, <code>prodigy.components.filters</code></li>
  </ul>
</blockquote>
<p>The stream is an iterable of annotation tasks in Prodigy's JSON format.Streams
let you load in any data from any source, and pre-process it however you like.</p>
<pre><code class="python language-python">stream = ({<span class="hljs-string">'text'</span>: tweet[<span class="hljs-string">'msg'</span>]} <span class="hljs-keyword">for</span> tweet <span class="hljs-keyword">in</span> TWITTER_DATA)
</code></pre>
<p>Prodigy comes with several built-in file loaders and API loaders for the most
common file formats, selected data sets and APIs.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.loaders <span class="hljs-keyword">import</span> JSONL, CSV
<span class="hljs-keyword">from</span> prodigy.components.loaders <span class="hljs-keyword">import</span> NewYorkTimes, Unsplash

stream = JSONL(<span class="hljs-string">'tweets.jsonl'</span>)
stream = CSV(<span class="hljs-string">'data.csv'</span>)

stream = NewYorkTimes(query=<span class="hljs-string">'Google'</span>, key=<span class="hljs-string">'xxx'</span>)
stream = Unsplash(query=<span class="hljs-string">'food'</span>, key=<span class="hljs-string">'xxx'</span>)
</code></pre>
<p>You can also wrap the stream in a function to filter it:</p>
<pre><code class="python language-python"><span class="hljs-comment"># Custom filtering by text length</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter_stream</span><span class="hljs-params">(stream)</span>:</span>
    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> stream:
        <span class="hljs-keyword">if</span> len(task[<span class="hljs-string">'text'</span>]) &gt; <span class="hljs-number">10</span>:
            <span class="hljs-keyword">yield</span> task

stream = filter_stream(stream)
</code></pre>
<p>This also lets you attach additional meta information to an annotation task. If
a task contains a <code>meta</code> property, its contents will be rendered at the bottom
of a card. This is especially helpful when using Prodigy as a developer tool.
For example, you can attach confidence or frequency scores, or meta data related
to the content:</p>
<pre><code class="json language-json">{<span class="hljs-attr">"text"</span>: <span class="hljs-string">"just setting up my twttr"</span>, <span class="hljs-attr">"meta"</span>: {<span class="hljs-attr">"user"</span>: <span class="hljs-string">"jack"</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">20</span>}}
{<span class="hljs-attr">"text"</span>: <span class="hljs-string">"YOLO"</span>, <span class="hljs-attr">"meta"</span>: {<span class="hljs-attr">"frequency"</span>: <span class="hljs-number">14024</span>}}
</code></pre>
<h4 id="update">Update</h4>
<p>The <code>update</code> function is invoked every time Prodigy receives a batch of
annotated examples. It receives a list of the original tasks in Prodigy's JSON
format, with an added <code>answer</code> key mapped to either <code>"accept"</code>, <code>"reject"</code> or
<code>"ignore"</code>.</p>
<pre><code class="python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span><span class="hljs-params">(answers)</span>:</span>
    <span class="hljs-keyword">for</span> answer <span class="hljs-keyword">in</span> answers:
        <span class="hljs-keyword">if</span> answer[<span class="hljs-string">'answer'</span>] == <span class="hljs-string">'accept'</span>
            my_custom_model.update(answer[<span class="hljs-string">'text'</span>], answer[<span class="hljs-string">'label'</span>])
</code></pre>
<p>Prodigy supports updating <a href="https://spacy.io/models">spaCy models</a>
out-of-the-box. If your models supports online learning, you can easily
implement your own <code>update</code> function that updates the model based on the
annotations.</p>
<h4 id="database">Database</h4>
<blockquote>
  <ul>
  <li><strong>Helpers:</strong> <code>prodigy.components.db</code></li>
  <li><strong>Libraries:</strong> <a href="http://docs.peewee-orm.com/en/latest/"><code>peewee</code></a>, <a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html"><code>playhouse</code></a></li>
  </ul>
</blockquote>
<p>The <code>db</code> setting lets you plug in your own storage solution for the annotations.
It can either be the ID of one of the built-in store components, <code>True</code> to use
the default store, <code>False</code> to disable the database, or a custom
<a href="#db">database class</a>.</p>
<p>Here's an example of a custom recipe using a remote PostgreSQL database and
environment variables for connection parameters via
<a href="http://docs.peewee-orm.com/en/latest/"><code>peewee</code></a>'s
<a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html">Playhouse extention</a>.
Because Prodigy is powered by <code>peewee</code>, all you need to do is import Prodigy's
<code>Database</code> class and drop in your initialised database:</p>
<pre><code class="python language-python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> prodigy
<span class="hljs-keyword">from</span> prodigy.components.db <span class="hljs-keyword">import</span> Database
<span class="hljs-keyword">from</span> playhouse.postgres_ext <span class="hljs-keyword">import</span> PostgresqlExtDatabase

db = PostgresqlExtDatabase(os.getenv(<span class="hljs-string">'PRODIGY_DB_NAME'</span>),
                           user=os.getenv(<span class="hljs-string">'PRODIGY_DB_USER'</span>),
                           password=os.getenv(<span class="hljs-string">'PRODIGY_DB_PASSWORD'</span>),
                           host=os.getenv(<span class="hljs-string">'PRODIGY_DB_HOST'</span>))

<span class="hljs-meta">@prodigy.recipe('custom-recipe')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">custom_recipe</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># your recipe here</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'db'</span>: Database(db)
        <span class="hljs-comment"># your other components here</span>
    }
</code></pre>
<h4 id="progress">Progress</h4>
<p>The <code>progress</code> function calculates an annotation progress. The current progress
is returned by the REST API on each submission of annotated tasks. If on
progress function is specified, Prodigy will try to calculate the progress based
on the stream.</p>
<pre><code class="python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">progress</span><span class="hljs-params">(session, total)</span>:</span>
    <span class="hljs-keyword">return</span> total / <span class="hljs-number">10000</span>
</code></pre>
<p>If you're annotating a finite number of examples, the progress can simply be the
percentage of annotated examples. However, it often makes sense to take the
gradient into account and increase the progress based on the impact of the
collected annotations.</p>
<h4 id="on-load">On load</h4>
<p>The <code>on_load</code> function is called when Prodigy is started. It receives the entire
<code>Controller</code> as its argument, giving you access to all recipe components. A
possible use case for this function could be to update your model with all
available annotations in the database:</p>
<pre><code class="python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_load</span><span class="hljs-params">(controller)</span>:</span>
    sessions = controller.db.get(dataset)
    <span class="hljs-keyword">for</span> session <span class="hljs-keyword">in</span> sessions:
        <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> session:
            <span class="hljs-keyword">if</span> task[<span class="hljs-string">'answer'</span>] == <span class="hljs-string">'accept'</span>:
                my_custom_model.update(task[<span class="hljs-string">'text'</span>], task[<span class="hljs-string">'label'</span>])
</code></pre>
<h4 id="on-exit">On exit</h4>
<p>The <code>on_exit</code> function is called when the user exits Prodigy and can be used to
save the current model state or a report to disk, or simply print custom stats
or progress. It receives the entire <code>Controller</code> as its argument, giving you
access to all recipe components.</p>
<pre><code class="python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_exit</span><span class="hljs-params">(controller)</span>:</span>
    model_path = controller.home / <span class="hljs-string">'models'</span> / controller.dataset / controller.session_id
    model.to_disk(model_path)
    print(<span class="hljs-string">'Saved model to disk.'</span>)
</code></pre>
<h3 id="get-session-id">Get session ID</h3>
<p>By default, Prodigy generates a timestamp-based session ID using the formatting
<code>'{:%Y-%m-%d_%H-%M-%S}'</code>. In most cases, this should be enough to ensure that
each annotation session receives a unique ID so that a unique session dataset
can be created in the database. However, if you're starting two Prodigy
sessions within the same second, and both sessions connect to the same database,
Prodigy will raise an error. To prevent this problem – or to simply use your own
scheme to assign session IDs, you can provide your own <code>get_session_id</code>
function.</p>
<pre><code class="python language-python">N_SESSIONS = <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_session_id</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">global</span> N_SESSIONS
    session_id = N_SESSIONS
    N_SESSIONS += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> session_id
</code></pre>
<h4 id="exclude">Exclude</h4>
<p>The <code>exclude</code> setting lets you filter out annotations that are already part
of other datasets so the annotator is not asked about the same question twice. It's also useful to ensure that evaluation sets don't contain any examples that
are also prevent in the training set. Excluded datasets are usually passed in
via the command line. If you use Prodigy's built in recipe argument
<code>recipe_args['exclude']</code>, it will take care of splitting the string and
converting it to a list.</p>
<pre><code class="python language-python">exclude_sets = [<span class="hljs-string">'my_dataset'</span>, <span class="hljs-string">'my_other_dataset'</span>]
</code></pre>
<p>Under the hood, Prodigy will fetch the task hashes for each example in the
datasets and filter out examples with the same task hash in the stream. The
task hash is generated based on the input data, plus added task properties
like spans, labels etc. This way, you still get to see different entities for
the same text – but not the same entity on the same text.</p>
<h4 id="config">Config</h4>
<p>The recipe config can be overwritten by the global or project-specific Prodigy
configuration. For example, a recipe may specify a batch size of 50, but in your
project, you can decide to use a batch size of 20 instead.</p>
<pre><code class="python language-python">config = {<span class="hljs-string">'batch_size'</span>: <span class="hljs-number">50</span>, <span class="hljs-string">'port'</span>: <span class="hljs-number">9000</span>}
</code></pre>
<h3 id="modifying-existing-recipes">Modifying existing recipes</h3>
<p>In some cases, you might only want to change or programmatically create one specific component of the recipe – for example, use the <code>ner.teach</code> recipe, but
load in a custom stream of examples from your database.</p>
<p>Because the <code>@recipe</code> decorator leaves the original recipe function intact, you
can simply import an existing recipe and wrap it in a custom recipe. When you call
<code>prodigy.recipes.ner.teach</code>, it will return a dictionary of components, which
you can then return by your custom recipe.</p>
<pre><code class="python language-python"><span class="hljs-keyword">import</span> prodigy
<span class="hljs-keyword">from</span> prodigy.recipes.ner <span class="hljs-keyword">import</span> teach
<span class="hljs-keyword">import</span> my_database

<span class="hljs-meta">@prodigy.recipe('my_recipe',</span>
    dataset=prodigy.recipe_args[<span class="hljs-string">'dataset'</span>],
    spacy_model=prodigy.recipe_args[<span class="hljs-string">'spacy_model'</span>],
    database=(<span class="hljs-string">"Database to connect to"</span>, <span class="hljs-string">"positional"</span>, <span class="hljs-keyword">None</span>, str),
    label=prodigy.recipe_args[<span class="hljs-string">'label_set'</span>])
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_recipe</span><span class="hljs-params">(dataset, spacy_model, database, label)</span>:</span>
    database = my_database.load(database)
    stream = ({<span class="hljs-string">'text'</span>: row[<span class="hljs-string">'plain_text'</span>]} <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> database)
    components = teach(dataset=dataset, spacy_model=spacy_model, source=stream, label=label)
    <span class="hljs-keyword">return</span> components
</code></pre>
<p>If the <code>source</code> argument is already an iterable stream, Prodigy will skip its
internal loading step and use the <code>source</code> as the <code>stream</code>. This lets you
overwrite it with an already loaded stream. You can now call your recipe from
the command line, and it will behave just like <code>ner.teach</code>:</p>
<pre><code>prodigy my_recipe my_dataset en_core_web_sm product_descriptions -F my_recipe<span class="hljs-selector-class">.py</span>
</code></pre>
<h3 id="testing-recipes">Testing recipes</h3>
<p>The <code>@recipe</code> decorator leaves the original function intact, so calling it
from within Python will simply return a dictionary of its components. This lets
you write comprehensive unit tests to ensure that your recipes are working
correctly.</p>
<pre><code class="python language-python"><span class="hljs-keyword">import</span> prodigy
<span class="hljs-keyword">import</span> my_database


<span class="hljs-meta">@prodigy.recipe('my-recipe')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_recipe</span><span class="hljs-params">(dataset, database)</span>:</span>
    stream = my_database.load(database)
    view_id = <span class="hljs-string">'classification'</span> <span class="hljs-keyword">if</span> database == <span class="hljs-string">'products'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'text'</span>
    <span class="hljs-keyword">return</span> {<span class="hljs-string">'dataset'</span>: dataset, <span class="hljs-string">'stream'</span>: stream, <span class="hljs-string">'view_id'</span>: view_id}


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_recipe</span><span class="hljs-params">()</span>:</span>
    dataset = <span class="hljs-string">'my_dataset'</span>
    database = <span class="hljs-string">'products'</span>
    components = my_recipe(dataset, database)
    <span class="hljs-keyword">assert</span> <span class="hljs-string">'dataset'</span> <span class="hljs-keyword">in</span> components
    <span class="hljs-keyword">assert</span> <span class="hljs-string">'stream'</span> <span class="hljs-keyword">in</span> components
    <span class="hljs-keyword">assert</span> <span class="hljs-string">'view_id'</span> <span class="hljs-keyword">in</span> components
    <span class="hljs-keyword">assert</span> components[<span class="hljs-string">'dataset'</span>] == dataset
    <span class="hljs-keyword">assert</span> components[<span class="hljs-string">'view_id'</span>] == <span class="hljs-string">'classification'</span>
    <span class="hljs-keyword">assert</span> hasattr(components[<span class="hljs-string">'stream'</span>], <span class="hljs-string">'__iter__'</span>)
</code></pre>
<p>You can also test the <code>Controller</code> created by a recipe by retrieving the loaded
recipe and executing it with its arguments. Note that <code>get_recipe()</code> expects
the Prodigy recipe to be registered (which happens automatically when you
apply the <code>@recipe</code> decorator to a function).</p>
<p>As a simple example, consider this custom recipe, which sets a <code>dataset</code> and
a custom function generating the session ID. (Of course, a static session ID is
a bad idea in practice, since session IDs have to be unique.)</p>
<pre><code class="python language-python"><span class="hljs-keyword">import</span> prodigy

<span class="hljs-meta">@prodigy.recipe('my-recipe')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_recipe</span><span class="hljs-params">(dataset)</span>:</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'dataset'</span>: dataset,
        <span class="hljs-string">'get_session_id'</span>: <span class="hljs-keyword">lambda</span>: <span class="hljs-number">5</span>  <span class="hljs-comment"># for example purposes – don't do this!</span>
    }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_my_recipe</span><span class="hljs-params">()</span>:</span>
    loaded_recipe = prodigy.get_recipe(<span class="hljs-string">'my-recipe'</span>)
    controller = loaded_recipe(<span class="hljs-string">'test'</span>)
    <span class="hljs-keyword">assert</span> controller.dataset == <span class="hljs-string">'test'</span>
    <span class="hljs-keyword">assert</span> controller.session_id == <span class="hljs-number">5</span>
</code></pre>
<p>Because <code>my-recipe</code> was registered by the <code>@recipe</code> decorator above, <code>get_recipe</code>
is able to find and load it. You can then execute it and create the <code>Controller</code>
by calling it with the recipe arguments – in this case, the <code>dataset</code>. The test
is then able to assert that the controller has received the correct attributes.</p>
<p>You can also take this one step further and call the controller's methods to
simulate retrieving tasks and sending annotations.</p>
<pre><code class="python language-python">batch = controller.get_questions()                    <span class="hljs-comment"># get a batch of examples from the queue</span>
examples = list(batch)
<span class="hljs-keyword">for</span> eg <span class="hljs-keyword">in</span> examples:
    eg[<span class="hljs-string">'answer'</span>] == <span class="hljs-string">'accept'</span>                          <span class="hljs-comment"># mock accepting all examples</span>
controller.receive_answers(examples)                  <span class="hljs-comment"># send the annotated examples back</span>
<span class="hljs-keyword">assert</span> controller.session_annotated == len(examples)  <span class="hljs-comment"># assert that all examples were received</span>
</code></pre>
<p>For more details and background, see the <a href="#controller"><code>Controller</code> API docs</a>.</p>
<h1 id="loaders">Loaders</h1>
<p>Loaders are helper classes to turn a source file into an iterable stream.
Calling a loader returns a generator that yields annotation tasks in Prodigy's
JSON format.</p>
<h2 id="file-loaders">File loaders</h2>
<p>Recipes that allow streaming in data from a file will choose the loader based on
the file extension.</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Component</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jsonl</code></td>
<td><code>JSONL</code></td>
<td>Stream in <a href="http://jsonlines.org">newline-delimited JSON</a> from a file. Prodigy's preferred format, as it's flexible and doesn't require parsing the entire file.</td>
</tr>
<tr>
<td><code>json</code></td>
<td><code>JSON</code></td>
<td>Stream in JSON from a file. Requires loading and parsing the entire file.</td>
</tr>
<tr>
<td><code>csv</code></td>
<td><code>CSV</code></td>
<td>Stream in a CSV file using the <code>csv</code> module. The keys will be read off the headers in the first line. Supports an optional <code>delimiter</code> keyword argument.</td>
</tr>
<tr>
<td><code>txt</code></td>
<td><code>TXT</code></td>
<td>Stream in a plain text from a file containing one example per line. Will yield tasks containing only a <code>text</code> property.</td>
</tr>
<tr>
<td><code>images</code></td>
<td><code>Images</code></td>
<td>Stream in images from a directory. All images will be encoded as <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">base64 data URIs</a> and included as the <code>image</code> key to be rendered with the <code>image</code> interface.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.loaders <span class="hljs-keyword">import</span> JSONL, JSON, CSV, TXT, Images

jsonl_stream = JSONL(<span class="hljs-string">'path/to/file.jsonl'</span>)
json_stream = JSON(<span class="hljs-string">'path/to/file.json'</span>)
csv_stream = CSV(<span class="hljs-string">'path/to/file.csv'</span>, delimiter=<span class="hljs-string">','</span>)
txt_stream = TXT(<span class="hljs-string">'path/to/file.txt'</span>)
img_stream = Images(<span class="hljs-string">'path/to/images'</span>)
</code></pre>
<h2 id="corpus-loaders">Corpus loaders</h2>
<p>Additionally, Prodigy also supports converting data from popular data sets and
corpora.</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Component</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reddit</code></td>
<td><code>Reddit</code></td>
<td>Stream in examples from a file of the <a href="https://archive.org/details/2015_reddit_comments_corpus">Reddit corpus</a>. Will extract, clean and validate the comments.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.loaders <span class="hljs-keyword">import</span> Reddit
reddit_stream = Reddit(<span class="hljs-string">'path/to/reddit.bz2'</span>)
</code></pre>
<h2 id="live-apis">Live APIs</h2>
<p>API loaders are similar to file format loaders, but stream in content via a web
API – for example, news headlines or teasers for a topic or from a specific
publication, images for a search term or related tags.</p>
<p>Individual APIs differ in the type of content they provide and the respective
rate limit restrictions. All APIs supported by Prodigy come with a free license
option and should provide sufficient rate limits for use on a single machine.</p>
<h3 id="api-the-new-york-times"><kbd>API</kbd> The New York Times</h3>
<blockquote>
  <ul>
  <li><strong>ID:</strong> <code>nyt</code></li>
  <li><strong>Component:</strong> <code>prodigy.components.loaders.NewYorkTimes</code></li>
  <li><strong>Details:</strong> <a href="https://developer.nytimes.com/">The New York Times API</a></li>
  <li><strong>Rate limit:</strong> 1,000/day</li>
  <li><strong>License:</strong> Non-commercial</li>
  </ul>
</blockquote>
<pre><code class="python language-python">stream = NewYorkTimes(query=<span class="hljs-string">'Berlin'</span>, key=<span class="hljs-string">'xxx'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>unicode</td>
<td>API key, can be requested from <a href="https://developer.nytimes.com/">here</a></td>
<td>-</td>
</tr>
<tr>
<td><code>query</code></td>
<td>unicode</td>
<td>Search term or query.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>content_type</code></td>
<td>unicode</td>
<td>Type of content to display. <code>'headline'</code>, <code>'snippet'</code>, <code>'lead'</code> or <code>'image'</code>.</td>
<td><code>'headline'</code></td>
</tr>
<tr>
<td><code>n_results</code></td>
<td>int</td>
<td>Number of results to request at once. Each page contains 10 results.</td>
<td><code>20</code></td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Text or image task.</td>
<td>Text</td>
</tr>
</tbody>
</table>
<h4 id="example-task">Example task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"2 Giant Pandas Arrive to Warm Welcome in Berlin"</span>,
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"source"</span>: <span class="hljs-string">"The New York Times"</span> }
}
</code></pre>
<h3 id="api-the-guardian"><kbd>API</kbd> The Guardian</h3>
<blockquote>
  <ul>
  <li><strong>ID:</strong> <code>guardian</code></li>
  <li><strong>Component:</strong> <code>prodigy.components.loaders.Guardian</code></li>
  <li><strong>Details:</strong> <a href="http://open-platform.theguardian.com">The Guardian API</a></li>
  <li><strong>Rate limit:</strong> 12/second, 5,000/day (free)</li>
  <li><strong>License:</strong> Non-commercial (free), commercial options</li>
  </ul>
</blockquote>
<pre><code class="python language-python">stream = Guardian(query=<span class="hljs-string">'Google'</span>, key=<span class="hljs-string">'xxx'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>unicode</td>
<td>API key, can be requested from <a href="http://open-platform.theguardian.com">here</a></td>
<td>-</td>
</tr>
<tr>
<td><code>query</code></td>
<td>unicode</td>
<td>Search term or query.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>page_size</code></td>
<td>int</td>
<td>Number of results to request per page.</td>
<td><code>50</code></td>
</tr>
<tr>
<td><code>section</code></td>
<td>unicode</td>
<td>Limit search to a specific sections. For a list of sections, see the <a href="http://open-platform.theguardian.com/documentation/section">sections API</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>lang</code></td>
<td>unicode</td>
<td>Limit search to a language. Takes the <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">ISO code</a>, e.g. <code>'en'</code>.</td>
<td>-</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Text task.</td>
<td>Text</td>
</tr>
</tbody>
</table>
<h4 id="example-task-1">Example task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Google is killing off Android's emoji blobs"</span>,
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"source"</span>: <span class="hljs-string">"The Guardian"</span>, <span class="hljs-attr">"section"</span>: <span class="hljs-string">"Technology"</span> }
}
</code></pre>
<h3 id="api-die-zeit"><kbd>API</kbd> Die Zeit</h3>
<blockquote>
  <ul>
  <li><strong>ID:</strong> <code>zeit</code></li>
  <li><strong>Component:</strong> <code>prodigy.components.loaders.Zeit</code></li>
  <li><strong>Details:</strong> <a href="http://developer.zeit.de/docs/content/">Die Zeit API</a></li>
  <li><strong>Rate limit:</strong> Yes</li>
  <li><strong>License:</strong> Non-commercial (free)</li>
  </ul>
</blockquote>
<pre><code class="python language-python">stream = Zeit(query=<span class="hljs-string">'Berlin'</span>, key=<span class="hljs-string">'xxx'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>unicode</td>
<td>API key, can be requested from <a href="http://developer.zeit.de/quickstart/">here</a></td>
<td>-</td>
</tr>
<tr>
<td><code>query</code></td>
<td>unicode</td>
<td>Search term or query.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>page_size</code></td>
<td>int</td>
<td>Number of results to request per page.</td>
<td><code>100</code></td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Text task.</td>
<td>Text</td>
</tr>
</tbody>
</table>
<h4 id="example-task-2">Example task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Die besten Technoclubs der Welt finden sich nicht in Berlin, sondern in Georgiens Hauptstadt Tbilissi. Hier explodiert das Nachtleben und zieht Feiernde aus Europa an."</span>,
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"source"</span>: <span class="hljs-string">"Die Zeit"</span> }
}
</code></pre>
<h3 id="api-news-api"><kbd>API</kbd> News API</h3>
<blockquote>
  <ul>
  <li><strong>ID:</strong> <code>newsapi</code></li>
  <li><strong>Component:</strong> <code>prodigy.components.loaders.NewsAPI</code></li>
  <li><strong>Details:</strong> <a href="https://newsapi.org">News API</a></li>
  <li><strong>Rate limit:</strong> n/a</li>
  <li><strong>License:</strong> Free with attribution</li>
  </ul>
</blockquote>
<pre><code class="python language-python">stream = NewsAPI(query=<span class="hljs-string">'apple'</span>, sources=[<span class="hljs-string">'cnn'</span>, <span class="hljs-string">'techcrunch'</span>, <span class="hljs-string">'the-verge'</span>], key=<span class="hljs-string">'xxx'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>unicode</td>
<td>API key, can be requested from <a href="https://newsapi.org/register">here</a></td>
<td>-</td>
</tr>
<tr>
<td><code>query</code></td>
<td>unicode</td>
<td>Search query. If not set, the latest articles are returned.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>lang</code></td>
<td>unicode</td>
<td>Language of text to return.</td>
<td><code>'en'</code></td>
</tr>
<tr>
<td><code>sources</code></td>
<td>unicode / iterable</td>
<td>List or comma-separated string of <a href="https://newsapi.org/sources">source IDs</a>.</td>
<td>see below</td>
</tr>
<tr>
<td><code>shuffle</code></td>
<td>bool</td>
<td>Shuffle order of sources.</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>sort_by</code></td>
<td>unicode</td>
<td>Sort priority. <code>'top'</code>, <code>'latest'</code> or <code>'popular'</code>. Note that not all options are available for all news source.</td>
<td><code>'top'</code></td>
</tr>
<tr>
<td><code>content_type</code></td>
<td>unicode</td>
<td>Type of content to display. <code>'title'</code>, <code>'description'</code> or <code>'image'</code>.</td>
<td><code>'title'</code></td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Text or image task.</td>
<td>Text</td>
</tr>
</tbody>
</table>
<h4 id="default-sources">Default sources</h4>
<pre><code class="python language-python">[<span class="hljs-string">'bbc-news'</span>, <span class="hljs-string">'al-jazeera-english'</span>, <span class="hljs-string">'associated-press'</span>, <span class="hljs-string">'bloomberg'</span>,
 <span class="hljs-string">'cnn'</span>, <span class="hljs-string">'independent'</span>, <span class="hljs-string">'recode'</span>, <span class="hljs-string">'reuters'</span>, <span class="hljs-string">'techcrunch'</span>,
 <span class="hljs-string">'the-guardian-au'</span>, <span class="hljs-string">'the-guardian-uk'</span>, <span class="hljs-string">'the-new-york-times'</span>,
 <span class="hljs-string">'the-verge'</span>, <span class="hljs-string">'the-washington-post'</span>]
</code></pre>
<h4 id="example-task-3">Example task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"US: North Korea launched new kind of missile"</span>,
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"source"</span>: <span class="hljs-string">"CNN"</span>, <span class="hljs-attr">"via"</span>: <span class="hljs-string">"News API"</span> }
}
</code></pre>
<h3 id="api-twitter"><kbd>API</kbd> Twitter</h3>
<blockquote>
  <ul>
  <li><strong>ID:</strong> <code>twitter</code></li>
  <li><strong>Component:</strong> <code>prodigy.components.loaders.Twitter</code></li>
  <li><strong>Details:</strong> <a href="https://dev.twitter.com/rest/reference/get/search/tweets">Twitter API</a></li>
  <li><strong>Rate limit:</strong> 180/15 min</li>
  </ul>
</blockquote>
<pre><code class="python language-python">key = {<span class="hljs-string">'consumer_key'</span>: <span class="hljs-string">'xxx'</span>, <span class="hljs-string">'consumer_secret'</span>: <span class="hljs-string">'xxx'</span>,
        <span class="hljs-string">'access_token'</span>: <span class="hljs-string">'xxx'</span>, <span class="hljs-string">'access_token_secret'</span>: <span class="hljs-string">'xxx'</span>}
stream = Twitter(query=<span class="hljs-string">'Berlin'</span>, key=key)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>unicode</td>
<td>Dictionary containing <code>'consumer_key'</code>, <code>'consumer_secret'</code>, <code>'access_token'</code> and <code>'access_token_secret'</code>. Can be requested from <a href="https://apps.twitter.com">here</a>.</td>
<td>-</td>
</tr>
<tr>
<td><code>query</code></td>
<td>unicode</td>
<td>Search term or query.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>content_type</code></td>
<td>unicode</td>
<td><code>'user'</code> to specify a Twitter handle as the query and only show tweets from one user's timeline. If not set, a regular search is performed.</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>sort_by</code></td>
<td>unicode</td>
<td>Sort priority. <code>'mixed'</code>, <code>'recent'</code> or <code>'popular'</code>.</td>
<td><code>'mixed'</code></td>
</tr>
<tr>
<td><code>lang</code></td>
<td>unicode</td>
<td><a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">ISO code</a> of the tweet language.</td>
<td><code>'en'</code></td>
</tr>
<tr>
<td><code>replies</code></td>
<td>bool</td>
<td>Include replies in the results.</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>retweets</code></td>
<td>bool</td>
<td>Include retweets in the results.</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>urls</code></td>
<td>bool</td>
<td>Include tweets with URLs in the results.</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>media</code></td>
<td>bool</td>
<td>Include tweets with media, like images, in the results.</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>hashtags</code></td>
<td>bool</td>
<td>Include tweets with hashtags in the results.</td>
<td><code>True</code></td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Text task.</td>
<td>Text</td>
</tr>
</tbody>
</table>
<h4 id="example-task-4">Example task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"so glad smoking in clubs isn't allowed in England my jacket fucking stinks from Berlin 😷"</span>,
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"source"</span>: <span class="hljs-string">"Twitter"</span>, <span class="hljs-attr">"date"</span>: <span class="hljs-string">"Jul 08 2017"</span>, <span class="hljs-attr">"user"</span>: <span class="hljs-string">"@User"</span> }
}
</code></pre>
<h3 id="kbdapikbd-tumblr"><kbd>API</kbd> Tumblr</h3>
<blockquote>
  <ul>
  <li><strong>ID:</strong> <code>tumblr</code></li>
  <li><strong>Component:</strong> <code>prodigy.components.loaders.Tumblr</code></li>
  <li><strong>Details:</strong> <a href="https://www.tumblr.com/docs/en/api/v2/#tagged-method">Tumblr API</a></li>
  <li><strong>Rate limit:</strong> n/a</li>
  </ul>
</blockquote>
<pre><code class="python language-python">stream = Tumblr(query=<span class="hljs-string">'grumpy cat'</span>, key=<span class="hljs-string">'xxx'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>unicode</td>
<td>API key, can be requested from <a href="https://www.tumblr.com/oauth/apps">here</a></td>
<td>-</td>
</tr>
<tr>
<td><code>query</code></td>
<td>unicode</td>
<td>Search term or query.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>content_type</code></td>
<td>unicode</td>
<td>Type of content to display. <code>'photo'</code> or <code>'tags'</code>.</td>
<td><code>'photo'</code></td>
</tr>
<tr>
<td><code>page_size</code></td>
<td>int</td>
<td>Number of results to request per page.</td>
<td><code>100</code></td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Text or image task.</td>
<td>Image</td>
</tr>
</tbody>
</table>
<h4 id="example-task-5">Example task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"https://68.media.tumblr.com/041906349bec5ccd6947ebbee4e8f07e/tumblr_oseiqqEa0Z1wtxtv6o1_1280.jpg"</span>,
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"source"</span>: <span class="hljs-string">"Tumblr"</span>, <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://tmblr.co/ZkAaXd2NTJWeO"</span> }
}
</code></pre>
<h3 id="api-github"><kbd>API</kbd> GitHub</h3>
<blockquote>
  <ul>
  <li><strong>ID:</strong> <code>github</code></li>
  <li><strong>Component:</strong> <code>prodigy.components.loaders.GitHub</code></li>
  <li><strong>Details:</strong> <a href="https://developer.github.com/v3/issues/">GitHub API</a></li>
  <li><strong>Rate limit:</strong> <a href="https://developer.github.com/v3/#rate-limiting">yes</a></li>
  </ul>
</blockquote>
<pre><code class="python language-python">stream = GitHub(query=<span class="hljs-string">'python'</span>, order=<span class="hljs-string">'desc'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>query</code></td>
<td>unicode</td>
<td>Search term or query. Supports GitHub's <a href="https://help.github.com/articles/search-syntax/">search syntax</a>.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>content_type</code></td>
<td>unicode</td>
<td>Type of content to display. <code>'title'</code>or <code>'body'</code> (not recommended without additional filtering, as it often contains lots of text and code).</td>
<td><code>'title'</code></td>
</tr>
<tr>
<td><code>order</code></td>
<td>unicode</td>
<td>Sort order. <code>'desc'</code> or <code>'asc'</code>.</td>
<td><code>'desc'</code></td>
</tr>
<tr>
<td><code>sort</code></td>
<td>unicode</td>
<td>Sort priority. <code>'created'</code>, <code>'updated'</code> or <code>'comments'</code>.</td>
<td><code>'created'</code></td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Text task.</td>
<td>Text</td>
</tr>
</tbody>
</table>
<h4 id="example-task-6">Example task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Unexpected results in Numpy datetime64 comparison within DataFrame"</span>,
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"source"</span>: <span class="hljs-string">"GitHub"</span>, <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://github.com/pandas-dev/pandas/issues/16831"</span> }
}
</code></pre>
<h3 id="api-unsplash"><kbd>API</kbd> Unsplash</h3>
<blockquote>
  <ul>
  <li><strong>ID:</strong> <code>unsplash</code></li>
  <li><strong>Component:</strong> <code>prodigy.components.loaders.Unsplash</code></li>
  <li><strong>Details:</strong> <a href="https://www.tumblr.com/docs/en/api/v2/#tagged-method">Unsplash API</a></li>
  <li><strong>Rate limit:</strong> 50-5,000/hour (free)</li>
  <li><strong>License:</strong> Free with attribution</li>
  </ul>
</blockquote>
<pre><code class="python language-python">stream = Unsplash(query=<span class="hljs-string">'food'</span>, key=<span class="hljs-string">'xxx'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key</code></td>
<td>unicode</td>
<td>API key, can be requested from <a href="https://unsplash.com/developers/terms">here</a></td>
<td>-</td>
</tr>
<tr>
<td><code>query</code></td>
<td>unicode</td>
<td>Search term or query.</td>
<td><code>''</code></td>
</tr>
<tr>
<td><code>page_size</code></td>
<td>int</td>
<td>Number of results to request per page.</td>
<td><code>30</code></td>
</tr>
<tr>
<td><code>image_size</code></td>
<td>unicode</td>
<td>Size of image to load. <code>'raw'</code>, <code>'full'</code>, <code>'regular'</code>, <code>'small'</code> or <code>'thumb'</code> (smaller images are recommended).</td>
<td><code>'small'</code></td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Image task.</td>
<td>Image</td>
</tr>
</tbody>
</table>
<h4 id="example-task-7">Example task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"https://images.unsplash.com/photo-1426869981800-95ebf51ce900?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=400&amp;fit=max&amp;s=22a57ba196375fb04b0cb14ca63caa59"</span>,
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"source"</span>: <span class="hljs-string">"Unsplash"</span>, <span class="hljs-attr">"by"</span>: <span class="hljs-string">"Brian Chan"</span>, <span class="hljs-attr">"url"</span>: <span class="hljs-string">"http://unsplash.com/@tigerrulezzz"</span> }
}
</code></pre>
<h1 id="models">Models</h1>
<h2 id="model-api">Model API</h2>
<p>Interface specification for Model components.</p>
<h3 id="kbdmethodkbd-model__call__"><kbd>METHOD</kbd> Model.__call__</h3>
<p>Predict scores for a sequence of examples.</p>
<blockquote>
  <p><strong>⚠️ Important note:</strong> Keep in mind that models yield <code>(score, example)</code>
  tuples, which can be consumed by a <a href="#sorters">sorter function</a>. If you want
  to use the unsorted output of a model as the stream returned by your recipe,
  you'll have to filter out the scores: <code>(eg for score, eg in model(stream))</code>.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>examples</code></td>
<td>iterator</td>
<td>An iterator of example objects. Each example object should be a JSON-serializable dict. The internal structure of the example depends on the task.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>tuple</td>
<td><code>(score, example)</code> pairs. The model may modify the example in-place.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-modelupdate"><kbd>METHOD</kbd> Model.update</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>examples</code></td>
<td>list</td>
<td>Each example is a dict containing the key <code>'answer'</code>, and other data that depends on the task. The <code>'answer'</code> key has three possible values: <code>'accept'</code>, <code>'reject'</code> and <code>'ignore'</code>.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>dict</td>
<td>A dictionary of statistics describing the update. Must contain at least the key <code>'loss'</code>, which should be a floating point number.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-modelevaluate"><kbd>METHOD</kbd> Model.evaluate</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>examples</code></td>
<td>list</td>
<td>Each example is a dict containing the key <code>'answer'</code>, and other data that depends on the task. The <code>'answer'</code> key has three possible values: <code>'accept'</code>, <code>'reject'</code> and <code>'ignore'</code>.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>dict</td>
<td>A dictionary of statistics describing the update. Must contain at least the key <code>'loss'</code>, which should be a floating point number.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-modelbatch_train"><kbd>METHOD</kbd> Model.batch_train</h3>
<p>Perform a training epoch on a dataset, using minibatched SGD.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>examples</code></td>
<td>list</td>
<td>A list of example records. Each record should be a dict with the keys <code>"text"</code> (string) and <code>"spans"</code> (list of dicts). Each span dict should have the keys <code>answer</code>, <code>start</code>, <code>end</code> and <code>label</code>. The value of <code>answer</code> should be one of <code>"accept"</code>, <code>"reject"</code> or <code>"ignore"</code>, and <code>start</code> and <code>end</code> should be character offsets of the span relative to the example text.</td>
</tr>
<tr>
<td><code>batch_size</code></td>
<td>int</td>
<td>The minibatch size for the updates.</td>
</tr>
<tr>
<td><code>drop</code></td>
<td>float</td>
<td>Dropout rate.</td>
</tr>
<tr>
<td><code>beam_width</code></td>
<td>int</td>
<td>Number of candidate parses to consider during training. In order to perform an update, the model finds the best parse subject to the annotation constraints. The beam width controls the depth of this search. A wider beam may improve accuracy, but will slow down training, especially on long inputs.</td>
</tr>
</tbody>
</table>
<h2 id="model-entityrecognizer">EntityRecognizer</h2>
<blockquote>
  <ul>
  <li><strong>Component:</strong> <code>prodigy.models.ner.EntityRecognizer</code></li>
  <li><strong>API:</strong> See <a href="#model-api"><code>Model</code> API</a>.</li>
  </ul>
</blockquote>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nlp</code></td>
<td><code>spacy.language.Language</code></td>
<td>spaCy <code>Language</code> object with loaded model.</td>
</tr>
<tr>
<td><code>label</code></td>
<td>list</td>
<td>The entity label(s) to recognise.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python">nlp = spacy.load(<span class="hljs-string">'en_core_web_sm'</span>)
model = EntityRecognizer(nlp, [<span class="hljs-string">'PERSON'</span>, <span class="hljs-string">'ORG'</span>])
</code></pre>
<h2 id="model-textclassifier">TextClassifier</h2>
<blockquote>
  <ul>
  <li><strong>Component:</strong> <code>prodigy.models.textcat.TextClassifier</code></li>
  <li><strong>API:</strong> See <a href="#model-api"><code>Model</code> API</a>.</li>
  </ul>
</blockquote>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nlp</code></td>
<td><code>spacy.language.Language</code></td>
<td>spaCy <code>Language</code> object with loaded model.</td>
</tr>
<tr>
<td><code>label</code></td>
<td>list</td>
<td>The label(s) to classify.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python">nlp = spacy.load(<span class="hljs-string">'en_core_web_sm'</span>)
model = TextClassifier(nlp, [<span class="hljs-string">'POSITIVE'</span>])
</code></pre>
<h2 id="model-patternmatcher">PatternMatcher</h2>
<blockquote>
  <ul>
  <li><strong>Component:</strong> <code>prodigy.models.matcher.PatternMatcher</code></li>
  </ul>
</blockquote>
<h3 id="kbdmethodkbd-patternmatcher__init__"><kbd>METHOD</kbd> PatternMatcher.__init__</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nlp</code></td>
<td><code>spacy.language.Language</code></td>
<td>spaCy <code>Language</code> object with loaded model.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td><code>PatternMatcher</code></td>
<td>The pattern matcher.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-patternmatcher__call__"><kbd>METHOD</kbd> PatternMatcher.__call__</h3>
<p>Match patterns on a stream of tasks.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of annotation examples, i.e. dictionaries.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>tuple</td>
<td><code>(score, task)</code> tuples. Tasks include a <code>"span"</code> property of the matched text as well as a <code>"label"</code>, set by the pattern. The <code>"meta"</code> includes the score and the ID of the matched pattern.</td>
</tr>
</tbody>
</table>
<p>Given a pattern like this:</p>
<pre><code class="json language-json">{ <span class="hljs-attr">"label"</span>: <span class="hljs-string">"DRUG"</span>, <span class="hljs-attr">"pattern"</span>: [{ <span class="hljs-attr">"lower"</span>: <span class="hljs-string">"fentanyl"</span> }] }
</code></pre>
<p>… a task could look like this:</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"fentanyl is dangerous"</span>,
    <span class="hljs-attr">"spans"</span>: [
        {
            <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">"end"</span>: <span class="hljs-number">8</span>,
            <span class="hljs-attr">"label"</span>: <span class="hljs-string">"DRUG"</span>,
            <span class="hljs-attr">"score"</span>: <span class="hljs-number">0.9</span>,
            <span class="hljs-attr">"priority"</span>: <span class="hljs-number">0.9</span>,
            <span class="hljs-attr">"pattern"</span>: <span class="hljs-number">1</span>
        }
    ],
    <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"score"</span>: <span class="hljs-number">0.9</span>, <span class="hljs-attr">"pattern"</span>: <span class="hljs-number">1</span> }
}
</code></pre>
<h3 id="kbdmethodkbd-patternmatcheradd_patterns"><kbd>METHOD</kbd> PatternMatcher.add_patterns</h3>
<p>Add patterns to the pattern matcher.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>patterns</code></td>
<td>list</td>
<td>The patterns to add.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-patternmatcheradd_matcher"><kbd>METHOD</kbd> PatternMatcher.add_matcher</h3>
<p>Add a new <code>Matcher</code> or <code>PhraseMatcher</code> to the pattern matcher model.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>matcher</code></td>
<td><code>Matcher</code> / <code>PatternMatcher</code></td>
<td>The matcher to add.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-patternmatcherupdate"><kbd>METHOD</kbd> PatternMatcher.update</h3>
<p>Update the pattern matcher model with annotations.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>examples</code></td>
<td>list</td>
<td>A list of dictionaries of examples.</td>
</tr>
<tr>
<td><code>drop</code></td>
<td>float</td>
<td>The dropout rate, defaults to <code>0</code>.</td>
</tr>
<tr>
<td><code>batch_size</code></td>
<td>int</td>
<td>The batch size, defaults to <code>8</code>.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>int</td>
<td><code>0</code></td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-patternmatcherfrom_disk"><kbd>METHOD</kbd> PatternMatcher.from_disk</h3>
<p>Load in a list of patterns from a file and add them to the pattern matcher.
The file should be newline-delimited JSON (JSONL) with one entry per line. See
the patterns file documentation for details.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>path</code></td>
<td>unicode or <code>Path</code></td>
<td>Path to the patterns file.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td><code>PatternMatcher</code></td>
<td>The pattern matcher with the loaded patterns.</td>
</tr>
</tbody>
</table>
<h1 id="api">API</h1>
<h2 id="top-level-functions">Top-level functions</h2>
<p>Prodigy provides the following top level utilities for writing your own scripts
and recipes. To use them, import the <code>prodigy</code> module at the top of your file.</p>
<h3 id="function-prodigyserve"><kbd>FUNCTION</kbd> prodigy.serve</h3>
<p>Serve the Prodigy web app using a recipe. Same as the <code>prodigy</code> command.</p>
<pre><code class="python language-python">prodigy.serve(<span class="hljs-string">'recipe-name'</span>, port=<span class="hljs-number">9000</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>recipe_name</code></td>
<td>unicode</td>
<td>Recipe name.</td>
</tr>
<tr>
<td><code>*args</code></td>
<td>-</td>
<td>Recipe-specific arguments, in the same order as the recipe's command-line arguments.</td>
</tr>
<tr>
<td><code>**config</code></td>
<td>-</td>
<td>Additional config parameters. Will overwrite the project-specific, global and default recipe config.</td>
</tr>
</tbody>
</table>
<h3 id="decorator-prodigyrecipe"><kbd>DECORATOR</kbd> prodigy.recipe</h3>
<p>Decorator that transforms a recipe function into a Prodigy recipe. The decorated
function needs to return a dictionary of recipe components or a <code>Controller</code>.
The decorator's first argument is the recipe name, followed by a variable number
of argument annotations, mapping to the arguments of the decorated function.
This lets you execute the recipe with Prodigy.</p>
<pre><code class="python language-python"><span class="hljs-meta">@prodigy.recipe('example', dataset=prodigy.recipe_args['dataset'], view=('View ID')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(dataset, view)</span>:</span>
    stream = ({<span class="hljs-string">'text'</span>: text} <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> TEXTS)
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'dataset'</span>: dataset,
        <span class="hljs-string">'view_id'</span>: view,
        <span class="hljs-string">'stream'</span>: stream
    }
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>unicode</td>
<td>Unique recipe name. Used to register the recipe and call it from the command line or via <code>prodigy.serve</code>.</td>
</tr>
<tr>
<td><code>**annotations</code></td>
<td>-</td>
<td>Argument annotations in <a href="https://github.com/micheles/plac">Plac</a> style, i.e. argument name mapped to tuple of description, style, shortcut and type.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>callable</td>
<td>Recipe function.</td>
</tr>
</tbody>
</table>
<h3 id="dict-prodigyrecipe-args"><kbd>DICT</kbd> prodigy.recipe_args</h3>
<p>Reusable annotations for the most common recipe arguments. Argument annotations
follow the <a href="https://github.com/micheles/plac">Plac</a> style and are a tuple of
argument description, argument position (positional, option, flag), shortcut
or <code>None</code>, and argument type.</p>
<pre><code class="python language-python"><span class="hljs-meta">@prodigy.recipe('example', dataset=prodigy.recipe_args['dataset'])</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Style</th>
<th>Shortcut</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>Dataset ID</td>
<td>positional</td>
<td><code>None</code></td>
<td>str</td>
</tr>
<tr>
<td><code>spacy_model</code></td>
<td>Loadable spaCy model</td>
<td>positional</td>
<td><code>None</code></td>
<td>str</td>
</tr>
<tr>
<td><code>output_model</code></td>
<td>Directory to save trained model</td>
<td>positional</td>
<td><code>None</code></td>
<td><code>Path</code></td>
</tr>
<tr>
<td><code>source</code></td>
<td>Source data, file path or API query</td>
<td>positional</td>
<td><code>None</code></td>
<td>str</td>
</tr>
<tr>
<td><code>patterns</code></td>
<td>Path to match patterns file</td>
<td>positional</td>
<td><code>None</code></td>
<td><code>Path</code></td>
</tr>
<tr>
<td><code>view</code></td>
<td>Annotation interface to use</td>
<td>option</td>
<td><code>v</code></td>
<td>str</td>
</tr>
<tr>
<td><code>label</code></td>
<td>Label to annotate</td>
<td>option</td>
<td><code>l</code></td>
<td>str</td>
</tr>
<tr>
<td><code>label_set</code></td>
<td>Label(s) to annotate. Comma-separated list or path to text file with one label per line.</td>
<td>option</td>
<td><code>l</code></td>
<td>list</td>
</tr>
<tr>
<td><code>loader</code></td>
<td>Loader to use (if not set, loader is based on file extension)</td>
<td>option</td>
<td><code>lo</code></td>
<td>str</td>
</tr>
<tr>
<td><code>api</code></td>
<td>API loader to use</td>
<td>option</td>
<td><code>a</code></td>
<td>str</td>
</tr>
<tr>
<td><code>sortby</code></td>
<td>Sorting mechanism</td>
<td>option</td>
<td><code>s</code></td>
<td>str</td>
</tr>
<tr>
<td><code>batch_size</code></td>
<td>Batch size</td>
<td>option</td>
<td><code>b</code></td>
<td>int</td>
</tr>
<tr>
<td><code>beam_width</code></td>
<td>Beam width</td>
<td>option</td>
<td><code>bw</code></td>
<td>int</td>
</tr>
<tr>
<td><code>n_iter</code></td>
<td>Number of iterations</td>
<td>option</td>
<td><code>n</code></td>
<td>int</td>
</tr>
<tr>
<td><code>dropout</code></td>
<td>Dropout rate</td>
<td>option</td>
<td><code>d</code></td>
<td>float</td>
</tr>
<tr>
<td><code>factor</code></td>
<td>Portion of examples to train on</td>
<td>option</td>
<td><code>f</code></td>
<td>float</td>
</tr>
<tr>
<td><code>exclude</code></td>
<td>Comma-separated list of dataset IDs whose annotations to exclude</td>
<td>option</td>
<td><code>e</code></td>
<td>str</td>
</tr>
<tr>
<td><code>eval_id</code></td>
<td>ID of evaluation dataset</td>
<td>option</td>
<td><code>e</code></td>
<td>str</td>
</tr>
<tr>
<td><code>eval_split</code></td>
<td>Portion of examples to split off for evaluation if no eval_id is provided</td>
<td>option</td>
<td><code>es</code></td>
<td>float</td>
</tr>
<tr>
<td><code>n_samples</code></td>
<td>Number of samples</td>
<td>option</td>
<td><code>ns</code></td>
<td>int</td>
</tr>
<tr>
<td><code>seeds</code></td>
<td>Path to seed terms or comma-separated list</td>
<td>option</td>
<td><code>se</code></td>
<td>str</td>
</tr>
<tr>
<td><code>lang</code></td>
<td>ISO-code of language to use if starting with a blank model</td>
<td>option</td>
<td><code>la</code></td>
<td>str</td>
</tr>
<tr>
<td><code>silent</code></td>
<td>Don't print updates</td>
<td>flag</td>
<td><code>S</code></td>
<td>bool</td>
</tr>
</tbody>
</table>
<h3 id="function-prodigyget-recipe"><kbd>FUNCTION</kbd> prodigy.get_recipe</h3>
<p>Get a recipe for a given name.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>unicode</td>
<td>The recipe name.</td>
</tr>
<tr>
<td><code>path</code></td>
<td>unicode or <code>Path</code></td>
<td>Optional path to recipe file.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>The recipe function.</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="function-prodigyset-recipe"><kbd>FUNCTION</kbd> prodigy.set_recipe</h3>
<p>Register a recipe function with a name. Also adds aliases with <code>-</code> and <code>_</code>
swapped. When you use the <code>@recipe</code> decorator, the recipe will be set
automatically.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>unicode</td>
<td>The recipe name.</td>
</tr>
<tr>
<td><code>func</code></td>
<td>callable</td>
<td>The recipe function.</td>
</tr>
</tbody>
</table>
<h3 id="function-prodigyget-config"><kbd>FUNCTION</kbd> prodigy.get_config</h3>
<p>Read and combine the user configuration from the available <code>prodigy.json</code> config
files. Helpful in recipes to read off database settings, API keys or entirely
custom config parameters.</p>
<pre><code class="python language-python">config = prodigy.get_config()
theme = config[<span class="hljs-string">'theme'</span>]
api_keys = config[<span class="hljs-string">'api_keys'</span>]
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RETURNS</strong></td>
<td>dict</td>
<td>The user configuration.</td>
</tr>
</tbody>
</table>
<h3 id="function-prodigyget-stream"><kbd>FUNCTION</kbd> prodigy.get_stream</h3>
<p>Get an iterable stream of tasks. This function is also used in recipes that
allow streaming data from a source, an API <em>or</em> standard input.</p>
<p>If an API ID is set, Prodigy will look for a
matching loader and use the <code>source</code> as the API query. If a loader ID is set,
Prodigy will look for a matching loader, and try to load the <code>source</code>. If the
<code>source</code> is a file path or <code>Path</code>-like object, Prodigy will try to guess the
loader from the file extension (defaults to <code>'jsonl'</code>). If no <code>source</code> is set,
<code>sys.stdin</code> will be used, letting you pipe through data via the
<a href="#manage-pipe"><code>pipe</code> recipe</a>.</p>
<pre><code class="python language-python">stream = prodigy.get_stream(<span class="hljs-string">'McDonalds'</span>, api=<span class="hljs-string">'twitter'</span>)
stream = prodigy.get_stream(<span class="hljs-string">'/tmp/myfile.tmp'</span>, loader=<span class="hljs-string">'txt'</span>)
stream = prodigy.get_stream(<span class="hljs-string">'/tmp/data.json'</span>, input_key=<span class="hljs-string">'text'</span>, skip_invalid=<span class="hljs-keyword">False</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source</code></td>
<td>unicode</td>
<td>A text source, e.g. a file path or an API query. Defaults to <code>sys.stdin</code> if not set.</td>
</tr>
<tr>
<td><code>api</code></td>
<td>unicode</td>
<td>ID of an API to use, e.g. <code>'nyt'</code>.</td>
</tr>
<tr>
<td><code>loader</code></td>
<td>unicode</td>
<td>ID of a loader, e.g. <code>'csv'</code>.</td>
</tr>
<tr>
<td><code>rehash</code></td>
<td>bool</td>
<td>Rehash the stream and assign new input and task IDs.</td>
</tr>
<tr>
<td><code>dedup</code></td>
<td>bool</td>
<td>Deduplicate the stream and filter out duplicate input tasks.</td>
</tr>
<tr>
<td><code>input_key</code></td>
<td>unicode</td>
<td>Optional input key relevant to this task, to filter out examples with invalid keys. For example, <code>'text'</code> for NER and text classification projects and <code>'image'</code> for image projects.</td>
</tr>
<tr>
<td><code>skip_invalid</code></td>
<td>bool</td>
<td>If an input key is set, skip invalid tasks. Defaults to <code>True</code>. If set to <code>False</code>, a <code>ValueError</code> will be raised.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>iterable</td>
<td>An iterable stream of tasks produced by the loader.</td>
</tr>
</tbody>
</table>
<p>If the <code>source</code> is an iterable stream itself – e.g. a generator or a list –
<code>get_stream</code> will simply return the stream. This is useful if you're calling an
existing recipe function from Python – for example, in your custom recipe – and
want to use an already loaded stream.</p>
<h3 id="function-prodigyget-loader"><kbd>FUNCTION</kbd> prodigy.get_loader</h3>
<p>Get a loader ID from an ID or guess a loader ID based on a file's extension.</p>
<pre><code class="python language-python">loader = prodigy.get_loader(<span class="hljs-string">'nyt'</span>)  <span class="hljs-comment"># NewYorkTimes</span>
loader = prodigy.get_loader(file_path=<span class="hljs-string">'/tmp/data.json'</span>)  <span class="hljs-comment"># JSON</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>loader_id</code></td>
<td>unicode</td>
<td>ID of a loader, e.g. <code>'nyt'</code> or <code>'csv'</code>.</td>
</tr>
<tr>
<td><code>file_path</code></td>
<td>unicode or <code>Path</code></td>
<td>Optional file path to allow guessing loader from file extension.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>callable</td>
<td>A loader.</td>
</tr>
</tbody>
</table>
<h3 id="function-prodigyset_hashes"><kbd>FUNCTION</kbd> prodigy.set_hashes</h3>
<p>Set hash IDs on a task based on the task properties. This is usually done by
Prodigy automatically as the stream is processed by the controller. However, in
some cases, you may want to take care of the hashing yourself, to implement
custom filtering.</p>
<p>Input hashes are based on the input data, like the text, image
or HTML. Task keys are based on the input hash, plus optional features you're
annotating, like the label or spans. This allows Prodigy to distinguish between
two tasks that collect annotations on the same input, but for different
features – for example, two different entities in the same text.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy <span class="hljs-keyword">import</span> set_hashes

stream = (set_hashes(eg) <span class="hljs-keyword">for</span> eg <span class="hljs-keyword">in</span> stream)
stream = (set_hashes(eg, input_keys=(<span class="hljs-string">'text'</span>, <span class="hljs-string">'custom_text'</span>)) <span class="hljs-keyword">for</span> eg <span class="hljs-keyword">in</span> stream)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>task</code></td>
<td>dict</td>
<td>The annotation task to set hashes on.</td>
</tr>
<tr>
<td><code>input_keys</code></td>
<td>tuple</td>
<td>Dictionary keys to consider for the input hash. Defaults to <code>('text', 'image', 'html', 'input')</code>.</td>
</tr>
<tr>
<td><code>task_keys</code></td>
<td>tuple</td>
<td>Dictionary keys to consider for the task hash. Defaults to <code>('spans', 'label', 'options')</code>.</td>
</tr>
<tr>
<td><code>overwrite</code></td>
<td>bool</td>
<td>Overwrite existing hashes in the task. Defaults to <code>False</code>.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>dict</td>
<td>The task with hashes set.</td>
</tr>
</tbody>
</table>
<h3 id="function-prodigyget_schema"><kbd>FUNCTION</kbd> prodigy.get_schema</h3>
<p>Get the <a href="http://json-schema.org/">JSON schema</a> for a given <code>view_id</code>. This is
the schema that Prodigy will validate against when you run a recipe. The
JSON schemas describe the properties and types needed in order for an interface
to render your task. The very first batch of the stream is validated <em>before</em>
the server starts. After that, tasks in the stream are validated before
they're sent out to the web app. To disabled validation, set <code>"validate": false</code>
in your Prodigy config.</p>
<pre><code class="python language-python">schema = prodigy.get_schema(<span class="hljs-string">'text'</span>)
</code></pre>
<pre><code class="json language-json">{
    <span class="hljs-attr">"title"</span>: <span class="hljs-string">"Text Task"</span>,
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"object"</span>,
    <span class="hljs-attr">"properties"</span>: {
        <span class="hljs-attr">"text"</span>: {
            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"string"</span>
        },
        <span class="hljs-attr">"_task_hash"</span>: {
            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"integer"</span>
        },
        <span class="hljs-attr">"_input_hash"</span>: {
            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"integer"</span>
        },
        <span class="hljs-attr">"meta"</span>: {
            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"object"</span>
        }
    },
    <span class="hljs-attr">"additionalProperties"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"required"</span>: [<span class="hljs-string">"text"</span>, <span class="hljs-string">"_task_hash"</span>, <span class="hljs-string">"_input_hash"</span>]
}
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view_id</code></td>
<td>unicode</td>
<td>One of the available <a href="#annotation-interfaces">interface IDs</a>, e.g. <code>ner</code>.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>dict</td>
<td>The expected JSON schema for a task rendered by the interface.</td>
</tr>
</tbody>
</table>
<h3 id="function-prodigylog"><kbd>FUNCTION</kbd> prodigy.log</h3>
<p>Add an entry to Prodigy's log. For more details, see the docs on
<a href="#debugging-and-logging">debugging and logging</a>.</p>
<pre><code class="python language-python">prodigy.log(<span class="hljs-string">'RECIPE: Starting recipe custom-recipe'</span>, locals())
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message</code></td>
<td>unicode</td>
<td>The basic message to display, e.g. "RECIPE: Starting recipe ner.teach".</td>
</tr>
<tr>
<td><code>details</code></td>
<td>-</td>
<td>Optional details to log only in <code>verbose</code> mode.</td>
</tr>
</tbody>
</table>
<h2 id="filters">Filters</h2>
<blockquote>
  <ul>
  <li><strong>Module:</strong> <code>prodigy.components.filters</code></li>
  </ul>
</blockquote>
<p>Filters are helper functions used across recipes that wrap a stream and filter
it based on certain conditions.</p>
<h3 id="kbdfunctionkbd-filter_empty"><kbd>FUNCTION</kbd> filter_empty</h3>
<p>Remove examples with a missing, empty or otherwise falsy value from a stream.
This filter can also be enabled by specifying an <code>input_key</code> argument on the
<code>get_stream</code> helper function.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.filters <span class="hljs-keyword">import</span> filter_empty
stream = [{<span class="hljs-string">'text'</span>: <span class="hljs-string">'test'</span>}, {<span class="hljs-string">'image'</span>: <span class="hljs-string">'test.jpg'</span>}, {<span class="hljs-string">'text'</span>: <span class="hljs-string">''</span>}]
stream = filter_empty(stream, key=<span class="hljs-string">'text'</span>)
<span class="hljs-comment"># [{'text': 'test'}]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of examples.</td>
</tr>
<tr>
<td><code>key</code></td>
<td>unicode</td>
<td>The key in the annotation task to check, e.g. <code>'text'</code>.</td>
</tr>
<tr>
<td><code>skip</code></td>
<td>bool</td>
<td>Skip filtered examples. If set to <code>False</code>, a <code>ValueError</code> is raised. Defaults to <code>True</code>.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Filtered annotation examples.</td>
</tr>
</tbody>
</table>
<h3 id="kbdfunctionkbd-filter_duplicates"><kbd>FUNCTION</kbd> filter_duplicates</h3>
<p>Filter duplicate examples from a stream. You can choose to filter by task, which
includes the input data as well as the added spans, labels etc., or by input
data only. This filter can also enabled by setting <code>dedup=True</code> on the
<code>get_stream</code> helper function.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.filters <span class="hljs-keyword">import</span> filter_duplicates

stream = [{<span class="hljs-string">'text'</span>: <span class="hljs-string">'foo'</span>, <span class="hljs-string">'label'</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-string">'text'</span>: <span class="hljs-string">'foo'</span>, <span class="hljs-string">'label'</span>: <span class="hljs-string">'bar'</span>},
          {<span class="hljs-string">'text'</span>: <span class="hljs-string">'foo'</span>}]
stream = filter_duplicates(stream, by_input=<span class="hljs-keyword">False</span>, by_task=<span class="hljs-keyword">True</span>)
<span class="hljs-comment"># [{'text': 'foo', 'label': 'bar'}, {'text': 'foo'}]</span>
stream = filter_duplicates(stream, by_input=<span class="hljs-keyword">True</span>, by_task=<span class="hljs-keyword">True</span>)
<span class="hljs-comment"># [{'text': 'foo', 'label': 'bar'}]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of examples.</td>
</tr>
<tr>
<td><code>by_input</code></td>
<td>bool</td>
<td>Filter out duplicates of the same input data. Defaults to <code>False</code>.</td>
</tr>
<tr>
<td><code>by_task</code></td>
<td>bool</td>
<td>Filter out duplicates of the same task data. Defaults to <code>True</code>.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Filtered annotation examples.</td>
</tr>
</tbody>
</table>
<h3 id="kbdfunctionkbd-filter_inputs"><kbd>FUNCTION</kbd> filter_inputs</h3>
<p>Filter out tasks based on a list of input hashes, referring to the input data.
Useful for filtering out already annotated tasks. To get the task hashes
of one or more datasets, you can use <code>db.get_input_hashes(*dataset_names)</code>.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.filters <span class="hljs-keyword">import</span> filter_inputs
stream = [{<span class="hljs-string">'_input_hash'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'text'</span>: <span class="hljs-string">'foo'</span>}, {<span class="hljs-string">'_input_hash'</span>: <span class="hljs-number">9</span>, <span class="hljs-string">'text'</span>: <span class="hljs-string">'bar'</span>}]
stream = filter_inputs(stream, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])
<span class="hljs-comment"># [{'_input_hash': 9, 'text': 'bar'}]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of examples.</td>
</tr>
<tr>
<td><code>input_ids</code></td>
<td>list</td>
<td>The input IDs to filter out.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Filtered annotation examples.</td>
</tr>
</tbody>
</table>
<h3 id="kbdfunctionkbd-filter_tasks"><kbd>FUNCTION</kbd> filter_tasks</h3>
<p>Filter out tasks based on a list of task hashes, referring to the input data
plus the added spans, label etc. Useful for filtering out already annotated tasks and used by Prodigy's built-in <code>--exclude</code> logic. To get the task hashes
of one or more datasets, you can use <code>db.get_task_hashes(*dataset_names)</code>.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.filters <span class="hljs-keyword">import</span> filter_tasks
stream = [{<span class="hljs-string">'_task_hash'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'text'</span>: <span class="hljs-string">'foo'</span>}, {<span class="hljs-string">'_task_hash'</span>: <span class="hljs-number">9</span>, <span class="hljs-string">'text'</span>: <span class="hljs-string">'bar'</span>}]
stream = filter_tasks(stream, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])
<span class="hljs-comment"># [{'_task_hash': 9, 'text': 'bar'}]</span>
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of examples.</td>
</tr>
<tr>
<td><code>task_ids</code></td>
<td>list</td>
<td>The task IDs to filter out.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Filtered annotation examples.</td>
</tr>
</tbody>
</table>
<h2 id="sorters">Sorters</h2>
<blockquote>
  <ul>
  <li><strong>Module:</strong> <code>prodigy.components.sorters</code></li>
  </ul>
</blockquote>
<p>Sorters are helper functions that wrap a stream of <code>(score, example)</code> tuples,
(usually returned by a model), resort it and yield examples in the new order.
All sorters follow the same API and take two arguments:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream to sort.</td>
</tr>
<tr>
<td><code>bias</code></td>
<td>float</td>
<td>Bias towards high or low scoring.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>Annotation examples.</td>
</tr>
</tbody>
</table>
<p>The following sorters are available and can be imported from
<code>prodigy.components.sorters</code>:</p>
<table>
<thead>
<tr>
<th>Sorter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>prefer_uncertain</code></td>
<td>Resort stream to prefer uncertain scores.</td>
</tr>
<tr>
<td><code>prefer_high_scores</code></td>
<td>Resort the stream to prefer high scores.</td>
</tr>
<tr>
<td><code>prefer_low_scores</code></td>
<td>Resort the stream to prefer low scores.</td>
</tr>
</tbody>
</table>
<p>The <code>prefer_uncertain</code> function also supports an additional keyword argument
<code>algorithm</code>, that lets you specify either <code>"probability"</code> or <code>"ema"</code>
(exponential moving average).</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.models.ner <span class="hljs-keyword">import</span> EntityRecognizer
<span class="hljs-keyword">from</span> prodigy.components.sorters <span class="hljs-keyword">import</span> prefer_uncertain

model = EntityRecognizer(nlp)
stream = prefer_uncertain(model(stream))
</code></pre>
<h2 id="preprocess">Preprocess</h2>
<blockquote>
  <ul>
  <li><strong>Module:</strong> <code>prodigy.components.preprocess</code></li>
  </ul>
</blockquote>
<p>Preprocessors convert and modify a stream of examples and their properties, or
pre-process documents before annotation.</p>
<h3 id="kbdfunctionkbd-split_sentences"><kbd>FUNCTION</kbd> split_sentences</h3>
<p>Use spaCy's sentence boundary detector to split example text into sentences,
convert the existing <code>"spans"</code> and their start and end positions accordingly
and yield one example per sentence. Setting a <code>min_length</code> will only split texts
longer than a certain number of characters. This lets you use your own logic,
while still preventing very long examples from throwing off the beam search
algorithm and affecting performance. If no <code>min_length</code> is set, Prodigy will
check the config for a <code>'split_sents_threshold'</code> setting.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nlp</code></td>
<td><code>spacy.language.Language</code></td>
<td>A spaCy <code>nlp</code> object with a sentence boundary detector (a custom implementation or any model that supports dependency parsing).</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of examples.</td>
</tr>
<tr>
<td><code>text_key</code></td>
<td>unicode</td>
<td>Task key containing the text. Defaults to <code>'text'</code>.</td>
</tr>
<tr>
<td><code>batch_size</code></td>
<td>int</td>
<td>Batch size to use when processing the examples with <code>nlp.pipe</code>. Defaults to <code>32</code>.</td>
</tr>
<tr>
<td><code>min_length</code></td>
<td>int</td>
<td>Minimum character length of text to be split. If <code>None</code>, Prodigy will check the config for a <code>'split_sents_threshold'</code> setting. If <code>False</code>, all texts are split, if possible. Defaults to <code>False</code>.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>The individual sentences as annotation examples.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.preprocess <span class="hljs-keyword">import</span> split_sentences
<span class="hljs-keyword">import</span> spacy

nlp = spacy.load(<span class="hljs-string">'en'</span>)
stream = [{<span class="hljs-string">'text'</span>: <span class="hljs-string">'spaCy is a library. It is written in Python.'</span>}]
stream = split_sentences(nlp, stream, min_length=<span class="hljs-number">30</span>)
</code></pre>
<h3 id="kbdfunctionkbd-split_spans"><kbd>FUNCTION</kbd> split_spans</h3>
<p>Split a stream with multiple spans per example so that there's one span per
task.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of examples.</td>
</tr>
<tr>
<td><code>labels</code></td>
<td>list</td>
<td>Only create examples for entities of those labels. If <code>None</code>, all entities will be used.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>The annotation examples.</td>
</tr>
</tbody>
</table>
<h3 id="kbdfunctionkbd-add_tokens"><kbd>FUNCTION</kbd> add_tokens</h3>
<p>Tokenize the incoming text and add a <code>'tokens'</code> key to each example in the
stream. If the example has spans, each span is updated with a <code>"token_start"</code>
and <code>"token_end"</code> key. This pre-processor is mostly used in for manual NER
annotation to allow entity annotation based on token boundaries.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nlp</code></td>
<td><code>spacy.language.Language</code></td>
<td>A spaCy <code>nlp</code> object with a tokenizer.</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of examples.</td>
</tr>
<tr>
<td><code>skip</code></td>
<td>bool</td>
<td>Don't raise <code>ValueError</code> for mismatched tokenization and skip example instead. Defaults to <code>False</code>.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>The annotation examples with added tokens.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.preprocess <span class="hljs-keyword">import</span> add_tokens
<span class="hljs-keyword">import</span> spacy

nlp = spacy.load(<span class="hljs-string">'en'</span>)
stream = [{<span class="hljs-string">'text'</span>: <span class="hljs-string">'Hello world'</span>}, {<span class="hljs-string">'text'</span>: <span class="hljs-string">'Another text'</span>}]
stream = add_tokens(nlp, stream, skip=<span class="hljs-keyword">True</span>)
</code></pre>
<h3 id="kbdfunctionkbd-fetch_images"><kbd>FUNCTION</kbd> fetch_images</h3>
<p>Replace all image paths and URLs in a stream with base64 data URIs. The <code>skip</code>
keyword argument lets you specify whether to skip invalid images that can't be
converted (for example, because the path doesn't exist, or the URL can't be
fetched). If set to <code>False</code>, Prodigy will raise a <code>ValueError</code> if it encounters
invalid images.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of examples.</td>
</tr>
<tr>
<td><code>image_key</code></td>
<td>unicode</td>
<td>The task key containing the image. Defaults to <code>'image'</code>.</td>
</tr>
<tr>
<td><code>skip</code></td>
<td>bool</td>
<td>Skip and don't include tasks with images that can't be fetched. Defaults to <code>False</code>, which will raise a <code>ValueError</code>.</td>
</tr>
<tr>
<td><strong>YIELDS</strong></td>
<td>dict</td>
<td>The annotation examples with converted images.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.preprocess <span class="hljs-keyword">import</span> fetch_images

stream = [{<span class="hljs-string">'image'</span>: <span class="hljs-string">'/path/to/image.jpg'</span>}, {<span class="hljs-string">'image'</span>: <span class="hljs-string">'https://example.com/image.jpg'</span>}]
stream = fetch_images(stream, skip=<span class="hljs-keyword">True</span>)
</code></pre>
<h2 id="controller">Controller</h2>
<p>The controller takes care of putting the individual recipe components together
and exposes methods that allow the application to interact with the REST API.
This is usually done when you use the <code>@recipe</code> decorator on a function that
returns a dictionary of components. However, you can also choose to initialise
a <code>Controller</code> yourself and make your recipe return it.</p>
<h3 id="kbdmethodkbd-controller__init__"><kbd>METHOD</kbd> Controller.__init__</h3>
<p>Initialise the controller.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.controller <span class="hljs-keyword">import</span> Controller
controller = Controller(dataset, view_id, stream, update, store, progress, on_load, on_exit, get_session_id, exclude, config)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dataset</code></td>
<td>unicode</td>
<td>The ID of the current project.</td>
</tr>
<tr>
<td><code>view_id</code></td>
<td>unicode</td>
<td>The annotation interface to use.</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>iterable</td>
<td>The stream of annotation tasks.</td>
</tr>
<tr>
<td><code>update</code></td>
<td>callable</td>
<td>The update function called when annotated tasks are received.</td>
</tr>
<tr>
<td><code>db</code></td>
<td>callable</td>
<td>The database ID, component or custom storage function.</td>
</tr>
<tr>
<td><code>progress</code></td>
<td>callable</td>
<td>The progress function that computes the annotation progress.</td>
</tr>
<tr>
<td><code>on_load</code></td>
<td>callable</td>
<td>The on load function that gets called when Prodigy is started.</td>
</tr>
<tr>
<td><code>on_exit</code></td>
<td>callable</td>
<td>The on exit function that gets called when the user exits Prodigy.</td>
</tr>
<tr>
<td><code>get_session_id</code></td>
<td>callable</td>
<td>Function that returns a custom session ID. If not set, a timestamp is used.</td>
</tr>
<tr>
<td><code>exclude</code></td>
<td>list</td>
<td>List of dataset IDs whose annotations to exclude.</td>
</tr>
<tr>
<td><code>config</code></td>
<td>dict</td>
<td>Recipe-specific configuration.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td><code>Controller</code></td>
<td>The recipe controller.</td>
</tr>
</tbody>
</table>
<p>All arguments of the controller are also accessible as attributes, for example
<code>controller.store</code>. In addition, the controller exposes the following
attributes:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>home</code></td>
<td><code>Path</code></td>
<td>Path to Prodigy home directory.</td>
</tr>
<tr>
<td><code>session_id</code></td>
<td>unicode</td>
<td>ID of the current session, generated from a timestamp.</td>
</tr>
<tr>
<td><code>batch_size</code></td>
<td>int</td>
<td>The number of tasks to return at once. Taken from <code>config</code> and defaults to <code>10</code>.</td>
</tr>
<tr>
<td><code>queue</code></td>
<td>generator</td>
<td>The batched-up stream of annotation tasks.</td>
</tr>
<tr>
<td><code>total_annotated</code></td>
<td>int</td>
<td>Number of tasks annotated in the current project.</td>
</tr>
<tr>
<td><code>session_annotated</code></td>
<td>int</td>
<td>Number of tasks annotated in the current session.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-controllerget_questions"><kbd>METHOD</kbd> Controller.get_questions</h3>
<p>Get a batch of annotation tasks from the <code>queue</code>.</p>
<pre><code class="python language-python">next_batch = controller.get_questions()
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RETURNS</strong></td>
<td>list</td>
<td>Batch of annotation tasks.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-controllerreceive_answers"><kbd>METHOD</kbd> Controller.receive_answers</h3>
<p>Receive a batch of annotated tasks. If available, stores the tasks in the
database and calls the <code>update</code> function.</p>
<pre><code class="python language-python">tasks = [{<span class="hljs-string">'id'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'text'</span>: <span class="hljs-string">'x'</span>, <span class="hljs-string">'answer'</span>: <span class="hljs-string">'accept'</span>},
            {<span class="hljs-string">'id'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'text'</span>: <span class="hljs-string">'y'</span>, <span class="hljs-string">'answer'</span>: <span class="hljs-string">'reject'</span>}]
controller.receive_answers(tasks)
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>answers</code></td>
<td>list</td>
<td>Annotated tasks.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-controllersave"><kbd>METHOD</kbd> Controller.save</h3>
<p>Saves the current project and progress when the user exits the application. If
available, calls the store's <code>save</code> method and the <code>on_exit</code> function.</p>
<h3 id="kbdpropertykbd-controllerprogress"><kbd>PROPERTY</kbd> Controller.progress</h3>
<p>Get the current progress. If available, calls the <code>progress</code> function.
Otherwise, it checks whether the <code>stream</code> has a length and returns the quotient
of the session annotations and stream length. Otherwise, it returns <code>None</code>. A
progress of <code>None</code> is visualised with an inifinity symbol in the web
application.</p>
<pre><code class="python language-python">progress = controller.progress
</code></pre>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RETURNS</strong></td>
<td>float or <code>None</code></td>
<td>The current annotation progress.</td>
</tr>
</tbody>
</table>
<h2 id="db">DB</h2>
<p>All supported database interfaces are available via the <code>db</code> component. For more
information on Prodigy's database options, see the
<a href="#database-setup">database setup documentation</a>. Prodigy uses <a href="http://docs.peewee-orm.com/en/latest/">peewee</a> as its ORM, which means you can plug
in any database solutions and <a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html">extensions</a> supported by the
package.</p>
<h3 id="kbdfunctionkbd-connect"><kbd>FUNCTION</kbd> connect</h3>
<p>Prodigy provides a simple connection helper that takes care of connecting to
one of the built-in database options using the database ID and database
settings. If no database config is provided, it will be read off the
<code>prodigy.json</code> settings, and default to <code>'sqlite'</code> with the standard settings.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>db_id</code></td>
<td>unicode</td>
<td>ID of database, i.e. <code>'sqlite'</code>, <code>'postgresql'</code> or <code>'mysql'</code>. Defaults to <code>'sqlite'</code>.</td>
</tr>
<tr>
<td><code>db_settings</code></td>
<td>dict</td>
<td>Database-specific settings. If not provided, settings will be read off the <code>prodigy.json</code>.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td><code>Database</code></td>
<td>The database.</td>
</tr>
</tbody>
</table>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.db <span class="hljs-keyword">import</span> connect

db = connect(<span class="hljs-string">'sqlite'</span>, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'my_db.db'</span>})
</code></pre>
<h3 id="kbdmethodkbd-database__init__"><kbd>METHOD</kbd> Database.__init__</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>db</code></td>
<td><code>peewee.Database</code></td>
<td><a href="http://docs.peewee-orm.com/en/latest/">peewee</a> database. Will be available as the <code>db</code> attribute of the database.</td>
</tr>
<tr>
<td><code>display_id</code></td>
<td>unicode</td>
<td>ID of database, e.g. <code>'sqlite'</code>. Will be available as the <code>db_id</code> attribute of the database. For custom databases plugged in by the user, the ID will default to <code>'custom'</code>.</td>
</tr>
<tr>
<td><code>display_name</code></td>
<td>unicode</td>
<td>Human-readable name of the database, e.g. <code>'SQLite'</code>. Will be available as the <code>db_name</code> attribute. For custom database module, the display name will defaults to the function name, class name, or <code>repr(db)</code>.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td><code>Database</code></td>
<td>The database.</td>
</tr>
</tbody>
</table>
<p>To plug in custom database, you can initialise the <code>Database</code> class with a
custom instance of <code>peewee.Database</code> or its extension package
<a href="http://docs.peewee-orm.com/en/latest/peewee/playhouse.html">Playhouse</a>,
for example:</p>
<pre><code class="python language-python"><span class="hljs-keyword">import</span> prodigy
<span class="hljs-keyword">from</span> prodigy.components.db <span class="hljs-keyword">import</span> Database
<span class="hljs-keyword">from</span> playhouse.postgres_ext <span class="hljs-keyword">import</span> PostgresqlExtDatabase

psql_db = PostgresqlExtDatabase(<span class="hljs-string">'my_database'</span>, user=<span class="hljs-string">'postgres'</span>)
db = Database(psql_db, <span class="hljs-string">'postgresql'</span>, <span class="hljs-string">'Custom PostgreSQL Database'</span>)

<span class="hljs-meta">@prodigy.recipe('recipe-with-custom-db')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recipe_with_custom_db</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">return</span> {<span class="hljs-string">'db'</span>: db}
</code></pre>
<h3 id="kbdmethodkbd-database__len__"><kbd>METHOD</kbd> Database.__len__</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RETURNS</strong></td>
<td>int</td>
<td>The number of datasets in the database.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-database__contains__"><kbd>METHOD</kbd> Database.__contains__</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>unicode</td>
<td>Dataset ID.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>bool</td>
<td>Whether the dataset exists in the database.</td>
</tr>
</tbody>
</table>
<h3 id="kbdpropertykbd-databasedatasets"><kbd>PROPERTY</kbd> Database.datasets</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RETURNS</strong></td>
<td>list</td>
<td>A list of all dataset IDs in the database (excluding sessions).</td>
</tr>
</tbody>
</table>
<h3 id="kbdpropertykbd-databasesessions"><kbd>PROPERTY</kbd> Database.sessions</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RETURNS</strong></td>
<td>list</td>
<td>A list of all session IDs in the database (excluding user-created datasets).</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databasereconnect"><kbd>METHOD</kbd> Database.reconnect</h3>
<p>Reconnect to the database. Called on API requests to avoid timeout issues,
especiallly with MySQL. If the database connection is still open, it will be
closed before reconnecting.</p>
<h3 id="kbdmethodkbd-databaseclose"><kbd>METHOD</kbd> Database.close</h3>
<p>Close the database connection (if not already closed). Called after API requests
to avoid timeout issues, especially with MySQL.</p>
<h3 id="kbdmethodkbd-databaseget_dataset"><kbd>METHOD</kbd> Database.get_dataset</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>unicode</td>
<td>The dataset ID.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>list</td>
<td>A list of all examples in the dataset.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databaseget_meta"><kbd>METHOD</kbd> Database.get_meta</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>unicode</td>
<td>The dataset ID.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>dict</td>
<td>The meta data associated with the dataset.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databaseget_examples"><kbd>METHOD</kbd> Database.get_examples</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ids</code></td>
<td>list</td>
<td>A list of task IDs.</td>
</tr>
<tr>
<td><code>by</code></td>
<td>unicode</td>
<td>Select by field, defaults to <code>task_hash</code>.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>list</td>
<td>The examples with the given IDs.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databaseget_input_hashes"><kbd>METHOD</kbd> Database.get<em>input</em>hashes</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*names</code></td>
<td>list</td>
<td>Dataset IDs.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>set</td>
<td>A set of input hashes for examples of the given datasets.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databaseget_task_hashes"><kbd>METHOD</kbd> Database.get<em>task</em>hashes</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*names</code></td>
<td>list</td>
<td>Dataset IDs.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>set</td>
<td>A set of task hashes for examples of the given datasets.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databaseadd_dataset"><kbd>METHOD</kbd> Database.add_dataset</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>unicode</td>
<td>The dataset ID.</td>
</tr>
<tr>
<td><code>meta</code></td>
<td>dict</td>
<td>The dataset meta.</td>
</tr>
<tr>
<td><code>session</code></td>
<td>bool</td>
<td>Whether dataset is a session.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>list</td>
<td>The dataset.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databaseadd_examples"><kbd>METHOD</kbd> Database.add_examples</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>examples</code></td>
<td>list</td>
<td>A list of annotated examples.</td>
</tr>
<tr>
<td><code>datasets</code></td>
<td>list</td>
<td>A list of datasets to add the examples to.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databaselink"><kbd>METHOD</kbd> Database.link</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>unicode</td>
<td>The dataset ID.</td>
</tr>
<tr>
<td><code>example_ids</code></td>
<td>list</td>
<td>IDs of examples to link to the dataset.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databaseunlink"><kbd>METHOD</kbd> Database.unlink</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>example_ids</code></td>
<td>list</td>
<td>IDs of examples to unlink.</td>
</tr>
</tbody>
</table>
<h3 id="kbdmethodkbd-databasedrop_dataset"><kbd>METHOD</kbd> Database.drop_dataset</h3>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>list</td>
<td>The dataset ID.</td>
</tr>
<tr>
<td><code>batch_size</code></td>
<td>int</td>
<td>Delete examples in batches of the given size.</td>
</tr>
<tr>
<td><strong>RETURNS</strong></td>
<td>bool</td>
<td>Whether the dataset was successfully deleted.</td>
</tr>
</tbody>
</table>
<h2 id="rest-api">REST API</h2>
<p>Prodigy communicates with its web application via a REST API. You can also use
this API to send requests to Prodigy directly, to the same port that's running
the web application. By default,
<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">cross-origin resource sharing</a>
(CORS) is enabled, allowing you to make a request from a different origin, like
a different port or domain. To disable CORS, set <code>"cors": false</code> in your
configuration file.</p>
<h3 id="get-project"><kbd>GET</kbd> /project</h3>
<p>Get a project's meta data and the current configuration. The web app makes one
request to this endpoint on load to fetch the project information (displayed in
the sidebar) and the front-end settings.</p>
<h4 id="example-response">Example response</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"id"</span>: <span class="hljs-string">"dataset"</span>,
    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"Project description"</span>,
    <span class="hljs-attr">"author"</span>: <span class="hljs-string">"You"</span>,
    <span class="hljs-attr">"theme"</span>: <span class="hljs-string">"basic"</span>,
    <span class="hljs-attr">"view_id"</span>: <span class="hljs-string">"ner"</span>,
    <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>
}
</code></pre>
<h3 id="get-get-questions"><kbd>GET</kbd> /get_questions</h3>
<p>Get a new queue of tasks. The number of new tasks sent with each request can be
specified via the <code>batch_size</code> setting of a recipe or in your Prodigy config. On
each request, the endpoint also returns the number of total annotations and the
progress calculated by the annotation recipe.</p>
<h4 id="example-response-1">Example response</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"tasks"</span>: [
        {
            <span class="hljs-attr">"id"</span>: <span class="hljs-number">10354113762182654000</span>,
            <span class="hljs-attr">"spans"</span>: [
                {
                    <span class="hljs-attr">"start"</span>: <span class="hljs-number">16</span>,
                    <span class="hljs-attr">"end"</span>: <span class="hljs-number">22</span>,
                    <span class="hljs-attr">"label"</span>: <span class="hljs-string">"ORG"</span>
                }
            ],
            <span class="hljs-attr">"score"</span>: <span class="hljs-number">0.340494123</span>,
            <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Check it out in action."</span>
        }
    ],
    <span class="hljs-attr">"total"</span>: <span class="hljs-number">268</span>,
    <span class="hljs-attr">"progress"</span>: <span class="hljs-number">0.19027213177874192</span>
}
</code></pre>
<h3 id="post-give-answers"><kbd>POST</kbd> /give_answers</h3>
<p>Send a list of annotated tasks containing an answer key and receive a progress.
The web app makes a request to this endpoint every time a batch is annotated, or
if the user chooses to manually save the current progress. The lower the
<code>batch_size</code>, the more frequent the updates.</p>
<h4 id="example-request">Example request</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"answers"</span>: [
        {
            <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"reject"</span>,
            <span class="hljs-attr">"id"</span>: <span class="hljs-number">10354113762182654000</span>,
            <span class="hljs-attr">"spans"</span>: [
                {
                    <span class="hljs-attr">"start"</span>: <span class="hljs-number">16</span>,
                    <span class="hljs-attr">"end"</span>: <span class="hljs-number">22</span>,
                    <span class="hljs-attr">"label"</span>: <span class="hljs-string">"ORG"</span>
                }
            ],
            <span class="hljs-attr">"score"</span>: <span class="hljs-number">0.340494123</span>,
            <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Check it out in action."</span>
        }
    ]
}
</code></pre>
<h4 id="example-response-2">Example response</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"progress"</span>: <span class="hljs-number">0.19027213177874192</span>
}
</code></pre>
<h2 id="entry-points">Entry Points</h2>
<p>Plugging in your own loaders or database connectors usually required writing a custom recipe – even if you don't want to change anything about the built-in
recipes themselves. Prodigy <code>v1.5.0</code> introduces a new way of making your own
functions available to built-in recipes and CLI commands, without having to
modify the source. All you need is a simple Python package that exposes your
components via <code>entry_points</code>, and is installed in the same environment as
Prodigy. For a quick introduction to entry points in Python, we recommend
<a href="http://amir.rachum.com/blog/2017/07/28/python-entry-points/">this blog post</a>.</p>
<p>Consider the following structure of your <code>prodigy_utils</code> package:</p>
<pre><code class="yaml language-yaml"><span class="hljs-string">└──</span> <span class="hljs-string">prodigy_utils</span>       <span class="hljs-comment"># package directory</span>
    <span class="hljs-string">├──</span> <span class="hljs-string">recipes.py</span>      <span class="hljs-comment"># recipe functions</span>
    <span class="hljs-string">├──</span> <span class="hljs-string">loaders.py</span>      <span class="hljs-comment"># loader functions</span>
    <span class="hljs-string">├──</span> <span class="hljs-string">db.py</span>           <span class="hljs-comment"># database classes</span>
    <span class="hljs-string">└──</span> <span class="hljs-string">setup.py</span>        <span class="hljs-comment"># package setup</span>
</code></pre>
<p>In the <code>setup.py</code>, you can then define a dictionary of <code>entry_points</code> for one
or more of the available categories. Each category is mapped to a list of
strings in the format <code>[name] = module:function</code>. For example,
<code>'custom_json = loaders:CustomJSON'</code> will make the function or class
<code>CustomJSON</code> in the file <code>loaders.py</code> available via the name <code>custom_json</code>.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup

setup(
    name=<span class="hljs-string">'prodigy_utils'</span>,
    entry_points={
        <span class="hljs-string">'prodigy_recipes'</span>: [
            <span class="hljs-string">'custom_recipe = recipes:custom_recipe'</span>
        ],
        <span class="hljs-string">'prodigy_loaders'</span>: [
            <span class="hljs-string">'database = loaders:DatabaseLoader'</span>,
            <span class="hljs-string">'custom_json = loaders:CustomJSON'</span>
        ],
        <span class="hljs-string">'prodigy_db'</span>: [
            <span class="hljs-string">'mongodb = db:MongoDBLoader'</span>
        ]
    },
    requirements=[
        <span class="hljs-string">'prodigy&gt;=1.4.3,&lt;1.5.0'</span>
    ]
)
</code></pre>
<p>Prodigy checks the following entry point categories:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>prodigy_recipes</code></td>
<td>Custom recipe functions, one entry per recipe.</td>
</tr>
<tr>
<td><code>prodigy_loaders</code></td>
<td>File or API loaders.</td>
</tr>
<tr>
<td><code>prodigy_db</code></td>
<td>Database connectors that follow the same API as Prodigy's <a href="#db"><code>Database</code></a> class.</td>
</tr>
</tbody>
</table>
<p>To install your package and expose the entry points, navigate to the package
directory and run the setup – for example, in <a href="https://stackoverflow.com/questions/19048732/python-setup-py-develop-vs-install">development mode</a>:</p>
<pre><code class="bash language-bash"><span class="hljs-built_in">cd</span> prodigy_utils
python setup.py develop
</code></pre>
<p>If your package is installed in the same environment, you won't have to do
anything else. Prodigy will automatically find and load your entry points. To
verify that your entry points were read in correctly, you can set the
<code>PRODIGY_LOGGING=basic</code> environment variable. On startup, Prodigy will log how
many components were added via entry points.</p>
<p>You can then refer to your custom components by name, for example:</p>
<pre><code class="bash language-bash">prodigy custom_recipe your_dataset
prodigy ner.teach your_dataset en_core_web_sm data.json --loader custom_json
</code></pre>
<h3 id="file-loader-api">File loader API</h3>
<p>All file loaders follow the same API. At a minimum, your custom loader needs to
be a function that takes a <code>source</code> argument and yields annotation tasks. Of
course, you can also implement a more complex class that exposes an <code>__iter__</code>
method.</p>
<pre><code class="python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loader</span><span class="hljs-params">(source)</span>:</span>
    <span class="hljs-keyword">with</span> open(source) <span class="hljs-keyword">as</span> f:
        lines = f.read()
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:
        <span class="hljs-keyword">yield</span> {<span class="hljs-string">'text'</span>: line}
</code></pre>
<p>The source is what you pass in as the <code>source</code> argument on the command line. It
can be the path to a file, but also any other string, like database connection
parameters or an API query. Here are some fictional examples:</p>
<pre><code class="bash language-bash">prodigy ner.teach your_set en_core_web_sm file.pdf --loader pdf
prodigy ner.teach your_set en_core_web_sm <span class="hljs-string">"xxx.amazonaws.com:1433"</span> --loader aws
</code></pre>
<p>In your custom loaders, you can also use Prodigy's
<a href="#function-prodigyget-config"><code>get_config</code> helper</a> to get access to your
<code>prodigy.json</code>. This can be useful if you want to store your API keys or
auth tokens in one place. Here's an example of a loader that makes an API
request for a given query, and uses an API key stored in the Prodigy config:</p>
<pre><code class="python language-python"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> prodigy <span class="hljs-keyword">import</span> get_config

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">custom_api_loader</span><span class="hljs-params">(source)</span>:</span>
    config = get_config()
    key = config[<span class="hljs-string">'api_keys'</span>][<span class="hljs-string">'custom_api'</span>]
    res = requests.get(<span class="hljs-string">'https://your-api'</span>, params={<span class="hljs-string">'query'</span>: source<span class="hljs-string">', key'</span>: key})
    data = response.json()[<span class="hljs-string">'data'</span>]
    <span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> result:
        <span class="hljs-keyword">yield</span> {<span class="hljs-string">'text'</span>: entry[<span class="hljs-string">'text'</span>]}
</code></pre>
<h1 id="formats">Formats</h1>
<h2 id="input-formats">Input formats</h2>
<p>Prodigy supports streaming in data from a variety of different formats, via the
available loader components. To load data from other formats or sources, like a
database or an API, you can write your own loader function that returns an
iterable stream, and include it in your custom recipe.</p>
<blockquote>
  <p><strong>Preferred file format:</strong> In general, Prodigy prefers <a href="http://jsonlines.org">newline-delimited JSON</a>, as it can contain detailed information and meta data and allows being read in line by line. Unlike regular JSON, JSONL doesn't require parsing the entire file, which results in overall better performance when working with large volumes of text.</p>
</blockquote>
<h3 id="text-sources">Text sources</h3>
<h4 id="jsonl">JSONL</h4>
<pre><code class="json language-json">{<span class="hljs-attr">"text"</span>: <span class="hljs-string">"This is a sentence."</span>}
{<span class="hljs-attr">"text"</span>: <span class="hljs-string">"This is another sentence."</span>, <span class="hljs-attr">"meta"</span>: {<span class="hljs-attr">"score"</span>: <span class="hljs-number">0.1</span>}}
</code></pre>
<h4 id="json">JSON</h4>
<pre><code class="json language-json">[
    { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"This is a sentence."</span> },
    { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"This is another sentence."</span>, <span class="hljs-attr">"meta"</span>: { <span class="hljs-attr">"score"</span>: <span class="hljs-number">0.1</span> } }
]
</code></pre>
<h4 id="csv">CSV</h4>
<pre><code><span class="hljs-literal">Text</span>,<span class="hljs-keyword">Label</span>,Meta
This <span class="hljs-keyword">is</span> a sentence.,<span class="hljs-built_in">POSITIVE</span>,<span class="hljs-number">0</span>
This <span class="hljs-keyword">is</span> another sentence.,NEGATIVE,<span class="hljs-number">0.1</span>
</code></pre>
<p>Column headers can be lowercase or title case. Columns for label and meta are
optiona. The value of the meta column will be added as a <code>"meta"</code> key within the <code>"meta"</code> dictionary, e.g. <code>{'text': 'This is a sentence', 'meta': {'meta': 0}},</code>.</p>
<h4 id="txt">TXT</h4>
<pre><code>This is <span class="hljs-keyword">a</span> <span class="hljs-keyword">sentence</span>.
This is another <span class="hljs-keyword">sentence</span>.
</code></pre>
<h4 id="comparison-files">Comparison files</h4>
<p>Each entry in a comparison file needs to include an <code>output</code> key containing the
annotation example data – for example, the text, a text and an entity span or
an image. Optionally, you can also include an <code>input</code> key for the baseline
annotation. The <code>id</code> is used to combine the examples from each file. If an ID
is only present in one file, the example is skipped.</p>
<pre><code class="json language-json">{<span class="hljs-attr">"id"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"input"</span>: {<span class="hljs-attr">"text"</span>: <span class="hljs-string">"NLP"</span>}, <span class="hljs-attr">"output"</span>: {<span class="hljs-attr">"text"</span>: <span class="hljs-string">"Natural Language Processing"</span>}}
{<span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"input"</span>: {<span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hund"</span>}, <span class="hljs-attr">"output"</span>: {<span class="hljs-attr">"text"</span>: <span class="hljs-string">"dog"</span>}}
</code></pre>
<pre><code class="json language-json">{<span class="hljs-attr">"id"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"input"</span>: {<span class="hljs-attr">"text"</span>: <span class="hljs-string">"NLP"</span>}, <span class="hljs-attr">"output"</span>: {<span class="hljs-attr">"text"</span>: <span class="hljs-string">"Neuro-Linguistic Programming"</span>}}
{<span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"input"</span>: {<span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hund"</span>}, <span class="hljs-attr">"output"</span>: {<span class="hljs-attr">"text"</span>: <span class="hljs-string">"hound"</span>}}
</code></pre>
<h4 id="match-patterns">Match patterns</h4>
<p>Match patterns can be used in the <code>ner.match</code> and <code>ner.teach</code> recipes to filter
out specific entities you're interested in – for example, to collect training
data for a new entity type. You can also use the <code>terms.to-patterns</code> recipe to
convert a dataset of seed terms to a JSONL pattern file.</p>
<p>Each entry should contain a <code>"label"</code> and <code>"pattern"</code> key. A pattern can be an
exact string, or a
<a href="https://spacy.io/usage/linguistic-features#rule-based-matching">rule-based token pattern</a>,
(used by spaCy's <code>Matcher</code> class), consisting of a list of dictionaries, each
describing one individual token and its attributes. When using token patterns,
keep in mind that their interpretation depends on the model's tokenizer.</p>
<pre><code class="json language-json">{<span class="hljs-attr">"label"</span>: <span class="hljs-string">"FRUIT"</span>, <span class="hljs-attr">"pattern"</span>: [{<span class="hljs-attr">"lower"</span>: <span class="hljs-string">"apple"</span>}]}
{<span class="hljs-attr">"label"</span>: <span class="hljs-string">"FRUIT"</span>, <span class="hljs-attr">"pattern"</span>: [{<span class="hljs-attr">"lower"</span>: <span class="hljs-string">"goji"</span>}, {<span class="hljs-attr">"lower"</span>: <span class="hljs-string">"berry"</span>}]}
{<span class="hljs-attr">"label"</span>: <span class="hljs-string">"VEGETABLE"</span>, <span class="hljs-attr">"pattern"</span>: [{<span class="hljs-attr">"lower"</span>: <span class="hljs-string">"squash"</span>, <span class="hljs-attr">"pos"</span>: <span class="hljs-string">"NOUN"</span>}]}
{<span class="hljs-attr">"label"</span>: <span class="hljs-string">"VEGETABLE"</span>, <span class="hljs-attr">"pattern"</span>: <span class="hljs-string">"Lamb's lettuce"</span>}
</code></pre>
<p>Here are some examples of match patterns and the respective matched strings. For
more details, see the <a href="https://spacy.io/usage/linguistic-features#rule-based-matching">spaCy documentation on rule-based matching</a>.</p>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>Matches</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[{"lower": "apple"}]</code></td>
<td>"apple", "APPLE", "Apple", "ApPlLe" etc.</td>
</tr>
<tr>
<td><code>[{"orth": "apple"}]</code></td>
<td>"apple"</td>
</tr>
<tr>
<td><code>[{"lower": "squash", "pos": "NOUN"}]</code></td>
<td>"squash", "Squash" etc. (nouns only, i.e. not "to squash")</td>
</tr>
<tr>
<td><code>"Lamb's lettuce"</code></td>
<td>"Lamb's lettuce"</td>
</tr>
</tbody>
</table>
<p>Prodigy will assign each entry a hash ID based on its label and pattern. This
ID will be used when updating the matcher from an existing dataset, e.g.
using <code>ner.match</code> with the <code>--resume</code> flag. If you want to use your own
pattern ID system, you can define an <code>"id"</code> value on each entry, which will
be respected by Prodigy.</p>
<h4 id="images">Images</h4>
<p>Images can be loaded via any of the data formats that support keyed inputs. If the data contains an <code>image</code> key, it will be copied over into the annotation task, and you'll be able to use it with the <code>image</code> or <code>classification</code> interface.</p>
<pre><code class="json language-json">{ <span class="hljs-attr">"image"</span>: <span class="hljs-string">"https://media.giphy.com/media/LHZyixOnHwDDy/giphy.gif"</span> }
</code></pre>
<p>Alternatively, the <code>Images</code> loader lets you stream in image files from a
directory. All images will be encoded as
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">base64 data URIs</a>
and included as the <code>image</code> key.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.loaders <span class="hljs-keyword">import</span> Images
stream = Images(<span class="hljs-string">'/path/to/images'</span>)
</code></pre>
<h5 id="fetching-images-from-local-paths-and-urls">Fetching images from local paths and URLs</h5>
<p>You can also use the <code>fetch_images</code> preprocessor to replace all image paths and
URLs in your stream with base64 data URIs. The <code>skip</code> keyword argument lets you
specify whether to skip invalid images that can't be converted (for example,
because the path doesn't exist, or the URL can't be fetched). If set to <code>False</code>,
Prodigy will raise a <code>ValueError</code> if it encounters invalid images.</p>
<pre><code class="python language-python"><span class="hljs-keyword">from</span> prodigy.components.preprocess <span class="hljs-keyword">import</span> fetch_images

stream = [{<span class="hljs-string">'image'</span>: <span class="hljs-string">'/path/to/image.jpg'</span>}, {<span class="hljs-string">'image'</span>: <span class="hljs-string">'https://example.com/image.jpg'</span>}]
stream = fetch_images(stream, skip=<span class="hljs-keyword">True</span>)
</code></pre>
<blockquote>
  <p><strong>Note on encoded images:</strong> When working with base64-encoded data URIs, keep
  in mind that all task data will be also be <strong>stored in the database</strong> –
  including the base64-encoded images. In some cases, this can be convenient,
  as it lets you store the image data with the annotation. In other cases,
  this can lead to unexpected results and database bloat.</p>
</blockquote>
<h2 id="annotation-task-formats">Annotation task formats</h2>
<p>Prodigy expects annotation tasks to follow a simple JSON-style format. This
format is also used to communicate tasks between REST API and web application,
and will be used when exporting annotations via the <code>db.io</code> command. Annotated
tasks contain an additional <code>answer</code> key mapping to either <code>"accept"</code>,
<code>"reject"</code> or <code>"ignore"</code>.</p>
<p>In order to be rendered by the web application and stored in the database,
<strong>each task requires a unique ID</strong>. You can either assign those IDs yourself in
the input data, or let Prodigy take care of it. The automatically generated IDs
are usually hash values generated from the available task properties.</p>
<blockquote>
  <p><strong>Formatting in annotation tasks:</strong> The <code>text</code> property of an annotation task
  will always be rendered as plain text. To add markup like line breaks or
  simple formatting, use the <code>html</code> key instead. Prodigy wants you to explicitly
  choose to use "HTML mode" to avoid stray HTML tags (which can influence the
  model's predictions) from being rendered or hidden – for example, if you're
  working with raw, uncleaned data. If you're using one of Prodigy's
  default recipes with a model in the loop, keep in mind that the <code>text</code> of an
  annotation task is used to update the model.</p>
</blockquote>
<h4 id="annotated-task">Annotated task</h4>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Nintendo Switch"</span>,
    <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"accept"</span>
}
</code></pre>
<h3 id="text">Text</h3>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Nintendo Switch"</span>
}
</code></pre>
<h3 id="ner">NER</h3>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple updates its analytics service with new metrics"</span>,
    <span class="hljs-attr">"spans"</span>: [{ <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">"label"</span>: <span class="hljs-string">"ORG"</span> }]
}
</code></pre>
<blockquote>
  <p><strong>⚠️ Important note:</strong> If you're creating NER annotation tasks manually and
  need to render multiple entities per task, make sure to provide them in
  order.</p>
</blockquote>
<p>The <code>ner_manual</code> interface allows highlighting spans of text based on token
boundaries, and will use a model to tokenize the text and add an additional
<code>"tokens"</code> property to the annotation task. This will allow the application to
resolve the highlighted spans back to the respective token boundaries. Selected
entities will be added to the task's <code>"spans"</code>:</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello Apple"</span>,
    <span class="hljs-attr">"tokens"</span>: [
        { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">0</span> },
        { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span> }
    ],
    <span class="hljs-attr">"spans"</span>: [{ <span class="hljs-attr">"start"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">"label"</span>: <span class="hljs-string">"ORG"</span>, <span class="hljs-attr">"token_start"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"token_end"</span>: <span class="hljs-number">1</span> }]
}
</code></pre>
<h3 id="dependencies">Dependencies</h3>
<p>Dependencies are specified as a list of arc with a head and a child, indicating
the direction of the arrow. Since the arcs refer to the token index, the task
also requires a <code>"tokens"</code> property. This is usually taken care of in the
respective recipes, using the <code>add_tokens</code> pre-processor.</p>
<blockquote>
  <p><strong>⚠️ Important note:</strong> Prodigy currently only supports one arc per task.</p>
</blockquote>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello Apple"</span>,
    <span class="hljs-attr">"tokens"</span>: [
        { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">0</span> },
        { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span> }
    ],
    <span class="hljs-attr">"arcs"</span>: [{ <span class="hljs-attr">"head"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"child"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"label"</span>: <span class="hljs-string">"compound"</span> }]
}
</code></pre>
<h3 id="image">Image</h3>
<pre><code class="json language-json">{
    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"some_image.jpg"</span>
}
</code></pre>
<pre><code class="json language-json">{
    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAqdJREFUeNrMl12LTVEcxs85TjPMKBkmeWkaOWgkKa9z4T1ulCtlcDG5UFO4QG58BD4ApcSESe7kQilcaGQMbpzMSJozNElMQ5IhM36P/mq3O3ufvdbZu6z6tTp77bXWs/b/bZ1c7n9si9pKcz3n5cFpTiHi+U5P7SthRhoCVrmexNoaaEpDwFaY5fkFFtYlgJM30q2FNg8B7a7zqn2BTpgHpxBT8BDQ7jKhaLZugGY7+TnIQze8Zvwm/Uf4NTb6ZjomAv52PiYomOojcBHW25hMcR6uwu4EzqUDLIblLgLyoVNokz7YB1NwQqI4+VSCHNBBV4ZB3t/o5QNM/E53Gn7DbbiQZHNrW+xAJcTMrMcJR2FcAuJsHpO85pgp/ASw6U85HzxySMEL6PYG1uyqNxE9gXcJN281R50deHyW50ehwckJA4vK6++FIqVokSFH1aYrYDschJaI9YfgOjy1A8m0X2ESZN7pKAEtmGLcElGrhekSWA07oMM2LSb80j9gAj7BMzPvK0VN3qPkNlqtOAz7Lf7jmiLqPtyCB/A2GFnOAkJiltJdgl0RrwzCcRiIiqh8wo1U40ssMhzxRZQz9oSGrsAxyy3OURBuKs2bqw2wwaTVj+AJx+Bkrc1dBMgRt8WMP7Tc8a/1svlEPXkg3FTqNunOF/EV5GjXQoJyaQrYAMus3Ea1uwGvL6ciQDUeVF4PWRI6w+/miPtiRXcG+AafvcqxbarkMt8umF0W78GUqsVvwB14rt8KMYsUFbIP/F7nLSAkRl/oAFwGldgRE/S4WlzzvmxfYaw78ZUsbtAyVh8Ld9rlpIdn/TFTymaKXCoCAm3A7PuixnsjWQl4acmllnOpwLzPQoBO1m/xHteUqr9kIUCL9iZ4r2J5IJN/zE1ZrPtHgAEAAuvBpEMJ1j8AAAAASUVORK5CYII="</span>
}
</code></pre>
<h3 id="object-detection-and-image-segmentation">Object detection and image segmentation</h3>
<p>If an image task contains a list of <code>span</code> objects, it will be rendered in
image segmentation mode. Each span can define a list of <code>points</code>, consisting
of <code>[X, Y]</code> coordinate tuples, describing the points of the bounding box.
While bounding boxes are usually squares, Prodigy also supports polygon shapes.
The coordinates should be measured in pixels, relative to the original image.
If a label is specified, it will be rendered with the bounding box.</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"some_image.jpg"</span>,
    <span class="hljs-attr">"width"</span>: <span class="hljs-number">800</span>,
    <span class="hljs-attr">"height"</span>: <span class="hljs-number">600</span>,
    <span class="hljs-attr">"spans"</span>: [
        {
            <span class="hljs-attr">"label"</span>: <span class="hljs-string">"PERSON"</span>,
            <span class="hljs-attr">"color"</span>: <span class="hljs-string">"magenta"</span>,
            <span class="hljs-attr">"points"</span>: [[<span class="hljs-number">150</span>, <span class="hljs-number">80</span>], [<span class="hljs-number">270</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">250</span>, <span class="hljs-number">200</span>], [<span class="hljs-number">170</span>, <span class="hljs-number">240</span>], [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>]]
        },
        {
            <span class="hljs-attr">"label"</span>: <span class="hljs-string">"CAR"</span>,
            <span class="hljs-attr">"color"</span>: <span class="hljs-string">"cyan"</span>,
            <span class="hljs-attr">"points"</span>: [[<span class="hljs-number">70</span>, <span class="hljs-number">120</span>], [<span class="hljs-number">70</span>, <span class="hljs-number">180</span>], [<span class="hljs-number">120</span>, <span class="hljs-number">180</span>], [<span class="hljs-number">120</span>, <span class="hljs-number">120</span>]]
        }
    ]
}
</code></pre>
<h3 id="classification">Classification</h3>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple updates its analytics service with new metrics"</span>,
    <span class="hljs-attr">"label"</span>: <span class="hljs-string">"technology"</span>
}
</code></pre>
<pre><code class="json language-json">{
    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"hotdog.jpg"</span>,
    <span class="hljs-attr">"label"</span>: <span class="hljs-string">"food"</span>
}
</code></pre>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple updates its analytics service with new metrics"</span>,
    <span class="hljs-attr">"label"</span>: <span class="hljs-string">"CORRECT"</span>,
    <span class="hljs-attr">"spans"</span>: [
        {
            <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">"end"</span>: <span class="hljs-number">5</span>,
            <span class="hljs-attr">"label"</span>: <span class="hljs-string">"ORG"</span>
        }
    ]
}
</code></pre>
<h3 id="html">HTML</h3>
<pre><code class="json language-json">{
    <span class="hljs-attr">"html"</span>: <span class="hljs-string">"&lt;iframe width='560' height='315' src='https://www.youtube.com/embed/vKmrxnbjlfY'&gt;&lt;/iframe&gt;"</span>
}
</code></pre>
<p>The content of the <code>html</code> property won't be displayed in the sidebar history,
as it can easily look confusing – especially if the developer and annotator
are not the same person. To customise what's shown in the history, you can
include an additional <code>text</code> property:</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"html"</span>: <span class="hljs-string">"&lt;iframe width='560' height='315' src='https://www.youtube.com/embed/vKmrxnbjlfY'&gt;&lt;/iframe&gt;"</span>,
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Baby sloth yawning"</span>
}
</code></pre>
<h3 id="choice">Choice</h3>
<p>The <code>choice</code> interface can render text, entities, images or HTML. Each option
is stuctured like an individual annotation task and will receive a unique ID.
You can also choose to assign the IDs yourself. A <code>choice</code> tasks can also contain
other task properties – like a <code>text</code>, a <code>label</code> or <code>spans</code>. This content will
be rendered above the options.</p>
<p>Note that selecting options via keyboard shortcuts like <kbd>1</kbd> and
<kbd>2</kbd> only works for 9 or less options. To use multiple choice instead of
single choice, you can set<code>"choice_style": "multiple"</code> in your Prodigy or recipe
config. You can also set <code>"choice_auto_accept": true</code> to automatically accept
a single-choice option when selecting it – without having to click the
<kbd>accept</kbd> button.</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"options"</span>: [
        { <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple"</span> },
        { <span class="hljs-attr">"id"</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Google"</span> },
        { <span class="hljs-attr">"id"</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">"text"</span>: <span class="hljs-string">"McDonalds"</span> }
    ]
}
</code></pre>
<p>An option can also contain a <code>style</code> key with an object of CSS properties in
the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Properties_Reference">camel-cased JavaScript format</a>,
mapping to their values:</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"options"</span>: [
        { <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Option 1"</span>, <span class="hljs-attr">"style"</span>: { <span class="hljs-attr">"background"</span>: <span class="hljs-string">"#ff6666"</span> } },
        { <span class="hljs-attr">"id"</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Option 2"</span>, <span class="hljs-attr">"style"</span>: { <span class="hljs-attr">"fontWeight"</span>: <span class="hljs-string">"bold"</span> } }
    ]
}
</code></pre>
<p>When you annotate, an <code>"accept"</code> key is added to the parent task, containing
the IDs of the selected options, as well as the <code>"answer"</code>. This allows the
annotator to reject or ignore tasks, for example if they contain errors.</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"options"</span>: [
        { <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple"</span> },
        { <span class="hljs-attr">"id"</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Google"</span> },
        { <span class="hljs-attr">"id"</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">"text"</span>: <span class="hljs-string">"McDonalds"</span> }
    ],
    <span class="hljs-attr">"accept"</span>: [<span class="hljs-number">3</span>],
    <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"accept"</span>
}
</code></pre>
<h3 id="compare">Compare</h3>
<p>The <code>compare</code> recipe supports all annotation modes. It can reveive an optional
<code>input</code> containing the original example, plus two examples to collect feedback
on. This format is normally used to compare two different outputs, and requires
you to feed in data from two different sources. The data is associated via its
IDs. To ensure unbiased annotation, Prodigy randomly decides which example to
return as the assumed correct answer ("accept"). The mapping lets you resolve
those back to the original sources (A or B).</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">"input"</span>: { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"NLP"</span> },
    <span class="hljs-attr">"accept"</span>: { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Natural Language Processing"</span> },
    <span class="hljs-attr">"reject"</span>: { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Neuro-Linguistic Programming"</span> },
    <span class="hljs-attr">"mapping"</span>: { <span class="hljs-attr">"A"</span>: <span class="hljs-string">"accept"</span>, <span class="hljs-attr">"B"</span>: <span class="hljs-string">"reject"</span> }
}
</code></pre>
<h3 id="review">Review</h3>
<p>The <code>review</code> interface currently supports all annotation modes (except
<code>image_manual</code> and <code>compare</code>). It will present one or more versions of a given
task (e.g. annotated in different sessions), display them with the session
information and allow the reviewer to correct or override the decision. The data
requires a <code>"view_id"</code> setting that defines the annotation UI to render the
example with. The versions follow the same format as regular annotation tasks.
They can specify a list of <code>"sessions"</code>, as well as a boolean <code>"default"</code> key,
marking that version as the default version to pre-populate the review UI with
(if the interface is a manual interface).</p>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello world"</span>,
    <span class="hljs-attr">"label"</span>: <span class="hljs-string">"POSITIVE"</span>,
    <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"accept"</span>,
    <span class="hljs-attr">"view_id"</span>: <span class="hljs-string">"classification"</span>,
    <span class="hljs-attr">"versions"</span>: [
        {
            <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello world"</span>,
            <span class="hljs-attr">"label"</span>: <span class="hljs-string">"POSITIVE"</span>,
            <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"accept"</span>,
            <span class="hljs-attr">"sessions"</span>: [<span class="hljs-string">"dataset-user1"</span>, <span class="hljs-string">"dataset-user3"</span>, <span class="hljs-string">"dataset-user4"</span>]
        },
        {
            <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello world"</span>,
            <span class="hljs-attr">"label"</span>: <span class="hljs-string">"POSITIVE"</span>,
            <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"reject"</span>,
            <span class="hljs-attr">"sessions"</span>: [<span class="hljs-string">"dataset-user2"</span>]
        }
    ]
}
</code></pre>
<pre><code class="json language-json">{
    <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello Apple"</span>,
    <span class="hljs-attr">"tokens"</span>: [
        { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">0</span> },
        { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span> }
    ],
    <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"accept"</span>,
    <span class="hljs-attr">"view_id"</span>: <span class="hljs-string">"ner_manual"</span>,
    <span class="hljs-attr">"versions"</span>: [
        {
            <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello Apple"</span>,
            <span class="hljs-attr">"tokens"</span>: [
                { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">0</span> },
                { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span> }
            ],
            <span class="hljs-attr">"spans"</span>: [{ <span class="hljs-attr">"start"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">"label"</span>: <span class="hljs-string">"ORG"</span>, <span class="hljs-attr">"token_start"</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">"token_end"</span>: <span class="hljs-number">1</span> }],
            <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"accept"</span>,
            <span class="hljs-attr">"sessions"</span>: [<span class="hljs-string">"dataset-user1"</span>, <span class="hljs-string">"dataset-user3"</span>, <span class="hljs-string">"dataset-user4"</span>],
            <span class="hljs-attr">"default"</span>: <span class="hljs-literal">true</span>
        },
        {
            <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello Apple"</span>,
            <span class="hljs-attr">"tokens"</span>: [
                { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Hello"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">0</span> },
                { <span class="hljs-attr">"text"</span>: <span class="hljs-string">"Apple"</span>, <span class="hljs-attr">"start"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"end"</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span> }
            ],
            <span class="hljs-attr">"spans"</span>: [],
            <span class="hljs-attr">"answer"</span>: <span class="hljs-string">"accept"</span>,
            <span class="hljs-attr">"sessions"</span>: [<span class="hljs-string">"dataset-user2"</span>],
            <span class="hljs-attr">"default"</span>: <span class="hljs-literal">false</span>
        }
    ]
}
</code></pre>
<p>© 2019 <a href="https://explosion.ai">Explosion AI</a> | <a href="https://prodi.gy/terms">Terms & Conditions</a></p>
        </article>
        <h6 id="top"><a href="#table-of-contents">▲ Top</a></h6>
    </body>
</html>
