Next-generation sequencing (NGS) technologies have raised a challenging de novo genome assembly problem that is further amplified in recently emerged single-cell sequencing projects.
While various NGS assemblers can use information from several libraries of read-pairs, most of them were originally developed for a single library and do not fully benefit from multiple libraries.
Moreover, most assemblers assume uniform read coverage, condition that does not hold for single-cell projects where utilization of read-pairs is even more challenging.
We have developed an exSPAnder algorithm that accurately resolves repeats in the case of both single and multiple libraries of read-pairs in both standard and single-cell assembly projects.
Availability and implementation: http://bioinf.spbau.ru/en/spades Contact: ap@bioinf.spbau.ru 1 INTRODUCTION Most of existing next-generation sequencing (NGS) platforms generate read-pairspairs of reads (called mates) that are sequenced from different ends of a genomic fragment with approximately known length (called the insert size).
Because the insert size usually exceeds the length of a single read, readpairs may match up unique regions surrounding repeats that are longer than the read length.
A combination of several libraries of read-pairs with different insert sizes is often used to produce high-quality assemblies (Butler et al.2008; Bresler et al., 2012).
Paired-end libraries usually have insert size51 kb and are used for resolving relatively short repeats.
Jumping libraries are characterized by an average insert size of anywhere from 1 to 20 kb and are helpful in resolving longer repeats and contig scaffolding (inferring the order of contigs in the genome).
However, because of a high insert size variation, information from jumping libraries is rather difficult to use for the purpose of assembly.
The problem of using multiple read-pair libraries was previously addressed by ALLPATHS-LG (Gnerre et al., 2011), Ray (Boisvert et al., 2010), Velvet (Zerbino and Birney, 2008) and some other assemblers.
However, these tools are designed for standard (mutlicell) assemblies and do not perform well on single-cell datasets.
On the other hand, the single-cell assemblers ESC (Chitsaz et al., 2011), IDBA-UD (Peng et al., 2012) and SPAdes (Bankevich et al., 2012) are designed for a single read-pair library.
In addition, the recently proposed Paired de Bruijn Graph algorithms for repeat resolution (Medvedev et al., 2011; Pham et al., 2013; Vyahhi et al., 2012) also focus on a single library and it remains unclear how to extend them to multiple libraries.
We present EXSPANDER algorithm that works with both single and multiple libraries in standard and single-cell assembly projects.
EXSPANDER uses a simple path extension approach for repeat resolution that was originally proposed in the Ray assembler [and later used in Telescoper (Bresler et al., 2012)] and combines it with some ideas from the Rectangle Graph approach (Bankevich et al., 2012; Vyahhi et al., 2012).
Given a set of paths in the assembly graph (Bankevich et al., 2012) (i.e.simplified de Bruijn graph (Compeau et al., 2011; Pevzner et al., 2001) of k-mers in reads after removal of bulges, tips and chimeric edges), EXSPANDER attempts to extend each path with the goal to generate longer paths.
For a path P ending in a vertex v, we consider all edges starting at v (referred to as extension edges) and compute ScoreP(e) for each extension edge.
To compute ScoreP(e) we analyze all reads that map to path P and whose mates map to e. Thus, ScoreP(e) reflects our confidence that an extension of the path P by the edge e is correct.
We note that to properly map read-pairs and calculate ScoreP(e), the total length of path P and edge e should be longer than the insert size.
In addition to function ScoreP(e), EXSPANDER uses a decision rule Extend(P) that either chooses one of the extension edges to extend the path P or makes the decision to stop growing this path beyond the ending vertex of P. The procedure is iterated over all the paths until no path can be further extended.
To initiate this algorithm one can start with a set of single-edge paths formed by all sufficiently long edges in the assembly graph.
The resulting paths are output as contigs after removing the paths that are contained within other paths as well as removing non-informative overlaps (i.e.suffixes of paths that represent prefixes of other paths).
This simple approach is merely a framework and, depending on the specifics of the scoring function and the decision rule, it can be either efficient (like in the Ray assembler) or disastrous.
The authors of Telescoper made an attempt to improve on Rays scoring function and to substantiate it with rigorous statistical analysis.
However, scoring functions in both Ray and Telescoper are not universal, e.g.they assume the uniform genome coverage by reads, condition that does not hold for single-cell data.
We demonstrate that EXSPANDER works well on single-cell datasets with multiple libraries.
We also show that EXSPANDER *To whom correspondence should be addressed.
yThe authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors.
The Author 2014.
Published by Oxford University Press.
This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited.
For commercial re-use, please contact journals.permissions@oup.com Since [ 1 2 ] less than p kb p up p tiliz 3 ] 4 ] 5 ] 6 ] 7 ] 8 ] 9 10 11 ] ( 2 ) 8 11 ] 8 ] , 12 ; 13 ] XPath error Undefined namespace prefix XPath error Undefined namespace prefix [implemented as a part of SPAdes (Bankevich et al., 2012)] improves on existing assemblers on standard bacterial datasets and outperforms such popular assemblers as ABySS (Simpson et al., 2009), Ray (Boisvert et al., 2010), SOAPdenovo (Li et al., 2010) and Velvet (Zerbino and Birney, 2008).
ALLPATHS-LG (Gnerre et al., 2011) is an excellent assembler whose applications, however, are limited to specially constructed read-pair libraries.
On such libraries EXSPANDER and ALLPATHS-LG generate comparable results (EXSPANDER generates longer contigs but ALLPATHS-LG generates longer scaffolds).
2 ANALYSIS OF READ-PAIR LIBRARIES As we mentioned in the introduction, jumping libraries present additional challenges for genome assembly owing to their high variations in the insert size.
Additionally, jumping libraries have high rate of chimeric read-pairsread-pairs that either have abnormal insert size or incorrect orientation.
Chimeric read-pairs further complicate utilization of such libraries while resolving repeats.
Below we present analysis of the insert size distributions for the following data: Brachybacterium faecium isolate dataset (read length 150 bp) and Staphylococcus aureus single-cell dataset (read length 101bp).
Both datasets contain one paired-end and one jumping library.
To analyze read-pair libraries we aligned reads to the B.faecium and S.aureus reference genomes using Bowtie 2 (Langmead and Salzberg, 2012) and computed the chimeric readpair rates and insert size distributions.
As Figure 1 and Table 1 demonstrate, both isolate and singlecell paired-end libraries have small variations of the insert size.
In contrast, the jumping library from the B.faecium dataset has a much higher variation in the insert size and higher rate of chimeric read-pairs (Table 1).
At the same time, in addition to the large insert size variations, S.aureus jumping library contains only 22% of all read-pairs aligned with the proper reverse forward orientation.
Thirty-six percent of all read-pairs have incorrect forwardreverse orientation (correspond to the left peak in Fig.1d) and 14% are classified as chimeric read-pairs of other types.
Forwardreverse read-pairs in jumping libraries represent an artifact of the sample preparation and are common for datasets of different types.
Despite the fact that various artifacts of jumping libraries make it difficult to incorporate them into existing assembly tools, EXSPANDER uses jumping libraries to generate high-quality assemblies.
3 EXSPANDER ALGORITHM EXSPANDER uses an assembly graph constructed by SPAdes (Bankevich et al., 2012) and a set of read-pair libraries.
For each library, we map read-pairs to the long edges of the assembly graph and estimate the average insert size along with its confidence intervala shortest insert size interval that contains at least 80% of properly aligned read-pairs.
These estimates are used as parameters of the scoring function and the decision rule.
3.1 The decision rule 3.1.1 Single library Given a path P, we define a winner as an edge e with the maximal score ScoreP(e) among all extension edges for P. Similarly, a contender is defined as an extension edge with the second best score.
The winner edge is called the strong winner if (i) ScoreP(winner) 4 and (ii) ScoreP(winner)4C ScoreP(contender), where and C are parameters of the algorithm, which are discussed below.
If the path P has a single extension edge (which is obviously the winner), only the first condition is used.
The decision rule is defined as follows: ExtendP= e; if edge e is the strong winner for path P ;; if there is no strong winner for path P ( 3.1.2 Multiple libraries The decision rule described above can be generalized for several read-pair libraries.
Consider M readpair libraries, which are sorted in the order of increasing insert (a) (b) (c) (d) Fig.1.
Plots of the insert size distributions for B.faecium isolate (a) paired-end and (b) jumping library, and S.aureus single-cell dataset with (c) paired-end and (d) jumping library.
The distributions were computed by mapping reads to the B.faecium str.
DSM4810 (Lapidus et al., 2009) and S. aureus str.
USA300 substr.
FPR3757 (Diep et al., 2006) reference genomes, respectively.
All plots are in the logarithmic scale Table 1.
Information on the B.faecium isolate dataset and the S.aureus single-cell dataset Dataset B.faecium S.aureus Library Paired-end Jumping Paired-end Jumping Number of reads 13 M 41 M 38 M 41 M Average coverage 400 1100 1050 1050 Coverage span 210570 03000 03500 03500 Insert size 270bp 7.5kb 210bp 1.8kb Insert span 150400bp 610kb 180230bp 0.54kb Chimeric read-pairs (%) 1 9 3 50 Unaligned read-pairs (%) 16 10 6 28 Note: Insert span is the shortest insert size interval that contains at least 95% of properly aligned read-pairs.
Unaligned reads refer to the percentage of read-pairs that have at least one read unaligned.
Chimeric read-pairs refer to the percentage of chimeric read-pairs among all read-pairs.
All statistics was obtained using Bowtie 2 (Langmead and Salzberg, 2012).
Coverage span is the smallest coverage interval that includes a least 95% of all genomic positions i294 A.D.Prjibelski et al.( 8 ]) 14 ] 4 ] 15 ] 5 ] 3 ] due s. 16 ] 36&percnt; 8 ] sizes and the associated decision rules Extendi(P) for 1 iM.
We process the libraries in this order because our analysis revealed that the smaller is the insert size of a library (and its variation), the more reliable is the decision rule for this individual library.
We thus select the library with the smallest index i that has the strong winner and define the decision rule for multiple libraries Extend(P) as simply Extendi(P).
If neither library has a strong winner, we define ExtendP=;.
3.2 The scoring function 3.2.1 The support function We first consider an idealized case when the genome defines a genomic path in the assembly graph.
We say that an edge e0 follows edge e at a distance D if the distance between starts of these edges in the genomic path is D. We define a boolean function SupportD(e,e 0) that reflects our confidence that edge e0 follows edge e in the genome at distance D. Below we describe how to calculate SupportD(e,e 0).
Let I and [Imin,Imax] be the mean and the confidence interval of the insert size for a read-pair library formed by reads of length ReadLength.
Consider consecutive edges e and e0 in the assembly graph and a read-pair (r,r0) such that read r maps to e at position x0 and read r 0 maps to e0 in position y0 (Fig.2a).
We say that the read-pair (r,r0) connects edges e and e0.
Figure 2b shows a rectangle formed by the edges e and e0 [further simply referred to as rectangle (e,e0)] with the read-pair (r,r0) represented as a point (x0,y0) within the rectangle.
If edges e and e 0 represent consecutive regions in the genome, then the genomic distance from the start of read r to the start of read r0 equals to Lengthe x0+y0, where Length(e) stands for the length of edge e. Therefore, in the case of an ideal read-pair (r,r0) (e.g.a read-pair with the exact insert size I), y0=x0 d, where d=Lengthe I+ReadLength.
Thus all ideal read-pairs mapping to edges e and e0 form a set of integer points on the 45 line y= x d within the rectangle (Fig.2c).
Because the read-pairs from the real sequencing data have variations in the insert size, their corresponding points are typically scattered in the strip between the 45 lines y= x dmin and y=x dmax, where dmin=Lengthe Imin+ReadLength; dmax=Lengthe Imax+ReadLength: This strip in the rectangle is further referred to as the confidence strip (Fig.2d).
Let F(x) be the empirical distribution of the insert size and S be a set of all integer points within the confidence strip in the rectangle (e,e0).
We define the expected number of read-pairs within the confidence strip (under the assumption of the uniform coverage) as Expectede; e0= X x;y2S FIx; y; where Ix; y=Lengthe x+y+ReadLength represents the insert size of a read-pair that corresponds to the point (x, y).
We also define Points(e,e0) as the total number of read-pairs (from the real dataset) that correspond to the points within the confidence strip.
The notion of density is defined as Densitye; e0= Pointse; e 0 Expectede; e0 : We setDensity(e,e0)=0, if Expected(e,e0)=0.
The points outside the confidence strip may represent read-pairs with somewhat larger deviations from the mean insert sizes or chimeric readpairs.
Our analysis revealed that being conservative (e.g.limiting analysis to the confidence strip) allows one to avoid most of the assembly errors caused by chimeric read-pairs, particularly in single-cell projects.
We distinguish between notions of genome-consecutive and graph-consecutive edges and emphasize that graph-consecutive edges are not necessarily genome-consecutive.
The decision about which graph-consecutive edges are genome-consecutive is an important part of any assembler.
Figure 2d and e illustrate how rectangles help us to make such decisions: both rectangles correspond to graph-consecutive edges, but only rectangle in Figure 2d is formed by the pair of genome-consecutive edges.
The described notions of Expected(e,e0), Points(e,e0) and Density(e,e0) (defined for the case when edges e and e0 are genome-consecutive) can be generalized for the case when e and e0 are not consecutive genomic edges under the assumption that genomic distance between them is D. In this case the confidence strip [further referred to as StripD(e,e 0)] is bounded by the lines y=x dmin and y= x dmax, where dmin=D Imin+ReadLength; dmax=D Imax+ReadLength: PointsD(e,e 0) similarly represents the number of points within strip StripD(e,e 0).
ExpectedD(e,e 0) and DensityD(e,e 0) are defined (a) (b) (c) (d) (e) Fig.2.
(a) Reads r and r0 form a read-pair mapping to consecutive edges e and e0 in the assembly graph at positions x0 and y0, respectively.
(b) Representation of a read-pair (r,r0) as a point in a rectangle (e,e0).
(c) Ideal read-pairs with the exact insert size I connecting edges e and e0 form a 45 line within a rectangle.
(d) Read-pairs from the real sequencing data with variations in the insert size represented as points within a rectangle.
Most points are located within the confidence strip providing the evidence that edges e and e0 are supported by the read-pairs and are genome-consecutive.
(e) A rectangle formed by a pair of edges that has few points falling into the confidence strip revealing that e and e0 are not genome-consecutive edges i295 ExSPAnder since ( ) `` '' , `` '' &Unicode_x2218; Since &Unicode_x2218; , 2 ( ) using the same formulas and the corresponding confidence strip.
Clearly, for two genome-consecutive edges Expected(e,e0)= ExpectedL(e,e 0) and Density(e,e0)=DensityL(e,e 0), where L=Length(e).
The support function reflects whether the number of readpairs connecting edges e and e0 supports the conjecture that e0 follows e in the genome at distance D: SupportDe; e0= 1; DensityDe; e04 0; otherwise ( where is a parameter of the algorithm, which is automatically computed for each read-pair library based on the chimeric readpair rate (see below).
For the standard isolate datasets this parameter corresponds to the coverage cutoff for read-pairs.
For single-cell datasets this parameter is usually set to be very low to retain the regions with low coverage, which are typical for single-cell projects.
If SupportD(e,e 0)=1, we say that the rectangle (e,e0) is supported by the read-pairs.
3.2.2 The naive scoring function To explain the intuition behind EXSPANDER, we first introduce the naive scoring function.
We further modify the naive scoring function to arrive to the advanced scoring function used in the real EXSPANDER implementation.
A path P=(p1,... ,pm) and its extension edge e can be represented as a composite rectangle formed by m simple rectangles (pj,e) containing points that correspond to read-pairs connecting edges of P and e. Figure 3b shows an example of a composite rectangle, which is formed by a path (p1, p2, p3) and its extension edge e1 and consists of three simple rectangles.
The notion of the confidence strip remains (it now consists of up to m substrips within simple rectangles), except that it is bounded by the lines y= x dmin and y=x dmax, where dmin=LengthP Imin+ReadLength; dmax=LengthP Imax+ReadLength: For an edge pj from the path P we define the expected number of points in the confidence substrip within the simple rectangle (pj,e) as ExpectedDj pj; e, where Dj is the distance between start of pj and start of e according to the path P (i.e.Dj= Pm i=j Lengthpi).
We consider rectangles pj; e; j=star t;... ; end such that ExpectedDj pj; e40 and introduce the function ScoreP(e) as the fraction of the total number of expected read-pairs in these rectangles with SupportDj pj; e=1: ScorePe= Xend j=start SupportDj pj; e ExpectedDj pj; e Xend j=start ExpectedDj pj; e : We set ScoreP(e)=0 if all simple rectangle have zero expected read-pairs.
Figure 3a shows paths P=(p1, p2, p3) and P 0 =p1; p 0 2; p3 and its extension edges e1,e2.
Let (p1, p2, p3, e1) and p1; p02; p3; e2 be the true (but unknown) genomic paths.
Figure 3b shows the composite rectangle for path P and its correct extension e1, in which points within the confidence strip are rather evenly distributed resulting in ScoreP(e1)=1.
Figure 3c shows the composite rectangle for path P=(p1, p2, p3) and its incorrect extension edge e2.
Because p1; p02; p3; e2 is a genomic path, density of the points in the sectors of the confidence strip corresponding to edges p1 and p3 is high.
However, edge p2 of the path P does not support extension edge e2 because there are few points in the rectangle (p2, e2).
Additionally, Figure 3d and e shows composite rectangles for all possible extension edges for path P0=p1; p02; p3.
Because the defined scoring function does not linearly depend on read coverage, it is well suitable for both single-cell and standard sequencing projects.
At the same time, considering only readpairs with insert size in [Imin,Imax] (which correspond to points within the confidence strip) allows one to filter out most of the chimeric read-pairs (common for single-cell datasets) and to minimize their influence on the scoring function.
3.2.3 The advanced scoring function The naive scoring function ScoreP(e) described above works well in many cases but may be too conservative when the path P contains repetitive edges (edges that are visited more than once by the genomic traversal).
Figure 4 illustrates the case when the path P has a repetitive edge and motivates the need for further improvements in the scoring function.
Figure 4a shows an assembly graph with four unique edges (p, p0, e and e0) and a single repetitive edge pr with multiplicity 2.
We assume that paths (p,pr,e) and (p 0,pr,e 0) are genomic and paths (p,pr,e 0) and (p0,pr,e) are non-genomic.
Our goal is to design an algorithm that correctly extends genomic paths (p,pr) (a) (b) (c) (d) (e) Fig.3.
(a) An example of an assembly graph with the genomic paths (p1, p2, p3, e1) and p1; p02; p3; e2.
(b, e) The composite rectangles for correct genomic extension of each path: in these cases the points are evenly distributed within the confidence strip and the resulting score is equal to 1.
(c, d) The composite rectangles that correspond to incorrect extensions edges of these two paths.
In each of these cases, at least one simple rectangle contains few points within the confidence strip i296 A.D.Prjibelski et al., Since since very 3 Since and (p0,pr) into longer genomic paths (p,pr,e) and (p 0,pr,e 0), respectively.
Consider a path P=(p,pr) and composite rectangles (P,e) and (P,e0) (Fig.4b and c).
As Figure 4 illustrates, ScoreP(e) is similar to ScoreP(e 0), implying that there is no strong winner for path P and preventing us from extending the path P by edge e. However, because the repetitive edge pr supports both extension edges e and e0, it does not provide any valuable information about the correct extension of the path P. Therefore, to make a decision about extending the path P by an extension edge e, we should have excluded pr from the consideration as a repetitive edge.
Because we do not know in advance which edges of the assembly graph correspond to repeats in the genome, we classify pr as repetitive because it supports both extension edges e and e 0.
Below we present the EXSPANDER algorithm that allows us to exclude repetitive edges from contributing to scoring.
An extension edge e of path P is called an active edge if C ScorePe ScorePwinner.
At the first step of the algorithm we score all extension edges and form a set of active edges A.
An edge pj in path P is classified as repetitive if it supports all active edges, i.e.SupportDj pj; ei=1 for all ei 2 A.
At the second step we mark all repetitive edges pj 2 P and recalculate scores of all edges in A ignoring these repetitive edges.
We then update A by removing all non-active edges and iterate the process.
The process continues until yet another iteration does not change the set of active edges A. IfA=feg and ScoreP(e)4 (which means that e satisfies both conditions in the decision rule) the extension edge e is considered to be a strong winner and added to the path P. Otherwise, we stop extending path P. We further demonstrate the work of the EXSPANDER algorithm using a simple assembly graph shown in Figure 5.
The paths p1; p2; p3; e1; p01; p2; p3; e2 and p02; p3; e3 are genomic paths, which means that edges p2 and p3 are repetitive and have multiplicities 2 and 3, respectively.
Let P=(p1, p2, p3) be a path we aim to extend.
We first calculate scores of all extension edges using the composite rectangles (Fig.6ac) and form a set of active edges A=fe1; e2; e3g based on their scores (marked red in Fig.6d).
Because SupportD3 p3; ei=1 for i=1, 2, 3, edge p3 is classified as repetitive and is removed from further consideration (Fig.6e).
We now recalculate scores for the extension edges inA ignoring repetitive edge p3 (Fig.6fh) and remove non-active edge e3 from A (Fig.6i).
Using the updated set A=fe1; e2g we again proceed to the repeat detection step and mark edge p2 as repetitive because Su pportD2 p2; ei=1 for i=1, 2 (Fig.6j).
Finally, we once again recalculate scores of the extension edges in A (Fig.6km) and remove e2 as non-active (Fig.6n).
The extension edge e1 remains the only active edge in and is used to extend path P. Extensive tests of the advanced scoring function revealed that it works well across diverse datasets including single-cell jumping libraries with high variations in the insert size, extremely nonuniform coverage and large number of chimeric reads and chimeric read-pairs (see Section 4).
3.3 Scaffolding After all paths are constructed, we consider all pairs of paths that form composite rectangles with non-zero number of points (Fig.7).
For each such pair of paths P and P0 we can check whether points in the corresponding composite rectangle are scattered around a certain 45 line using SPAdes distance estimation procedure (Nurk et al., 2013).
When SPAdes provides the estimated distance D between P and P0, we use EXSPANDER to verify the conjecture that P0 follows P at distance D. If this conjecture is supported and does not contradict to any other conjectures about these paths, we extend the path P by P0 (the scaffolding step).
We estimate the gap length between the paths as D LengthP and insert the appropriate number of N symbols (unspecified nucleotide) between end of P and start of P0.
If paths P and P0 overlap, we construct their overlap alignment to correct distance D. 3.4 Choice of the parameters 3.4.1 The scoring function We select the parameter as a threshold for the density of the read-pairs within the confidence strip.
We therefore assume that rectangles with the density below contain mostly chimeric read-pairs and should be ignored while calculating the score of an extension edge.
To select for a particular read-pair library, we estimate the distribution of the densities for rectangles that contain only chimeric readpairs (false rectangles) and for rectangles that contain only nonchimeric read-pairs (true rectangles).
To partition all read-pairs into chimeric and non-chimeric, one needs the complete genome that is unavailable.
To get around this, we identify a subset of chimeric reads using the long edges in the assembly graph (e.g.edges longer than N50) that can be (a) (b) (c) Fig.4.
Scoring a path that contains repetitive edges.
(a) An example of the assembly graph with a repetitive edge pr.
(b) A composite rectangle for the correct extension e of path (p,pr).
(c) A composite rectangle for the incorrect extension e0 of the path (p,pr) Fig.5.
An example of the assembly graph with repetitive edges p2 and p3 i297 ExSPAnder 4 since Since , 6b and 6 Since , 6 g and 6 since , 6l and 6 &Unicode_x2218; 19 ] `` '' , (a) (d) (f) (b) (g) (h) (i) (k) (l) (n) (m) (j) (c) (e) Fig.6.
A step-by-step example of the EXSPANDER algorithm.
(ac) Forming a set of active edges {e1, e2, e3} (marked red) for the path P=(p1, p2, p3) using the corresponding composite rectangles.
(d, e) Classifying of edge p3 as repetitive and removing it from further consideration (marking gray).
Edges that are not classified as repetitive are colored in blue.
(fh) Recalculating scores of the extension edges and updating the set of active edges.
(i, j) Removing repetitive edge p2.
(km) Recalculating scores for the remaining active edges {e1, e2} and removing e2 as non-active.
(n) Selecting the only active edge e1 as an extension for the path P i298 A.D.Prjibelski et al.viewed as subgenomes of the complete genome.
By mapping a read-pair to a long edge we can compute its insert size and thus classify read-pairs with abnormally large insert sizes as chimeric.
To estimate the parameter , we generate a large number of equally sized rectangles by artificially splitting each long edge into shorter edges of equal length (e.g.100bp) called uni-edges.
We then consider rectangles formed by all pairs of uni-edges within the same long edge.
Because we know the exact distance between such uni-edges, we can calculate the expected number of read-pairs ExpectedD(e1,e2) for all pairs of uni-edges within the same long edge.
If uni-edges e1 and e2 come from the same long edge and ExpectedD(e1,e2)=0, then all points in the confidence strip StripD(e1,e2) represent chimeric read-pairs connecting e1 and e2.
Such edge-pair (e1,e2) is classified as a false edge-pair.
Otherwise, if ExpectedDe1; e240, we assume that all points within StripDe1; e2 represent correct read-pairs and classify (e1,e2) as a true edge-pair.
Edges e1 and e2 and a parameter D define the strip StripD(e1,e2) with the number of points PointsD(e1,e2).
For a pair of edges e1 and e2, we define D=argmax D PointsDe1; e2: When (e1,e2) is a false edge-pair, D * defines a confidence strip S tripD e1; e2 with the maximum number of chimeric read-pairs.
To compute the threshold , we assume this worst-case scenario for all pairs of uni-edges (within the same long edge) by using distance D* (rather than the known genomic distance) for calculating the densities DensityD e1; e2.
For a certain value of we define false positives (false negatives) as the false (true) edge-pairs that have density higher (lower) than 0.
Figures 8a and b illustrate how false-positive rate (green) and false-negative rate (blue) depend on the parameter.
EXSPANDER selects that corresponds to the intersection point of the false-positive and false-negative plots.
Our benchmarking revealed that such choice of the parameter allows one to filter out the rectangles containing only chimeric reads-pairs based on their densities.
Additional analysis revealed that estimating the parameter is an important step in the EXSPANDER algorithm because varying this parameter may significantly affect the assembly quality (see Section 3 in Appendix).
3.4.2 The decision rule Our analysis revealed that varying parameters C and within specified ranges (see Section 3 of the Appendix) hardly affects the quality of the resulting assemblies.
However, selecting inappropriate C and may result in a deteriorated performance of EXSPANDER.
Thus, we arbitrarily select these parameters within the ranges specified in Section 3 of Appendix (analysis of diverse sequencing datasets supports the default values C=1.5 and =0.5).
4 RESULTS 4.1.1 Datasets We have compared EXSPANDER (coupled with SPAdes assembler) with several popular assemblers on the B.faecium isolate dataset (genome size 3.6 Mb) and the S.aureus single-cell dataset (genome size 2.9 Mb).
For each dataset we have generated assemblies of (i) only paired-end library and (ii) both paired-end and jumping libraries.
Section 1 of Appendix provides a detailed description of both datasets.
4.1.2 Benchmarking assemblies ABySS 1.3.6, Ray 2.0.0, Velvet, Velvet-SC and SOAPdenovo 2.0.4 were run with k-mer size 55.
IDBA-UD 1.1.1 was run in its default iterative mode.
The authors of (Peng et al., 2012) released this new version of IDBA-UD that is capable of using several paired-end libraries, but there is no manuscript yet covering this new development.
ALLPATHS-LG was run with the default parameters; however, we down-sampled jumping library for the B.faecium dataset to generate 100 coverage required by ALLPATHS-LG.
SPAdes 2.4 (previous version of SPAdes that did not include EXSPANDER and did not support multiple libraries) was run in its default iterative mode with k=21, 33, 55, 77 for the B.faecium dataset and k=21, 33, 55 for the S.aureus dataset.
EXSPANDER (coupled with SPAdes) was run using the default parameters.
To analyze the resulting assemblies we used QUAST 2.2 (Gurevich et al., 2013) that reports various parameters including NG50 (similar to N50, but is calculated with respect to the reference genome size), the total number of contigs/scaffolds, the length of the longest assembled contig/scaffold, the number of misassemblies and the fraction of genome mapped.
QUAST defines a misassembly breakpoint as a position in the contig/scaffold, such that its left and right flanking sequences either align to the reference genome over 1 kb away from each other, or overlap by41 kb, or align on opposite strands or different chromosomes (Gurevich et al., 2013).
To compare assemblers we used both contigs and scaffolds of length exceeding 500 bp.
Fig.7.
An example of a composite rectangle formed by paths (p1, p2, p3) and p01; p02; p03 Fig.8.
Plots of the false-positive (green) and false-negative (blue) rates for (a) B.facium and (b) S.aureus paired-end libraries i299 ExSPAnder `` '' Since 8 since p p 7 ] , x 20 ] p p 20 ] Tables 2 and 3 show the benchmarking results for the B.faecium isolate dataset.
Interestingly, the single-cell assemblers (IDBA-UD and EXSPANDER coupled with SPAdes) as well as ABySS performed well on the B.faecium isolate dataset and produced contigs with the largest NG50 in the case of a single library.
While AbySS generated the assembly with the maximal genome fraction, manual inspection revealed that it reflects the specifics of ABySS and QUAST reporting (mapping each repeat to a single position in the genome) rather than real superiority of ABySS by this metric.
In the case of two libraries, EXSPANDER produced the best contigs while ALLPATHS-LG produced the best scaffolds.
The complexity of using jumping libraries is reflected in a deteriorated performance of ABySS and Ray (reduction in NG50) as well as Velvet and Velvet-SC (dramatic increase in the number of misassemblies).
Tables 4 and 5 compare various assemblers on the S.aureus single-cell dataset.
This comparison highlights the complexity of both (i) assembling single-cell datasets and (ii) using jumping libraries.
For example, SOAPdenovo produced assemblies of poor quality for single-cell data (we decided not to include it in Tables 4 and 5).
Similarly, ABySS produced assemblies with high number of misassemblies for the single-cell data.
Velvet and Velvet-SC are not included in the benchmark experiment for jumping libraries testing because they also produce low-quality assemblies when both paired-end and jumping libraries are used simultaneously.
IDBA-UD performed well on a single pairedend library, but produced an assembly of lower quality when both libraries were provided (decreased NG50).
EXSPANDER produced assemblies with the highest NG50 and largest assembled contig/scaffold.
Using only paired-end library IDBA-UD, SPAdes 2.4 and EXSPANDER recovered the largest fraction of the genome (498.5%).
However, the highest genome fraction of the assembly Table 2.
Comparison of contigs for the B.faecium isolate dataset Assembler NG50 Number of contigs Largest Number of mis GF Only paired-end library ABySS 203 40 672 0 99.9 Ray 114 51 436 1 98.9 SOAPdenovo 20 333 61 0 98.8 Velvet 144 47 550 0 99.4 Velvet-SC 163 46 550 0 99.4 IDBA-UD 202 39 483 0 99.4 SPAdes 2.4 361 24 635 1 99.7 EXSPANDER 380 22 672 1 99.5 Both paired-end and jumping libraries ABySS 203 40 672 0 99.9 ALLPATHS-LG 313 21 686 0 99.5 Ray 87 88 416 2 96.8 SOAPdenovo 20 333 61 0 98.8 Velvet 103 75 242 11 99.0 Velvet-SC 253 40 545 15 99.8 IDBA-UD 207 41 483 0 99.4 EXSPANDER 3268 2 3268 1 99.9 Note: NG50 is given in kb; number of contigs is the total number of contigs 4500bp; largest stands for the length (in kb) of the longest contig assembled; number of mis is the number of misassemblies; GF stands for the fraction of genome mapped given in percent.
In each column, the best value is indicated in bold.
Table 3.
Comparison of scaffolds for the B.faecium isolate dataset Assembler NG50 Number of scaffolds Largest Number of mis GF Only paired-end library ABySS 383 24 676 0 99.9 Ray 204 31 553 1 98.9 SOAPdenovo 477 26 724 0 99.3 Velvet 477 28 724 0 99.4 Velvet-SC 477 28 724 0 99.4 IDBA-UD 250 30 671 0 99.4 SPAdes 2.4 361 22 671 1 99.7 EXSPANDER 380 22 672 1 99.5 Both paired-end and jumping libraries ABySS 250 30 739 1 99.9 ALLPATHS-LG 3610 7 3610 1 99.5 Ray 106 75 416 2 96.8 SOAPdenovo 480 28 810 2 99.4 Velvet 2651 14 2651 78 99.1 Velvet-SC 945 102 1381 500 98.9 IDBA-UD 1002 9 1692 0 99.4 EXSPANDER 3268 2 3268 1 99.9 Note: NG50 is given in kb; number of scaffolds is the total number of scaffolds 4500 bp; largest stands for the length (in kb) of the longest scaffold assembled; number of mis is the number of misassemblies; GF stands for the fraction of genome mapped given in percent.
In each column, the best value is indicated in bold.
Table 4.
Comparison of contigs for the S.aureus single-cell dataset Assembler NG50 Number of contigs Largest Number of mis GF Only paired-end library ABySS 27 914 91 262 98.0 Ray 21 306 108 14 88.7 Velvet 10 538 56 2 93.2 Velvet-SC 9 616 56 4 94.2 IDBA-UD 75 390 161 7 98.6 SPAdes 2.4 98 400 230 8 99.1 EXSPANDER 148 366 275 3 98.6 Both paired-end and jumping libraries ABySS 27 914 91 262 98.0 ALLPATHS-LG 15 283 75 26 79.9 Ray 100 178 486 21 93.5 IDBA-UD 47 415 161 7 98.6 EXSPANDER 314 322 603 9 99.3 Note: NG50 is given in kb; number of contigs is the total number of contigs4500bp; largest stands for the length (in kb) of the longest contig assembled; number of mis is the number of misassemblies; GF stands for the fraction of genome mapped given in percent.
In each column, the best value is indicated in bold.
i300 A.D.Prjibelski et al.tiliz tiliz very very since more than generated by SPAdes 2.4 reflects the specifics of SPAdes 2.4 and QUAST reporting (some artifacts with reporting of repetitive regions) rather than real advantage of SPAdes 2.4 with respect to this parameter.
When using both libraries simultaneously, EXSPANDER produced assemblies with the highest genome fraction exceeding 99%, the largest genome fraction we saw across dozens of single-cell datasets assembled with SPAdes in the past 2 years.
Moreover, Tables 4 and 5 show that EXSPANDER successfully deals with the high rate of the chimeric read-pairs and relatively high variations in the insert size.
5 CONCLUSION We have presented EXSPANDER algorithm for resolving repeats using either a single or multiple read-pair libraries with different insert sizes, which is applicable for both single-cell and isolate bacterial datasets.
Benchmarks across eight popular assemblers demonstrate that EXSPANDER produces high-quality assemblies for datasets of different types.
Additionally, as illustrated by recent integration of Illumina and PacBio reads in SPAdes 3.0, EXSPANDER is a flexible approach that can be easily modified to work with diverse types of sequencing data.
ACKNOWLEDGEMENTS The B.faecium sequencing data were produced by the Joint Genome Institute in collaboration with the user community.
The S.aureus dataset was provided by the Human Microbiome Project (bioproject ID PRJNA236734).
Funding: This work was supported by the Government of the Russian Federation [grant numbers 11.G34.31.0018, 11.G34.31.0068]; the National Institutes of Health [3P41RR024851-02S1]; and the Russian Fund for Basic Research [12-01-00747-a to A.K.].
Conflict of Interest: none declared.
